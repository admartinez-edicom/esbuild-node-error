var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re2) {
      return objectToString(re2) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/object-filter-sequence/index.js
var require_object_filter_sequence = __commonJS({
  "node_modules/object-filter-sequence/index.js"(exports2, module2) {
    "use strict";
    var NotAFunctionError = class extends Error {
      constructor() {
        super("filter must be a function");
      }
    };
    function validateItems(items, orNumber) {
      if (orNumber && items.length === 1 && typeof items[0] === "number") {
        return;
      }
      if (!Array.isArray(items)) {
        throw new Error("items is undefined");
      }
      for (let item of items) {
        if (typeof item !== "function") {
          throw new NotAFunctionError();
        }
      }
    }
    var Filters = class extends Array {
      constructor(...items) {
        validateItems(items, true);
        super(...items);
      }
      static from(items) {
        validateItems(items);
        return super.from(items);
      }
      concat(...args) {
        const items = args.length > 1 ? args : Array.isArray(args[0]) ? args[0] : [args[0]];
        validateItems(items);
        return super.concat(...args);
      }
      push(...items) {
        validateItems(items);
        return super.push(...items);
      }
      unshift(...items) {
        validateItems(items);
        return super.unshift(...items);
      }
      process(payload) {
        let result = payload;
        this.some((filter) => {
          result = filter(result);
          return !result;
        });
        return result;
      }
    };
    module2.exports = Filters;
  }
});

// node_modules/stackframe/stackframe.js
var require_stackframe = __commonJS({
  "node_modules/stackframe/stackframe.js"(exports2, module2) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("stackframe", [], factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory();
      } else {
        root.StackFrame = factory();
      }
    })(exports2, function() {
      "use strict";
      function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
      }
      function _getter(p) {
        return function() {
          return this[p];
        };
      }
      var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"];
      var numericProps = ["columnNumber", "lineNumber"];
      var stringProps = ["fileName", "functionName", "source"];
      var arrayProps = ["args"];
      var objectProps = ["evalOrigin"];
      var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);
      function StackFrame(obj) {
        if (!obj) return;
        for (var i2 = 0; i2 < props.length; i2++) {
          if (obj[props[i2]] !== void 0) {
            this["set" + _capitalize(props[i2])](obj[props[i2]]);
          }
        }
      }
      StackFrame.prototype = {
        getArgs: function() {
          return this.args;
        },
        setArgs: function(v) {
          if (Object.prototype.toString.call(v) !== "[object Array]") {
            throw new TypeError("Args must be an Array");
          }
          this.args = v;
        },
        getEvalOrigin: function() {
          return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
          if (v instanceof StackFrame) {
            this.evalOrigin = v;
          } else if (v instanceof Object) {
            this.evalOrigin = new StackFrame(v);
          } else {
            throw new TypeError("Eval Origin must be an Object or StackFrame");
          }
        },
        toString: function() {
          var fileName = this.getFileName() || "";
          var lineNumber = this.getLineNumber() || "";
          var columnNumber = this.getColumnNumber() || "";
          var functionName = this.getFunctionName() || "";
          if (this.getIsEval()) {
            if (fileName) {
              return "[eval] (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
            }
            return "[eval]:" + lineNumber + ":" + columnNumber;
          }
          if (functionName) {
            return functionName + " (" + fileName + ":" + lineNumber + ":" + columnNumber + ")";
          }
          return fileName + ":" + lineNumber + ":" + columnNumber;
        }
      };
      StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf("(");
        var argsEndIndex = str.lastIndexOf(")");
        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(",");
        var locationString = str.substring(argsEndIndex + 1);
        if (locationString.indexOf("@") === 0) {
          var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, "");
          var fileName = parts[1];
          var lineNumber = parts[2];
          var columnNumber = parts[3];
        }
        return new StackFrame({
          functionName,
          args: args || void 0,
          fileName,
          lineNumber: lineNumber || void 0,
          columnNumber: columnNumber || void 0
        });
      };
      for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype["get" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype["set" + _capitalize(booleanProps[i])] = /* @__PURE__ */ function(p) {
          return function(v) {
            this[p] = Boolean(v);
          };
        }(booleanProps[i]);
      }
      for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype["set" + _capitalize(numericProps[j])] = /* @__PURE__ */ function(p) {
          return function(v) {
            if (!_isNumber(v)) {
              throw new TypeError(p + " must be a Number");
            }
            this[p] = Number(v);
          };
        }(numericProps[j]);
      }
      for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype["set" + _capitalize(stringProps[k])] = /* @__PURE__ */ function(p) {
          return function(v) {
            this[p] = String(v);
          };
        }(stringProps[k]);
      }
      return StackFrame;
    });
  }
});

// node_modules/error-stack-parser/error-stack-parser.js
var require_error_stack_parser = __commonJS({
  "node_modules/error-stack-parser/error-stack-parser.js"(exports2, module2) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define("error-stack-parser", ["stackframe"], factory);
      } else if (typeof exports2 === "object") {
        module2.exports = factory(require_stackframe());
      } else {
        root.ErrorStackParser = factory(root.StackFrame);
      }
    })(exports2, function ErrorStackParser(StackFrame) {
      "use strict";
      var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
      var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
      var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
      return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
          if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined") {
            return this.parseOpera(error);
          } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
            return this.parseV8OrIE(error);
          } else if (error.stack) {
            return this.parseFFOrSafari(error);
          } else {
            throw new Error("Cannot parse given Error object");
          }
        },
        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
          if (urlLike.indexOf(":") === -1) {
            return [urlLike];
          }
          var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
          var parts = regExp.exec(urlLike.replace(/[()]/g, ""));
          return [parts[1], parts[2] || void 0, parts[3] || void 0];
        },
        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !!line.match(CHROME_IE_STACK_REGEXP);
          }, this);
          return filtered.map(function(line) {
            if (line.indexOf("(eval ") > -1) {
              line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
            }
            var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
            var location = sanitizedLine.match(/ (\(.+\)$)/);
            sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
            var locationParts = this.extractLocation(location ? location[1] : sanitizedLine);
            var functionName = location && sanitizedLine || void 0;
            var fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];
            return new StackFrame({
              functionName,
              fileName,
              lineNumber: locationParts[1],
              columnNumber: locationParts[2],
              source: line
            });
          }, this);
        },
        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !line.match(SAFARI_NATIVE_CODE_REGEXP);
          }, this);
          return filtered.map(function(line) {
            if (line.indexOf(" > eval") > -1) {
              line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
            }
            if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
              return new StackFrame({
                functionName: line
              });
            } else {
              var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
              var matches = line.match(functionNameRegex);
              var functionName = matches && matches[1] ? matches[1] : void 0;
              var locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
              return new StackFrame({
                functionName,
                fileName: locationParts[0],
                lineNumber: locationParts[1],
                columnNumber: locationParts[2],
                source: line
              });
            }
          }, this);
        },
        parseOpera: function ErrorStackParser$$parseOpera(e) {
          if (!e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length) {
            return this.parseOpera9(e);
          } else if (!e.stack) {
            return this.parseOpera10(e);
          } else {
            return this.parseOpera11(e);
          }
        },
        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
          var lines = e.message.split("\n");
          var result = [];
          for (var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(new StackFrame({
                fileName: match[2],
                lineNumber: match[1],
                source: lines[i]
              }));
            }
          }
          return result;
        },
        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
          var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
          var lines = e.stacktrace.split("\n");
          var result = [];
          for (var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
              result.push(
                new StackFrame({
                  functionName: match[3] || void 0,
                  fileName: match[2],
                  lineNumber: match[1],
                  source: lines[i]
                })
              );
            }
          }
          return result;
        },
        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
          var filtered = error.stack.split("\n").filter(function(line) {
            return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
          }, this);
          return filtered.map(function(line) {
            var tokens = line.split("@");
            var locationParts = this.extractLocation(tokens.pop());
            var functionCall = tokens.shift() || "";
            var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
            var argsRaw;
            if (functionCall.match(/\(([^)]*)\)/)) {
              argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
            }
            var args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
            return new StackFrame({
              functionName,
              args,
              fileName: locationParts[0],
              lineNumber: locationParts[1],
              columnNumber: locationParts[2],
              source: line
            });
          }, this);
        }
      };
    });
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re2 = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re2, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major2 = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major2;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re2, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major2 = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major2}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re2[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re2[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re2[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major2 = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major: major2,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/elastic-apm-node/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/elastic-apm-node/lib/constants.js"(exports2, module2) {
    module2.exports = {
      // The default span or transaction `type`.
      DEFAULT_SPAN_TYPE: "custom",
      REDACTED: "[REDACTED]",
      OUTCOME_FAILURE: "failure",
      OUTCOME_SUCCESS: "success",
      OUTCOME_UNKNOWN: "unknown",
      RESULT_SUCCESS: "success",
      RESULT_FAILURE: "failure",
      // https://github.com/elastic/apm/blob/main/specs/agents/tracing-instrumentation-messaging.md#receiving-trace-context
      MAX_MESSAGES_PROCESSED_FOR_TRACE_CONTEXT: 1e3,
      // Config constants
      INTAKE_STRING_MAX_SIZE: 1024,
      CAPTURE_ERROR_LOG_STACK_TRACES_NEVER: "never",
      CAPTURE_ERROR_LOG_STACK_TRACES_MESSAGES: "messages",
      CAPTURE_ERROR_LOG_STACK_TRACES_ALWAYS: "always",
      CONTEXT_MANAGER_ASYNCHOOKS: "asynchooks",
      CONTEXT_MANAGER_ASYNCLOCALSTORAGE: "asynclocalstorage",
      TRACE_CONTINUATION_STRATEGY_CONTINUE: "continue",
      TRACE_CONTINUATION_STRATEGY_RESTART: "restart",
      TRACE_CONTINUATION_STRATEGY_RESTART_EXTERNAL: "restart_external"
    };
  }
});

// node_modules/elastic-apm-node/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/elastic-apm-node/lib/symbols.js"(exports2) {
    "use strict";
    exports2.unwrap = Symbol("ElasticAPMUnwrap");
    exports2.agentInitialized = Symbol("ElasticAPMAgentInitialized");
    exports2.knexStackObj = Symbol("ElasticAPMKnexStackObj");
    exports2.staticFile = Symbol("ElasticAPMStaticFile");
    exports2.expressMountStack = Symbol("ElasticAPMExpressMountStack");
    exports2.errorReportedSymbol = Symbol("ElasticAPMErrorReported");
    exports2.redisClientOptions = Symbol("ElasticAPMRedisClientOptions");
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/shimmer.js
var require_shimmer = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/shimmer.js"(exports2) {
    "use strict";
    var symbols = require_symbols();
    var isWrappedSym = Symbol("elasticAPMIsWrapped");
    exports2.wrap = wrap;
    exports2.massWrap = massWrap;
    exports2.unwrap = unwrap;
    var _agent;
    function logger() {
      if (!_agent) _agent = require_elastic_apm_node();
      return _agent.logger;
    }
    function isFunction(funktion) {
      return typeof funktion === "function";
    }
    function wrap(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger().debug("no original function %s to wrap", name);
        return;
      }
      if (!wrapper) {
        logger().debug({ stack: new Error().stack }, "no wrapper function");
        return;
      }
      if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
        logger().debug("original object and wrapper must be functions");
        return;
      }
      if (nodule[name][isWrappedSym]) {
        logger().debug("function %s already wrapped", name);
        return;
      }
      var desc = Object.getOwnPropertyDescriptor(nodule, name);
      if (desc && !desc.writable) {
        logger().debug("function %s is not writable", name);
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      wrapped[isWrappedSym] = true;
      wrapped[symbols.unwrap] = function elasticAPMUnwrap() {
        if (nodule[name] === wrapped) {
          nodule[name] = original;
          wrapped[isWrappedSym] = false;
        }
      };
      nodule[name] = wrapped;
      return wrapped;
    }
    function massWrap(nodules, names, wrapper) {
      if (!nodules) {
        logger().debug(
          { stack: new Error().stack },
          "must provide one or more modules to patch"
        );
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger().debug("must provide one or more functions to wrap on modules");
        return;
      }
      for (const nodule of nodules) {
        for (const name of names) {
          wrap(nodule, name, wrapper);
        }
      }
    }
    function unwrap(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger().debug({ stack: new Error().stack }, "no function to unwrap");
        return;
      }
      if (!nodule[name][symbols.unwrap]) {
        logger().debug(
          "no original to unwrap to -- has %s already been unwrapped?",
          name
        );
      } else {
        return nodule[name][symbols.unwrap]();
      }
    }
  }
});

// node_modules/elastic-apm-node/lib/lambda.js
var require_lambda = __commonJS({
  "node_modules/elastic-apm-node/lib/lambda.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var shimmer = require_shimmer();
    var fs = require("fs");
    var path = require("path");
    var querystring = require("querystring");
    var { MAX_MESSAGES_PROCESSED_FOR_TRACE_CONTEXT } = require_constants2();
    var isFirstRun = true;
    var gFaasId;
    var TRIGGER_GENERIC = 1;
    var TRIGGER_API_GATEWAY = 2;
    var TRIGGER_SNS = 3;
    var TRIGGER_SQS = 4;
    var TRIGGER_S3_SINGLE_EVENT = 5;
    var TRIGGER_ELB = 6;
    function triggerTypeFromEvent(event) {
      if (event.requestContext) {
        if (event.requestContext.elb) {
          return TRIGGER_ELB;
        } else if (event.requestContext.requestId) {
          return TRIGGER_API_GATEWAY;
        }
      }
      if (event.Records && event.Records.length >= 1) {
        const eventSource = event.Records[0].eventSource || // S3 and SQS
        event.Records[0].EventSource;
        if (eventSource === "aws:sns") {
          return TRIGGER_SNS;
        } else if (eventSource === "aws:sqs") {
          return TRIGGER_SQS;
        } else if (eventSource === "aws:s3" && event.Records.length === 1) {
          return TRIGGER_S3_SINGLE_EVENT;
        }
      }
      return TRIGGER_GENERIC;
    }
    function getMetadata(agent, cloudAccountId) {
      return {
        service: {
          framework: {
            // Passing this service.framework.name to Client#setExtraMetadata()
            // ensures that it "wins" over a framework name from
            // `agent.setFramework()`, because in the client `_extraMetadata`
            // wins over `_conf.frameworkName`.
            name: "AWS Lambda"
          },
          runtime: {
            name: process.env.AWS_EXECUTION_ENV
          },
          node: {
            configured_name: process.env.AWS_LAMBDA_LOG_STREAM_NAME
          }
        },
        cloud: {
          provider: "aws",
          region: process.env.AWS_REGION,
          service: {
            name: "lambda"
          },
          account: {
            id: cloudAccountId
          }
        }
      };
    }
    function getFaasData(context2, faasId, isColdStart, faasTriggerType, requestId) {
      const faasData = {
        id: faasId,
        name: context2.functionName,
        version: context2.functionVersion,
        coldstart: isColdStart,
        execution: context2.awsRequestId,
        trigger: {
          type: faasTriggerType
        }
      };
      if (requestId) {
        faasData.trigger.request_id = requestId;
      }
      return faasData;
    }
    function setGenericData(trans, event, context2, faasId, isColdStart) {
      trans.type = "request";
      trans.setDefaultName(context2.functionName);
      trans.setFaas(getFaasData(context2, faasId, isColdStart, "other"));
      const cloudContext = {
        origin: {
          provider: "aws"
        }
      };
      trans.setCloudContext(cloudContext);
    }
    function setApiGatewayData(agent, trans, event, context2, faasId, isColdStart) {
      const requestContext = event.requestContext;
      let name;
      let pseudoReq;
      if (requestContext.http) {
        if (agent._conf.usePathAsTransactionName) {
          name = `${requestContext.http.method} ${requestContext.http.path}`;
        } else {
          let routeKeyPath = requestContext.routeKey;
          const spaceIdx = routeKeyPath.indexOf(" ");
          if (spaceIdx === -1) {
            routeKeyPath = "/" + routeKeyPath;
          } else {
            routeKeyPath = routeKeyPath.slice(spaceIdx + 1);
          }
          name = `${requestContext.http.method} /${requestContext.stage}${routeKeyPath}`;
        }
        pseudoReq = {
          httpVersion: requestContext.http.protocol ? requestContext.http.protocol.split("/")[1] : void 0,
          method: requestContext.http.method,
          url: event.rawPath + (event.rawQueryString ? "?" + event.rawQueryString : ""),
          headers: event.normedHeaders || {},
          socket: { remoteAddress: requestContext.http.sourceIp },
          body: event.body
        };
      } else {
        if (agent._conf.usePathAsTransactionName) {
          name = `${requestContext.httpMethod} ${requestContext.path}`;
        } else {
          name = `${requestContext.httpMethod} /${requestContext.stage}${requestContext.resourcePath}`;
        }
        pseudoReq = {
          httpVersion: requestContext.protocol ? requestContext.protocol.split("/")[1] : void 0,
          method: requestContext.httpMethod,
          url: requestContext.path + (event.queryStringParameters ? "?" + querystring.encode(event.queryStringParameters) : ""),
          headers: event.normedHeaders || {},
          socket: {
            remoteAddress: requestContext.identity && requestContext.identity.sourceIp
          },
          // Limitation: Note that `getContextFromRequest` does *not* use this body,
          // because API Gateway payload format 1.0 does not include the
          // Content-Length header from the original request.
          body: event.body
        };
      }
      trans.type = "request";
      trans.setDefaultName(name);
      trans.req = pseudoReq;
      trans.setFaas(
        getFaasData(context2, faasId, isColdStart, "http", requestContext.requestId)
      );
      const serviceContext = {
        origin: {
          name: requestContext.domainName,
          id: requestContext.apiId,
          version: event.version || "1.0"
        }
      };
      trans.setServiceContext(serviceContext);
      const originSvcName = (
        // `<url-id>.lambda-url.<region>.on.aws` indicates this is a Lambda URL.
        requestContext.domainName && requestContext.domainPrefix && requestContext.domainName.startsWith(
          requestContext.domainPrefix + ".lambda-url."
        ) ? "lambda url" : "api gateway"
      );
      const cloudContext = {
        origin: {
          provider: "aws",
          service: {
            name: originSvcName
          },
          account: {
            id: requestContext.accountId
          }
        }
      };
      trans.setCloudContext(cloudContext);
    }
    function setTransDataFromApiGatewayResult(err, result, trans, event) {
      if (err) {
        trans.result = "HTTP 5xx";
        trans._setOutcomeFromHttpStatusCode(500);
      } else if (result && result.statusCode) {
        trans.result = "HTTP " + result.statusCode.toString()[0] + "xx";
        trans._setOutcomeFromHttpStatusCode(result.statusCode);
      } else {
        trans.result = constants.RESULT_SUCCESS;
        trans._setOutcomeFromHttpStatusCode(200);
      }
      if (err) {
        trans.res = {
          statusCode: 500
        };
      } else if (event.requestContext.http) {
        if (result && result.statusCode) {
          trans.res = {
            statusCode: result.statusCode,
            headers: result.headers
          };
        } else {
          trans.res = {
            statusCode: 200,
            headers: { "content-type": "application/json" }
          };
        }
      } else {
        if (result && result.statusCode) {
          trans.res = {
            statusCode: result.statusCode,
            headers: result.headers
          };
        }
      }
    }
    function setElbData(agent, trans, event, context2, faasId, isColdStart) {
      trans.type = "request";
      let name;
      if (agent._conf.usePathAsTransactionName) {
        name = `${event.httpMethod} ${event.path}`;
      } else {
        name = `${event.httpMethod} unknown route`;
      }
      trans.setDefaultName(name);
      trans.req = {
        // Used by parsers.getContextFromRequest() for adding context to transaction and errors.
        method: event.httpMethod,
        url: event.path + (event.queryStringParameters && Object.keys(event.queryStringParameters) > 0 ? "?" + querystring.encode(event.queryStringParameters) : ""),
        headers: event.normedHeaders || {},
        body: event.body,
        bodyIsBase64Encoded: event.isBase64Encoded
      };
      trans.setFaas(getFaasData(context2, faasId, isColdStart, "http"));
      const targetGroupArn = event.requestContext.elb.targetGroupArn;
      const arnParts = targetGroupArn.split(":");
      trans.setServiceContext({
        origin: {
          name: arnParts[5].split("/")[1],
          id: targetGroupArn
        }
      });
      trans.setCloudContext({
        origin: {
          provider: "aws",
          region: arnParts[3],
          service: {
            name: "elb"
          },
          account: {
            id: arnParts[4]
          }
        }
      });
    }
    function setTransDataFromElbResult(err, result, trans) {
      const validStatusCode = result && result.statusCode && typeof result.statusCode === "number" && Number.isInteger(result.statusCode) ? result.statusCode : null;
      if (err) {
        trans.result = "HTTP 5xx";
      } else if (validStatusCode) {
        trans.result = "HTTP " + validStatusCode.toString()[0] + "xx";
      } else {
        trans.result = "HTTP 5xx";
      }
      if (err) {
        trans.res = {
          statusCode: 502
        };
      } else {
        trans.res = {
          statusCode: validStatusCode || 502,
          headers: result.headers
        };
      }
      trans._setOutcomeFromHttpStatusCode(validStatusCode || 502);
    }
    function setSqsData(agent, trans, event, context2, faasId, isColdStart) {
      const record = event && event.Records && event.Records[0];
      const eventSourceARN = record.eventSourceARN ? record.eventSourceARN : "";
      trans.setFaas(getFaasData(context2, faasId, isColdStart, "pubsub"));
      const arnParts = eventSourceARN.split(":");
      const queueName = arnParts[5];
      const accountId = arnParts[4];
      trans.setDefaultName(`RECEIVE ${queueName}`);
      trans.type = "messaging";
      const serviceContext = {
        origin: {
          name: queueName,
          id: eventSourceARN
        }
      };
      trans.setServiceContext(serviceContext);
      const cloudContext = {
        origin: {
          provider: "aws",
          region: record.awsRegion,
          service: {
            name: "sqs"
          },
          account: {
            id: accountId
          }
        }
      };
      trans.setCloudContext(cloudContext);
      const links = spanLinksFromSqsRecords(event.Records);
      trans.addLinks(links);
    }
    function setSnsData(agent, trans, event, context2, faasId, isColdStart) {
      const record = event && event.Records && event.Records[0];
      const sns = record && record.Sns;
      trans.setFaas(getFaasData(context2, faasId, isColdStart, "pubsub"));
      const topicArn = sns && sns.TopicArn || "";
      const arnParts = topicArn.split(":");
      const topicName = arnParts[5];
      const accountId = arnParts[4];
      const region = arnParts[3];
      trans.setDefaultName(`RECEIVE ${topicName}`);
      trans.type = "messaging";
      const serviceContext = {
        origin: {
          name: topicName,
          id: topicArn
        }
      };
      trans.setServiceContext(serviceContext);
      const cloudContext = {
        origin: {
          provider: "aws",
          region,
          service: {
            name: "sns"
          },
          account: {
            id: accountId
          }
        }
      };
      trans.setCloudContext(cloudContext);
      const links = spanLinksFromSnsRecords(event.Records);
      trans.addLinks(links);
    }
    function setS3SingleData(trans, event, context2, faasId, isColdStart) {
      const record = event.Records[0];
      trans.setFaas(
        getFaasData(
          context2,
          faasId,
          isColdStart,
          "datasource",
          record.responseElements && record.responseElements["x-amz-request-id"]
        )
      );
      trans.setDefaultName(
        `${record && record.eventName} ${record && record.s3 && record.s3.bucket && record.s3.bucket.name}`
      );
      trans.type = "request";
      const serviceContext = {
        origin: {
          name: record && record.s3 && record.s3.bucket && record.s3.bucket.name,
          id: record && record.s3 && record.s3.bucket && record.s3.bucket.arn,
          version: record.eventVersion
        }
      };
      trans.setServiceContext(serviceContext);
      const cloudContext = {
        origin: {
          provider: "aws",
          service: {
            name: "s3"
          },
          region: record.awsRegion
        }
      };
      trans.setCloudContext(cloudContext);
    }
    function elasticApmAwsLambda(agent) {
      const log = agent.logger;
      const ins = agent._instrumentation;
      function registerTransaction(trans, awsRequestId) {
        if (!agent._apmClient) {
          return;
        }
        if (!agent._apmClient.lambdaShouldRegisterTransactions()) {
          return;
        }
        if (agent._conf.contextPropagationOnly) {
          return;
        }
        if (!trans.sampled && !agent._apmClient.supportsKeepingUnsampledTransaction()) {
          return;
        }
        var payload = trans.toJSON();
        delete payload.result;
        delete payload.duration;
        payload = agent._transactionFilters.process(payload);
        if (!payload) {
          log.trace(
            { traceId: trans.traceId, transactionId: trans.id },
            "transaction ignored by filter"
          );
          return;
        }
        return agent._apmClient.lambdaRegisterTransaction(payload, awsRequestId);
      }
      function endAndFlushTransaction(err, result, trans, event, context2, triggerType, cb) {
        log.trace(
          { awsRequestId: context2 && context2.awsRequestId },
          "lambda: fn end"
        );
        switch (triggerType) {
          case TRIGGER_API_GATEWAY:
            setTransDataFromApiGatewayResult(err, result, trans, event);
            break;
          case TRIGGER_ELB:
            setTransDataFromElbResult(err, result, trans);
            break;
          default:
            if (err) {
              trans.result = constants.RESULT_FAILURE;
              trans.setOutcome(constants.OUTCOME_FAILURE);
            } else {
              trans.result = constants.RESULT_SUCCESS;
              trans.setOutcome(constants.OUTCOME_SUCCESS);
            }
            break;
        }
        if (err) {
          agent.captureError(err, { skipOutcome: true });
        }
        trans.end();
        agent._flush({ lambdaEnd: true, inflightTimeout: 100 }, (flushErr) => {
          if (flushErr) {
            log.error(
              { err: flushErr, awsRequestId: context2 && context2.awsRequestId },
              "lambda: flush error"
            );
          }
          log.trace(
            { awsRequestId: context2 && context2.awsRequestId },
            "lambda: wrapper end"
          );
          cb();
        });
      }
      function wrapContext(runContext, trans, event, context2, triggerType) {
        shimmer.wrap(context2, "succeed", (origSucceed) => {
          return ins.bindFunctionToRunContext(
            runContext,
            function wrappedSucceed(result) {
              endAndFlushTransaction(
                null,
                result,
                trans,
                event,
                context2,
                triggerType,
                function() {
                  origSucceed(result);
                }
              );
            }
          );
        });
        shimmer.wrap(context2, "fail", (origFail) => {
          return ins.bindFunctionToRunContext(
            runContext,
            function wrappedFail(err) {
              endAndFlushTransaction(
                err,
                null,
                trans,
                event,
                context2,
                triggerType,
                function() {
                  origFail(err);
                }
              );
            }
          );
        });
        shimmer.wrap(context2, "done", (origDone) => {
          return wrapLambdaCallback(
            runContext,
            trans,
            event,
            context2,
            triggerType,
            origDone
          );
        });
      }
      function wrapLambdaCallback(runContext, trans, event, context2, triggerType, callback) {
        return ins.bindFunctionToRunContext(
          runContext,
          function wrappedLambdaCallback(err, result) {
            endAndFlushTransaction(
              err,
              result,
              trans,
              event,
              context2,
              triggerType,
              () => {
                callback(err, result);
              }
            );
          }
        );
      }
      return function wrapLambdaHandler(type, fn) {
        if (typeof type === "function") {
          fn = type;
          type = "request";
        }
        if (!agent._conf.active) {
          return fn;
        }
        return async function wrappedLambdaHandler(event, context2, callback) {
          if (!(event && context2 && typeof callback === "function")) {
            return fn.call(this, ...arguments);
          }
          log.trace({ awsRequestId: context2.awsRequestId }, "lambda: fn start");
          const isColdStart = isFirstRun;
          if (isFirstRun) {
            isFirstRun = false;
            const arnParts = context2.invokedFunctionArn.split(":");
            gFaasId = arnParts.slice(0, 7).join(":");
            const cloudAccountId = arnParts[4];
            if (agent._apmClient) {
              log.trace(
                { awsRequestId: context2.awsRequestId },
                "lambda: setExtraMetadata"
              );
              agent._apmClient.setExtraMetadata(getMetadata(agent, cloudAccountId));
            }
          }
          if (agent._apmClient) {
            agent._apmClient.lambdaStart();
          }
          const triggerType = triggerTypeFromEvent(event);
          let traceparent;
          let tracestate;
          if ((triggerType === TRIGGER_API_GATEWAY || triggerType === TRIGGER_ELB) && event.headers) {
            if (!event.requestContext.http) {
              event.normedHeaders = lowerCaseObjectKeys(event.headers);
            } else {
              event.normedHeaders = event.headers;
            }
            traceparent = event.normedHeaders.traceparent || event.normedHeaders["elastic-apm-traceparent"];
            tracestate = event.normedHeaders.tracestate;
          }
          const trans = agent.startTransaction(context2.functionName, type, {
            childOf: traceparent,
            tracestate
          });
          switch (triggerType) {
            case TRIGGER_API_GATEWAY:
              setApiGatewayData(agent, trans, event, context2, gFaasId, isColdStart);
              break;
            case TRIGGER_ELB:
              setElbData(agent, trans, event, context2, gFaasId, isColdStart);
              break;
            case TRIGGER_SQS:
              setSqsData(agent, trans, event, context2, gFaasId, isColdStart);
              break;
            case TRIGGER_SNS:
              setSnsData(agent, trans, event, context2, gFaasId, isColdStart);
              break;
            case TRIGGER_S3_SINGLE_EVENT:
              setS3SingleData(trans, event, context2, gFaasId, isColdStart);
              break;
            case TRIGGER_GENERIC:
              setGenericData(trans, event, context2, gFaasId, isColdStart);
              break;
            default:
              log.warn(
                `not setting transaction data for triggerType=${triggerType}`
              );
          }
          const transRunContext = ins.currRunContext();
          wrapContext(transRunContext, trans, event, context2, triggerType);
          const wrappedCallback = wrapLambdaCallback(
            transRunContext,
            trans,
            event,
            context2,
            triggerType,
            callback
          );
          await registerTransaction(trans, context2.awsRequestId);
          try {
            const retval = ins.withRunContext(
              transRunContext,
              fn,
              this,
              event,
              context2,
              wrappedCallback
            );
            if (retval instanceof Promise) {
              return retval;
            } else {
              return new Promise((resolve, reject) => {
              });
            }
          } catch (handlerErr) {
            wrappedCallback(handlerErr);
            return new Promise((resolve, reject) => {
            });
          }
        };
      };
    }
    function isLambdaExecutionEnvironment() {
      return !!process.env.AWS_LAMBDA_FUNCTION_NAME;
    }
    function getFilePath(taskRoot, handlerModule) {
      let filePath = path.resolve(taskRoot, `${handlerModule}.js`);
      if (!fs.existsSync(filePath)) {
        filePath = path.resolve(taskRoot, `${handlerModule}.cjs`);
      }
      return filePath;
    }
    function getLambdaHandlerInfo(env) {
      if (!isLambdaExecutionEnvironment() || !env._HANDLER || !env.LAMBDA_TASK_ROOT) {
        return null;
      }
      const functionExpression = /^([^.]*)\.(.*)$/;
      const match = env._HANDLER.match(functionExpression);
      if (!match || match.length !== 3) {
        return null;
      }
      const handlerModule = match[1].split("/").pop();
      const handlerFunctionPath = match[2];
      const handlerFilePath = getFilePath(env.LAMBDA_TASK_ROOT, match[1]);
      return {
        filePath: handlerFilePath,
        modName: handlerModule,
        propPath: handlerFunctionPath
      };
    }
    function lowerCaseObjectKeys(obj) {
      const lowerCased = {};
      for (const key of Object.keys(obj)) {
        lowerCased[key.toLowerCase()] = obj[key];
      }
      return lowerCased;
    }
    function spanLinksFromSqsRecords(records) {
      const links = [];
      const limit = Math.min(
        records.length,
        MAX_MESSAGES_PROCESSED_FOR_TRACE_CONTEXT
      );
      for (let i = 0; i < limit; i++) {
        const attrs = records[i].messageAttributes;
        if (!attrs) {
          continue;
        }
        let traceparent;
        const attrNames = Object.keys(attrs);
        for (let j = 0; j < attrNames.length; j++) {
          const attrVal = attrs[attrNames[j]];
          if (attrVal.dataType !== "String") {
            continue;
          }
          const attrNameLc = attrNames[j].toLowerCase();
          if (attrNameLc === "traceparent") {
            traceparent = attrVal.stringValue;
            break;
          }
        }
        if (traceparent) {
          links.push({ context: traceparent });
        }
      }
      return links;
    }
    function spanLinksFromSnsRecords(records) {
      const links = [];
      const limit = Math.min(
        records.length,
        MAX_MESSAGES_PROCESSED_FOR_TRACE_CONTEXT
      );
      for (let i = 0; i < limit; i++) {
        const attrs = records[i].Sns && records[i].Sns.MessageAttributes;
        if (!attrs) {
          continue;
        }
        let traceparent;
        const attrNames = Object.keys(attrs);
        for (let j = 0; j < attrNames.length; j++) {
          const attrVal = attrs[attrNames[j]];
          if (attrVal.Type !== "String") {
            continue;
          }
          const attrNameLc = attrNames[j].toLowerCase();
          if (attrNameLc === "traceparent") {
            traceparent = attrVal.Value;
            break;
          }
        }
        if (traceparent) {
          links.push({ context: traceparent });
        }
      }
      return links;
    }
    module2.exports = {
      isLambdaExecutionEnvironment,
      elasticApmAwsLambda,
      getLambdaHandlerInfo
    };
  }
});

// node_modules/elastic-apm-node/lib/activation-method.js
var require_activation_method = __commonJS({
  "node_modules/elastic-apm-node/lib/activation-method.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var errorStackParser = require_error_stack_parser();
    var semver = require_semver2();
    var { isLambdaExecutionEnvironment } = require_lambda();
    var CONTAINS_R_ELASTIC_APM_NODE_START = /(-r\s+|--require\s*=?\s*).*elastic-apm-node\/start/;
    function agentActivationMethodFromStartStack(startStack, log) {
      let frames;
      try {
        frames = errorStackParser.parse(startStack);
      } catch (parseErr) {
        log.trace(
          parseErr,
          "could not determine metadata.service.agent.activation_method"
        );
        return "unknown";
      }
      if (frames.length < 2) {
        return "unknown";
      }
      const topDir = path.dirname(path.dirname(frames[0].fileName));
      const functionName = semver.gte(process.version, "12.0.0", {
        includePrerelease: true
      }) ? "loadPreloadModules" : "preloadModules";
      let isPreload = false;
      for (let i = frames.length - 1; i >= 2; i--) {
        if (frames[i].functionName === functionName) {
          isPreload = true;
          break;
        }
      }
      if (isPreload) {
        if (isLambdaExecutionEnvironment && topDir === "/opt/nodejs/node_modules/elastic-apm-node") {
          return "aws-lambda-layer";
        } else if (process.env.ELASTIC_APM_ACTIVATION_METHOD === "K8S_ATTACH" || process.env.ELASTIC_APM_ACTIVATION_METHOD === "K8S") {
          return "k8s-attach";
        } else if (process.env.NODE_OPTIONS && CONTAINS_R_ELASTIC_APM_NODE_START.test(process.env.NODE_OPTIONS)) {
          return "env-attach";
        } else {
          return "preload";
        }
      }
      const esmImportFunctionName = "ModuleJob.run";
      if (esmImportFunctionName) {
        for (let i = frames.length - 1; i >= 2; i--) {
          if (frames[i].functionName === esmImportFunctionName) {
            return "import";
          }
        }
      }
      return "require";
    }
    module2.exports = {
      agentActivationMethodFromStartStack
    };
  }
});

// node_modules/is-finite/index.js
var require_is_finite = __commonJS({
  "node_modules/is-finite/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isFinite || function(value) {
      return !(typeof value !== "number" || value !== value || value === Infinity || value === -Infinity);
    };
  }
});

// node_modules/is-integer/index.js
var require_is_integer = __commonJS({
  "node_modules/is-integer/index.js"(exports2, module2) {
    var isFinite2 = require_is_finite();
    module2.exports = Number.isInteger || function(val) {
      return typeof val === "number" && isFinite2(val) && Math.floor(val) === val;
    };
  }
});

// node_modules/unicode-substring/dist/index.js
var require_dist = __commonJS({
  "node_modules/unicode-substring/dist/index.js"(exports2, module2) {
    "use strict";
    function charAt(string, index) {
      var first = string.charCodeAt(index);
      var second;
      if (first >= 55296 && first <= 56319 && string.length > index + 1) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return string.substring(index, index + 2);
        }
      }
      return string[index];
    }
    function slice(string, start, end) {
      var accumulator = "";
      var character;
      var stringIndex = 0;
      var unicodeIndex = 0;
      var length = string.length;
      while (stringIndex < length) {
        character = charAt(string, stringIndex);
        if (unicodeIndex >= start && unicodeIndex < end) {
          accumulator += character;
        }
        stringIndex += character.length;
        unicodeIndex += 1;
      }
      return accumulator;
    }
    function toNumber(value, fallback) {
      if (value === void 0) {
        return fallback;
      } else {
        return Number(value);
      }
    }
    module2.exports = function(string, start, end) {
      var realStart = toNumber(start, 0);
      var realEnd = toNumber(end, string.length);
      if (realEnd == realStart) {
        return "";
      } else if (realEnd > realStart) {
        return slice(string, realStart, realEnd);
      } else {
        return slice(string, realEnd, realStart);
      }
    };
  }
});

// node_modules/unicode-byte-truncate/index.js
var require_unicode_byte_truncate = __commonJS({
  "node_modules/unicode-byte-truncate/index.js"(exports2, module2) {
    "use strict";
    var isInteger = require_is_integer();
    var slice = require_dist();
    module2.exports = function(str, len) {
      if (typeof str !== "string") throw new Error("Expected first argument to be a string");
      if (!isInteger(len) || len < 0) throw new Error("Expected second argument be an integer greater than or equal to 0");
      var origLen = len;
      while (Buffer.byteLength(str) > origLen) {
        str = slice(str, 0, len--);
      }
      return str;
    };
  }
});

// node_modules/@elastic/ecs-helpers/lib/error-formatters.js
var require_error_formatters = __commonJS({
  "node_modules/@elastic/ecs-helpers/lib/error-formatters.js"(exports2, module2) {
    "use strict";
    var { toString } = Object.prototype;
    function formatError(ecsFields, err) {
      if (!(err instanceof Error)) {
        ecsFields.err = err;
        return false;
      }
      ecsFields.error = {
        type: toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name,
        message: err.message,
        stack_trace: err.stack
      };
      return true;
    }
    module2.exports = { formatError };
  }
});

// node_modules/@elastic/ecs-helpers/lib/http-formatters.js
var require_http_formatters = __commonJS({
  "node_modules/@elastic/ecs-helpers/lib/http-formatters.js"(exports2, module2) {
    "use strict";
    var REQUEST_ID_HEADERS = [
      "request-id",
      "x-request-id"
    ];
    function formatHttpRequest(ecs, req) {
      if (req === void 0 || req === null || typeof req !== "object") {
        return false;
      }
      if (req.raw && req.raw.req && req.raw.req.httpVersion) {
        req = req.raw.req;
      }
      if (!("httpVersion" in req && "headers" in req && "method" in req)) {
        return false;
      }
      const {
        method,
        headers,
        hostname,
        httpVersion,
        socket
      } = req;
      ecs.http = ecs.http || {};
      ecs.http.version = httpVersion;
      ecs.http.request = ecs.http.request || {};
      ecs.http.request.method = method;
      const url = req.originalUrl || req.url;
      ecs.url = ecs.url || {};
      ecs.url.full = (socket && socket.encrypted ? "https://" : "http://") + headers.host + url;
      const hasQuery = url.indexOf("?");
      const hasAnchor = url.indexOf("#");
      if (hasQuery > -1 && hasAnchor > -1) {
        ecs.url.path = url.slice(0, hasQuery);
        ecs.url.query = url.slice(hasQuery + 1, hasAnchor);
        ecs.url.fragment = url.slice(hasAnchor + 1);
      } else if (hasQuery > -1) {
        ecs.url.path = url.slice(0, hasQuery);
        ecs.url.query = url.slice(hasQuery + 1);
      } else if (hasAnchor > -1) {
        ecs.url.path = url.slice(0, hasAnchor);
        ecs.url.fragment = url.slice(hasAnchor + 1);
      } else {
        ecs.url.path = url;
      }
      if (hostname) {
        const [host, port] = hostname.split(":");
        ecs.url.domain = host;
        if (port) {
          ecs.url.port = Number(port);
        }
      }
      ecs.client = ecs.client || {};
      let ip;
      if (req.ip) {
        ip = req.ip;
      } else if (socket && socket.remoteAddress) {
        ip = socket.remoteAddress;
      }
      if (ip) {
        ecs.client.ip = ecs.client.address = ip;
      }
      if (socket) {
        ecs.client.port = socket.remotePort;
      }
      const hasHeaders = Object.keys(headers).length > 0;
      if (hasHeaders === true) {
        ecs.http.request.headers = Object.assign(ecs.http.request.headers || {}, headers);
        const cLen = Number(headers["content-length"]);
        if (!isNaN(cLen)) {
          ecs.http.request.body = ecs.http.request.body || {};
          ecs.http.request.body.bytes = cLen;
        }
        if (headers["user-agent"]) {
          ecs.user_agent = ecs.user_agent || {};
          ecs.user_agent.original = headers["user-agent"];
        }
      }
      let id = null;
      switch (typeof req.id) {
        case "string":
          id = req.id;
          break;
        case "number":
          id = req.id.toString();
          break;
        case "function":
          id = req.id();
          break;
      }
      if (!id && hasHeaders) {
        for (let i = 0; i < REQUEST_ID_HEADERS.length; i++) {
          const k = REQUEST_ID_HEADERS[i];
          if (headers[k]) {
            id = headers[k];
            break;
          }
        }
      }
      if (id) {
        ecs.http.request.id = id;
      }
      return true;
    }
    function formatHttpResponse(ecs, res) {
      if (res === void 0 || res === null || typeof res !== "object") {
        return false;
      }
      if (res.raw && res.raw.res && typeof res.raw.res.getHeaders === "function") {
        res = res.raw.res;
      }
      if (!("statusCode" in res && typeof res.getHeaders === "function")) {
        return false;
      }
      const { statusCode } = res;
      ecs.http = ecs.http || {};
      ecs.http.response = ecs.http.response || {};
      ecs.http.response.status_code = statusCode;
      const headers = res.getHeaders();
      const hasHeaders = Object.keys(headers).length > 0;
      if (hasHeaders === true) {
        ecs.http.response.headers = Object.assign(ecs.http.response.headers || {}, headers);
        const cLen = Number(headers["content-length"]);
        if (!isNaN(cLen)) {
          ecs.http.response.body = ecs.http.response.body || {};
          ecs.http.response.body.bytes = cLen;
        }
      }
      return true;
    }
    module2.exports = { formatHttpRequest, formatHttpResponse };
  }
});

// node_modules/@elastic/ecs-helpers/lib/index.js
var require_lib = __commonJS({
  "node_modules/@elastic/ecs-helpers/lib/index.js"(exports2, module2) {
    "use strict";
    var errorFormatters = require_error_formatters();
    var httpFormatters = require_http_formatters();
    module2.exports = {
      version: "8.10.0",
      ...errorFormatters,
      ...httpFormatters
    };
  }
});

// node_modules/@elastic/ecs-pino-format/index.js
var require_ecs_pino_format = __commonJS({
  "node_modules/@elastic/ecs-pino-format/index.js"(exports2, module2) {
    "use strict";
    var {
      version,
      formatError,
      formatHttpRequest,
      formatHttpResponse
    } = require_lib();
    var triedElasticApmImport = false;
    var elasticApm = null;
    function ecsFormat(opts) {
      opts = opts || {};
      const convertErr = opts.convertErr != null ? opts.convertErr : true;
      const convertReqRes = opts.convertReqRes != null ? opts.convertReqRes : false;
      const apmIntegration = opts.apmIntegration != null ? opts.apmIntegration : true;
      let apm = null;
      if (apmIntegration) {
        if (opts && opts._elasticApm) {
          elasticApm = opts._elasticApm;
        } else if (!triedElasticApmImport) {
          triedElasticApmImport = true;
          try {
            elasticApm = require_elastic_apm_node();
          } catch (ex) {
          }
        }
        if (elasticApm && elasticApm.isStarted && elasticApm.isStarted()) {
          apm = elasticApm;
        }
      }
      let serviceName = opts.serviceName;
      if (serviceName == null && apm) {
        serviceName = apm.getServiceName ? apm.getServiceName() : apm._conf.serviceName;
      }
      let serviceVersion = opts.serviceVersion;
      if (serviceVersion == null && apm) {
        serviceVersion = apm.getServiceVersion ? apm.getServiceVersion() : apm._conf.serviceVersion;
      }
      let serviceEnvironment = opts.serviceEnvironment;
      if (serviceEnvironment == null && apm) {
        serviceEnvironment = apm.getServiceEnvironment ? apm.getServiceEnvironment() : apm._conf.environment;
      }
      let serviceNodeName = opts.serviceNodeName;
      if (serviceNodeName == null && apm) {
        serviceNodeName = apm.getServiceNodeName ? apm.getServiceNodeName() : apm._conf.serviceNodeName;
      }
      let eventDataset = opts.eventDataset;
      if (eventDataset == null && serviceName) {
        eventDataset = serviceName;
      }
      let wasBindingsCalled = false;
      function addStaticEcsBindings(obj) {
        obj["ecs.version"] = version;
        if (serviceName) {
          obj["service.name"] = serviceName;
        }
        if (serviceVersion) {
          obj["service.version"] = serviceVersion;
        }
        if (serviceEnvironment) {
          obj["service.environment"] = serviceEnvironment;
        }
        if (serviceNodeName) {
          obj["service.node.name"] = serviceNodeName;
        }
        if (eventDataset) {
          obj["event.dataset"] = eventDataset;
        }
      }
      const ecsPinoOptions = {
        messageKey: "message",
        timestamp: () => `,"@timestamp":"${(/* @__PURE__ */ new Date()).toISOString()}"`,
        formatters: {
          level(label, number) {
            return { "log.level": label };
          },
          bindings(bindings) {
            const {
              // `pid` and `hostname` are default bindings, unless overriden by
              // a `base: {...}` passed to logger creation.
              pid,
              hostname,
              // name is defined if `log = pino({name: 'my name', ...})`
              name,
              ...ecsBindings
            } = bindings;
            if (pid !== void 0) {
              ecsBindings["process.pid"] = pid;
            }
            if (hostname !== void 0) {
              ecsBindings["host.hostname"] = hostname;
            }
            if (name !== void 0) {
              ecsBindings["log.logger"] = name;
            }
            wasBindingsCalled = true;
            addStaticEcsBindings(ecsBindings);
            return ecsBindings;
          },
          log(obj) {
            const {
              req,
              res,
              err,
              ...ecsObj
            } = obj;
            if (!wasBindingsCalled) {
              addStaticEcsBindings(ecsObj);
            }
            if (apm) {
              const tx = apm.currentTransaction;
              if (tx) {
                ecsObj["trace.id"] = tx.traceId;
                ecsObj["transaction.id"] = tx.id;
                const span = apm.currentSpan;
                if (span) {
                  ecsObj["span.id"] = span.id;
                }
              }
            }
            if (err !== void 0) {
              if (!convertErr) {
                ecsObj.err = err;
              } else {
                formatError(ecsObj, err);
              }
            }
            if (req !== void 0) {
              if (!convertReqRes) {
                ecsObj.req = req;
              } else {
                formatHttpRequest(ecsObj, req);
              }
            }
            if (res !== void 0) {
              if (!convertReqRes) {
                ecsObj.res = res;
              } else {
                formatHttpResponse(ecsObj, res);
              }
            }
            return ecsObj;
          }
        }
      };
      return ecsPinoOptions;
    }
    module2.exports = ecsFormat;
    module2.exports.ecsFormat = ecsFormat;
    module2.exports.default = ecsFormat;
  }
});

// node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path = req.path;
        _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "node_modules/pino/lib/caller.js"(exports2, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "node_modules/fast-redact/lib/validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/〇/.test(s)) throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});

// node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "node_modules/fast-redact/lib/rx.js"(exports2, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// node_modules/fast-redact/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/fast-redact/lib/parse.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse;
    function parse({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o, strPath, ix) {
        var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path = path.map((p) => {
          if (p[0] === "[") return p.substr(1, p.length - 2);
          else return p;
        });
        const star = path.indexOf("*");
        if (star > -1) {
          const before = path.slice(0, star);
          const beforeStr = before.join(".");
          const after = path.slice(star + 1, path.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o[strPath] = {
            path,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);
      redact.state = state;
      if (serialize === false) {
        redact.restore = (o) => state.restore(o);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path} != null`;
        else existence += ` && o${delim}${path} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length = keys.length;
      for (var i = 0; i < length; i++) {
        const k = keys[i];
        target[k] = values[i];
      }
    }
    function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path);
      if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path.length;
      const pathWithKey = censorFctTakesPath ? [...path] : void 0;
      const values = new Array(keysLength);
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        values[i] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i = 0; i < instructions.length; i++) {
        const { target, path, value } = instructions[i];
        let current = target;
        for (let i2 = path.length - 1; i2 > 0; i2--) {
          current = current[path[i2]];
        }
        current[path[0]] = value;
      }
    }
    function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n = o[k];
      if (typeof n !== "object") return;
      while (n != null && ++i < afterPathLen) {
        depth += 1;
        k = afterPath[i];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i;
              ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get(o, p) {
      var i = -1;
      var l = p.length;
      var n = o;
      while (n != null && ++i < l) {
        n = n[p[i]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path = [];
      do {
        path.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path, value, target };
    }
  }
});

// node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state);
        this.restore.state = state;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path) => {
        const { circle, escPath, leadingBracket } = secret[path];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "node_modules/fast-redact/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(o) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false) builder.push({ serialize });
      if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});

// node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "node_modules/fast-redact/index.js"(exports2, module2) {
    "use strict";
    var validator = require_validator();
    var parse = require_parse2();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate = validator();
    var noop = (o) => o;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse({ paths, censor });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// node_modules/pino/lib/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols2();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [k, ...path]);
          } : censor;
          o[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});

// node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var EventEmitter = require("events");
    var inherits = require("util").inherits;
    var path = require("path");
    var sleep = require_atomic_sleep();
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs.mkdirSync(path.dirname(file), { recursive: true });
          const fd = fs.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs.mkdir(path.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs.open(file, flags, mode, fileOpened);
        });
      } else {
        fs.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n2 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function releaseWritingBuf(writingBuf, len, n) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
      }
      len = Math.max(len - n, 0);
      writingBuf = writingBuf.slice(n);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([data]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          fs.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf = "";
      while (this._bufs.length || buf) {
        if (buf.length <= 0) {
          buf = this._bufs[0];
        }
        try {
          const n = fs.writeSync(this.fd, buf, "utf8");
          const releasedBufObj = releaseWritingBuf(buf, this._len, n);
          buf = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf = kEmptyBuffer;
      while (this._bufs.length || buf.length) {
        if (buf.length <= 0) {
          buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n = fs.writeSync(this.fd, buf);
          buf = buf.subarray(n);
          this._len = Math.max(this._len - n, 0);
          if (buf.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      fs.fsync(sonic.fd, closeWrapped);
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});

// node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "node_modules/on-exit-leak-free/index.js"(exports2, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry;
    function ensureRegistry() {
      if (registry === void 0) {
        registry = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry === void 0) {
        return;
      }
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// node_modules/thread-stream/package.json
var require_package = __commonJS({
  "node_modules/thread-stream/package.json"(exports2, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "2.7.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^3.0.0",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        test: 'standard && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "node_modules/thread-stream/lib/wait.js"(exports2, module2) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check(1);
    }
    module2.exports = { wait, waitDiff };
  }
});

// node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "node_modules/thread-stream/index.js"(exports2, module2) {
    "use strict";
    var { version } = require_package();
    var { EventEmitter } = require("events");
    var { Worker } = require("worker_threads");
    var { join } = require("path");
    var { pathToFileURL } = require("url");
    var { wait } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = require("buffer");
    var assert = require("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});

// node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "node_modules/pino/lib/transport.js"(exports2, module2) {
    "use strict";
    var { createRequire } = require("module");
    var getCallers = require_caller();
    var { join, isAbsolute, sep } = require("path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, options = {}, worker = {}, caller = getCallers() } = fullOptions;
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
        options.targets = targets.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-pipeline-worker"] || join(__dirname, "worker-pipeline.js");
        options.targets = pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      options.pinoWillSendConfig = true;
      return buildStream(fixTarget(target), options, worker);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context2 = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context2).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols2();
    var { isMainThread } = require("worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o, ...n) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o === void 0 ? n.shift() : o;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point >= 32; i++) {
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions, opts);
        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// node_modules/pino/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/pino/lib/constants.js"(exports2, module2) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module2.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols2();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants3();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
      o[DEFAULT_LEVELS[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = '{"level":' + Number(k);
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    module2.exports = { version: "8.21.0" };
  }
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym
    } = require_symbols2();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(s);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function insertSort(array) {
      if (array.length > 200) {
        return array.sort();
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getBooleanOption(options, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "node_modules/pino/lib/multistream.js"(exports2, module2) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants3();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i) => {
          streamLevels[i] = opts.levels[i];
        });
      }
      const res = {
        write,
        add,
        emit,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
          dest = streams[i];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function emit(...args) {
        for (const { stream } of this.streams) {
          if (typeof stream.emit === "function") {
            stream.emit(...args);
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone(level) {
        const streams = new Array(this.streams.length);
        for (let i = 0; i < streams.length; i++) {
          streams[i] = {
            level,
            stream: this.streams[i].stream
          };
        }
        return {
          write,
          add,
          minLevel: level,
          streams,
          clone,
          emit,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a, b) {
      return a.level - b.level;
    }
    function initLoopVar(length, dedupe) {
      return dedupe ? length - 1 : 0;
    }
    function adjustLoopVar(i, dedupe) {
      return dedupe ? i - 1 : i + 1;
    }
    function checkLoopVar(i, length, dedupe) {
      return dedupe ? i >= 0 : i < length;
    }
    module2.exports = multistream;
  }
});

// node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols2();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants3();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize = createArgsNormalizer(defaultOptions);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args) {
      const instance = {};
      const { opts, stream } = normalize(instance, caller(), ...args);
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      if (typeof stream.emit === "function") {
        stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
      }
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module2.exports = pino;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time);
    module2.exports.symbols = symbols;
    module2.exports.version = version;
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// node_modules/elastic-apm-node/lib/logging.js
var require_logging = __commonJS({
  "node_modules/elastic-apm-node/lib/logging.js"(exports2, module2) {
    "use strict";
    var { ecsFormat } = require_ecs_pino_format();
    var pino = require_pino();
    var semver = require_semver2();
    var DEFAULT_LOG_LEVEL = "info";
    var LOGGER_IS_OURS_SYM = Symbol("ElasticAPMLoggerIsOurs");
    var PINO_LEVEL_FROM_LEVEL_NAME = {
      trace: "trace",
      debug: "debug",
      info: "info",
      warning: "warn",
      warn: "warn",
      // Supported for backwards compat
      error: "error",
      critical: "fatal",
      fatal: "fatal",
      // Supported for backwards compat
      off: "silent"
    };
    var SafePinoDestWrapper = class {
      constructor(customLogger) {
        this.customLogger = customLogger;
        this.logFnNameFromLastLevel = pino.levels.labels;
        this[Symbol.for("pino.metadata")] = true;
      }
      write(s) {
        const { lastMsg, lastLevel } = this;
        const logFnName = this.logFnNameFromLastLevel[lastLevel];
        this.customLogger[logFnName](lastMsg);
      }
    };
    function createLogger(levelName, customLogger) {
      let dest;
      const serializers = {
        err: pino.stdSerializers.err,
        req: pino.stdSerializers.req,
        res: pino.stdSerializers.res
      };
      if (!levelName) {
        levelName = DEFAULT_LOG_LEVEL;
      }
      let pinoLevel = PINO_LEVEL_FROM_LEVEL_NAME[levelName];
      if (!pinoLevel) {
        pinoLevel = "trace";
      }
      if (customLogger) {
        if (Symbol.for("pino.serializers") in customLogger) {
          if (semver.gte(customLogger.version, "6.12.0")) {
            return customLogger.child({}, { serializers });
          }
          return customLogger.child({
            serializers
          });
        }
        dest = new SafePinoDestWrapper(customLogger);
        pinoLevel = "trace";
      } else {
        dest = pino.destination(1);
      }
      const logger = pino(
        {
          name: "elastic-apm-node",
          base: {},
          // Don't want pid and hostname fields.
          level: pinoLevel,
          serializers,
          ...ecsFormat({ apmIntegration: false })
        },
        dest
      );
      if (!customLogger) {
        logger[LOGGER_IS_OURS_SYM] = true;
      }
      return logger;
    }
    function isLoggerCustom(logger) {
      return !logger[LOGGER_IS_OURS_SYM];
    }
    function setLogLevel(logger, levelName) {
      const pinoLevel = PINO_LEVEL_FROM_LEVEL_NAME[levelName];
      if (!pinoLevel) {
        logger.warn('unknown log levelName "%s": cannot setLogLevel', levelName);
      } else {
        logger.level = pinoLevel;
      }
    }
    module2.exports = {
      DEFAULT_LOG_LEVEL,
      createLogger,
      isLoggerCustom,
      setLogLevel
    };
  }
});

// node_modules/elastic-apm-node/lib/apm-client/noop-apm-client.js
var require_noop_apm_client = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/noop-apm-client.js"(exports2, module2) {
    "use strict";
    var NoopApmClient = class {
      config(opts) {
      }
      addMetadataFilter(fn) {
      }
      setExtraMetadata(metadata) {
      }
      lambdaStart() {
      }
      lambdaShouldRegisterTransactions() {
        return true;
      }
      lambdaRegisterTransaction(trans, awsRequestId) {
      }
      sendSpan(span, cb) {
        if (cb) {
          process.nextTick(cb);
        }
      }
      sendTransaction(transaction, cb) {
        if (cb) {
          process.nextTick(cb);
        }
      }
      sendError(_error, cb) {
        if (cb) {
          process.nextTick(cb);
        }
      }
      sendMetricSet(metricset, cb) {
        if (cb) {
          process.nextTick(cb);
        }
      }
      flush(opts, cb) {
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        } else if (!opts) {
          opts = {};
        }
        if (cb) {
          process.nextTick(cb);
        }
      }
      supportsKeepingUnsampledTransaction() {
        return true;
      }
      // Inherited from Writable, called in agent.js.
      destroy() {
      }
    };
    module2.exports = {
      NoopApmClient
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/azure-functions.js
var require_azure_functions = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/azure-functions.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var constants = require_constants2();
    var isInstrumented = false;
    var hookDisposables = [];
    var isFirstRun = true;
    var TRIGGER_OTHER = 1;
    var TRIGGER_HTTP = 2;
    var TRIGGER_TIMER = 3;
    var TRANS_TYPE_FROM_TRIGGER_TYPE = {
      [TRIGGER_OTHER]: "request",
      [TRIGGER_HTTP]: "request",
      // Note: `transaction.type = "scheduled"` is not in the shared APM agent spec,
      // but the Java agent used the same value for some instrumentations.
      [TRIGGER_TIMER]: "scheduled"
    };
    var FAAS_TRIGGER_TYPE_FROM_TRIGGER_TYPE = {
      [TRIGGER_OTHER]: "other",
      [TRIGGER_HTTP]: "http",
      // Note: `faas.trigger = "timer"` is not in the shared APM agent spec yet.
      [TRIGGER_TIMER]: "timer"
    };
    var gHttpRouteFromFuncDir = /* @__PURE__ */ new Map();
    var DEFAULT_ROUTE_PREFIX = "api";
    var gRoutePrefix = null;
    var FunctionInfo = class {
      constructor(bindingDefinitions, executionContext, log) {
        this.triggerType = TRIGGER_OTHER;
        this.httpOutputName = "";
        this.hasHttpTrigger = false;
        this.hasReturnBinding = false;
        this.outputBindingNames = [];
        for (const bd of bindingDefinitions) {
          if (bd.direction !== "in") {
            if (bd.type && bd.type.toLowerCase() === "http") {
              this.httpOutputName = bd.name;
            }
            this.outputBindingNames.push(bd.name);
            if (bd.name === "$return") {
              this.hasReturnBinding = true;
            }
          }
          if (bd.type) {
            const typeLc = bd.type.toLowerCase();
            switch (typeLc) {
              case "httptrigger":
                this.triggerType = TRIGGER_HTTP;
                break;
              case "timertrigger":
                this.triggerType = TRIGGER_TIMER;
                break;
            }
          }
        }
        this.httpRoute = null;
        this.routePrefix = null;
        if (this.triggerType === TRIGGER_HTTP) {
          const funcDir = executionContext.functionDirectory;
          if (!funcDir) {
            this.httpRoute = executionContext.functionName;
          } else if (gHttpRouteFromFuncDir.has(funcDir)) {
            this.httpRoute = gHttpRouteFromFuncDir.get(funcDir);
          } else {
            try {
              const fj = JSON.parse(
                fs.readFileSync(path.join(funcDir, "function.json"))
              );
              for (let i = 0; i < fj.bindings.length; i++) {
                const binding = fj.bindings[i];
                if (binding.direction === "in" && binding.type && binding.type.toLowerCase() === "httptrigger") {
                  if (binding.route !== void 0) {
                    this.httpRoute = binding.route;
                  } else {
                    this.httpRoute = executionContext.functionName;
                  }
                  gHttpRouteFromFuncDir.set(funcDir, this.httpRoute);
                }
              }
              log.trace(
                { funcDir, httpRoute: this.httpRoute },
                "azure-functions: loaded route"
              );
            } catch (httpRouteErr) {
              log.debug(
                "azure-functions: could not determine httpRoute for function %s: %s",
                executionContext.functionName,
                httpRouteErr.message
              );
              this.httpRoute = executionContext.functionName;
            }
          }
          if (gRoutePrefix) {
            this.routePrefix = gRoutePrefix;
          } else if (!funcDir) {
            this.routePrefix = gRoutePrefix = DEFAULT_ROUTE_PREFIX;
          } else {
            try {
              const hj = JSON.parse(
                fs.readFileSync(path.join(path.dirname(funcDir), "host.json"))
              );
              if (hj && hj.extensions && hj.extensions.http && hj.extensions.http.routePrefix !== void 0) {
                const rawRoutePrefix = hj.extensions.http.routePrefix;
                this.routePrefix = gRoutePrefix = normRoutePrefix(rawRoutePrefix);
                log.trace(
                  { hj, routePrefix: this.routePrefix, rawRoutePrefix },
                  "azure-functions: loaded route prefix"
                );
              } else {
                this.routePrefix = gRoutePrefix = DEFAULT_ROUTE_PREFIX;
              }
            } catch (routePrefixErr) {
              log.debug(
                "azure-functions: could not determine routePrefix: %s",
                routePrefixErr.message
              );
              this.routePrefix = gRoutePrefix = DEFAULT_ROUTE_PREFIX;
            }
          }
        }
      }
    };
    function normRoutePrefix(routePrefix) {
      return routePrefix.startsWith("/") ? routePrefix.slice(1) : routePrefix;
    }
    function setTransDataFromHttpTriggerResult(trans, hookCtx) {
      if (hookCtx.error) {
        trans.setOutcome(constants.OUTCOME_FAILURE);
        trans.result = "HTTP 5xx";
        trans.res = {
          statusCode: 500
        };
        return;
      }
      const funcInfo = hookCtx.hookData.funcInfo;
      const result = hookCtx.result;
      const context2 = hookCtx.invocationContext;
      let httpRes;
      if (funcInfo.hasReturnBinding) {
        httpRes = hookCtx.result;
      } else {
        if (result && typeof result === "object" && result[funcInfo.httpOutputName] !== void 0) {
          httpRes = result[funcInfo.httpOutputName];
        } else if (context2.bindings && context2.bindings[funcInfo.httpOutputName] !== void 0) {
          httpRes = context2.bindings[funcInfo.httpOutputName];
        } else if (context2.res !== void 0) {
          httpRes = context2.res;
        }
      }
      if (typeof httpRes !== "object") {
        trans.setOutcome(constants.OUTCOME_FAILURE);
        trans.result = "HTTP 5xx";
        trans.res = {
          statusCode: 500
        };
        return;
      }
      let statusCode = Number(httpRes.status);
      if (!Number.isInteger(statusCode)) {
        statusCode = 200;
      }
      if (statusCode < 500) {
        trans.setOutcome(constants.OUTCOME_SUCCESS);
      } else {
        trans.setOutcome(constants.OUTCOME_FAILURE);
      }
      trans.result = "HTTP " + statusCode.toString()[0] + "xx";
      trans.res = {
        statusCode,
        body: httpRes.body
      };
      if (httpRes.headers && typeof httpRes.headers === "object") {
        trans.res.headers = httpRes.headers;
      }
    }
    function getAzureAccountId() {
      return process.env.WEBSITE_OWNER_NAME && process.env.WEBSITE_OWNER_NAME.split("+", 1)[0];
    }
    var isAzureFunctionsEnvironment = !!process.env.FUNCTIONS_WORKER_RUNTIME;
    function getAzureFunctionsExtraMetadata() {
      const metadata = {
        service: {
          framework: {
            // Passing this service.framework.name to Client#setExtraMetadata()
            // ensures that it "wins" over a framework name from
            // `agent.setFramework()`, because in the client `_extraMetadata`
            // wins over `_conf.frameworkName`.
            name: "Azure Functions",
            version: process.env.FUNCTIONS_EXTENSION_VERSION
          },
          runtime: {
            name: process.env.FUNCTIONS_WORKER_RUNTIME
          },
          node: {
            configured_name: process.env.WEBSITE_INSTANCE_ID
          }
        },
        // https://github.com/elastic/apm/blob/main/specs/agents/metadata.md#azure-functions
        cloud: {
          provider: "azure",
          region: process.env.REGION_NAME,
          service: {
            name: "functions"
          }
        }
      };
      const accountId = getAzureAccountId();
      if (accountId) {
        metadata.cloud.account = { id: accountId };
      }
      if (process.env.WEBSITE_SITE_NAME) {
        metadata.cloud.instance = { name: process.env.WEBSITE_SITE_NAME };
      }
      if (process.env.WEBSITE_RESOURCE_GROUP) {
        metadata.cloud.project = { name: process.env.WEBSITE_RESOURCE_GROUP };
      }
      return metadata;
    }
    function instrument(agent) {
      if (isInstrumented) {
        return;
      }
      isInstrumented = true;
      const ins = agent._instrumentation;
      const log = agent.logger;
      let d;
      let core;
      try {
        core = require("@azure/functions-core");
      } catch (err) {
        log.warn(
          { err },
          'could not import "@azure/functions-core": skipping Azure Functions instrumentation'
        );
        return;
      }
      d = core.registerHook("preInvocation", (hookCtx) => {
        if (!hookCtx.invocationContext) {
          return;
        }
        const context2 = hookCtx.invocationContext;
        const invocationId = context2.invocationId;
        log.trace({ invocationId }, "azure-functions: preInvocation");
        const isColdStart = isFirstRun;
        if (isFirstRun) {
          isFirstRun = false;
        }
        const funcInfo = hookCtx.hookData.funcInfo = new FunctionInfo(
          context2.bindingDefinitions,
          context2.executionContext,
          log
        );
        const triggerType = funcInfo.triggerType;
        let traceparent;
        let tracestate;
        if (triggerType === TRIGGER_HTTP && context2.req && context2.req.headers) {
          traceparent = context2.req.headers.traceparent || context2.req.headers["elastic-apm-traceparent"];
          tracestate = context2.req.headers.tracestate;
        }
        const trans = hookCtx.hookData.trans = ins.startTransaction(
          // This is the default name. Trigger-specific values are added below.
          context2.executionContext.functionName,
          TRANS_TYPE_FROM_TRIGGER_TYPE[triggerType],
          {
            childOf: traceparent,
            tracestate
          }
        );
        const accountId = getAzureAccountId();
        const resourceGroup = process.env.WEBSITE_RESOURCE_GROUP;
        const fnAppName = process.env.WEBSITE_SITE_NAME;
        const fnName = context2.executionContext.functionName;
        const faasData = {
          trigger: {
            type: FAAS_TRIGGER_TYPE_FROM_TRIGGER_TYPE[triggerType]
          },
          execution: invocationId,
          coldstart: isColdStart
        };
        if (accountId && resourceGroup && fnAppName) {
          faasData.id = `/subscriptions/${accountId}/resourceGroups/${resourceGroup}/providers/Microsoft.Web/sites/${fnAppName}/functions/${fnName}`;
        }
        if (fnAppName && fnName) {
          faasData.name = `${fnAppName}/${fnName}`;
        }
        trans.setFaas(faasData);
        if (triggerType === TRIGGER_HTTP) {
          const req = hookCtx.inputs[0];
          if (req) {
            trans.req = req;
            if (agent._conf.usePathAsTransactionName && req.url) {
              trans.setDefaultName(`${req.method} ${new URL(req.url).pathname}`);
            } else {
              const route = funcInfo.routePrefix ? `/${funcInfo.routePrefix}/${funcInfo.httpRoute}` : `/${funcInfo.httpRoute}`;
              trans.setDefaultName(`${req.method} ${route}`);
            }
          }
        }
      });
      hookDisposables.push(d);
      d = core.registerHook("postInvocation", (hookCtx) => {
        if (!hookCtx.invocationContext) {
          return;
        }
        const invocationId = hookCtx.invocationContext.invocationId;
        log.trace({ invocationId }, "azure-functions: postInvocation");
        const trans = hookCtx.hookData.trans;
        if (!trans) {
          return;
        }
        const funcInfo = hookCtx.hookData.funcInfo;
        if (funcInfo.triggerType === TRIGGER_HTTP) {
          setTransDataFromHttpTriggerResult(trans, hookCtx);
        } else if (hookCtx.error) {
          trans.result = constants.RESULT_FAILURE;
          trans.setOutcome(constants.OUTCOME_FAILURE);
        } else {
          trans.result = constants.RESULT_SUCCESS;
          trans.setOutcome(constants.OUTCOME_SUCCESS);
        }
        if (hookCtx.error) {
          agent.captureError(hookCtx.error, { skipOutcome: true });
        }
        trans.end();
      });
      hookDisposables.push(d);
    }
    function uninstrument() {
      if (!isInstrumented) {
        return;
      }
      isInstrumented = false;
      hookDisposables.forEach((d) => {
        d.dispose();
      });
      hookDisposables = [];
    }
    module2.exports = {
      isAzureFunctionsEnvironment,
      getAzureFunctionsExtraMetadata,
      instrument,
      uninstrument
    };
  }
});

// node_modules/elastic-apm-node/package.json
var require_package2 = __commonJS({
  "node_modules/elastic-apm-node/package.json"(exports2, module2) {
    module2.exports = {
      name: "elastic-apm-node",
      version: "4.7.3",
      description: "The official Elastic APM agent for Node.js",
      type: "commonjs",
      main: "index.js",
      types: "index.d.ts",
      scripts: {
        "docs:open": "PREVIEW=1 npm run docs:build",
        "docs:build": "./docs/scripts/build_docs.sh apm-agent-nodejs ./docs ./build",
        lint: "npm run lint:eslint && npm run lint:license-files && npm run lint:yaml-files && npm run lint:tav",
        "lint:eslint": "eslint . # requires node >=18.18.0",
        "lint:eslint-nostyle": "eslint --rule 'prettier/prettier: off' . # lint without checking style, not normally used; requires node>=18.18.0",
        "lint:fix": "eslint --fix .  # requires node >=18.18.0",
        "lint:license-files": "./dev-utils/gen-notice.sh --lint .  # requires node >=16",
        "lint:yaml-files": "./dev-utils/lint-yaml-files.sh  # requires node >=10",
        "lint:tav": "./dev-utils/lint-tav-json.js",
        test: "./test/script/run_tests.sh",
        "test:deps": "dependency-check index.js start.js start-next.js 'lib/**/*.js' 'test/**/*.js' '!test/activation-method/fixtures' '!test/instrumentation/azure-functions/fixtures' '!test/instrumentation/modules/next/a-nextjs-app' '!test/opentelemetry-bridge' '!test/opentelemetry-metrics/fixtures' --no-dev -i async_hooks -i perf_hooks -i node:http -i @azure/functions-core -i worker_threads -i timers",
        "test:tav": "(cd test/opentelemetry-metrics/fixtures && tav --quiet) && (cd test/opentelemetry-bridge && tav --quiet) && (cd test/instrumentation/modules/next/a-nextjs-app && tav --quiet) && tav --quiet",
        "test:types": "tsc --project test/types/tsconfig.json && tsc --project test/types/transpile/tsconfig.json && node test/types/transpile/index.js && tsc --project test/types/transpile-default/tsconfig.json && node test/types/transpile-default/index.js  # requires node >=14.17",
        "test:babel": "babel test/babel/src.js --out-file test/babel/out.js && cd test/babel && node out.js",
        bench: "./test/benchmarks/scripts/run-benchmarks.sh",
        "bench:ci": "./test/benchmarks/scripts/run-benchmarks-ci.sh",
        "local:start": "./test/script/local-deps-start.sh",
        "local:stop": "./test/script/local-deps-stop.sh",
        "docker:start": "docker compose -f ./test/docker-compose.yml up -d",
        "docker:stop": "docker compose -f ./test/docker-compose.yml down",
        "docker:clean": "./test/script/docker/cleanup.sh",
        "docker:dev": "docker compose -f ./dev-utils/docker-compose.yml run --workdir=/agent nodejs-agent"
      },
      directories: {
        test: "test"
      },
      files: [
        "NOTICE.md",
        "lib",
        "types",
        "start.js",
        "start-next.js",
        "loader.mjs",
        "index.d.ts",
        "start.d.ts",
        "start-next.d.ts"
      ],
      repository: {
        type: "git",
        url: "git://github.com/elastic/apm-agent-nodejs.git"
      },
      engines: {
        node: ">=14.17.0"
      },
      keywords: [
        "opbeat",
        "elastic",
        "elasticapm",
        "elasticsearch",
        "log",
        "logging",
        "bug",
        "bugs",
        "error",
        "errors",
        "exception",
        "exceptions",
        "catch",
        "monitor",
        "monitoring",
        "alert",
        "alerts",
        "performance",
        "apm",
        "ops",
        "devops",
        "stacktrace",
        "trace",
        "tracing",
        "distributedtracing",
        "distributed-tracing"
      ],
      author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
      contributors: [
        "Elastic Observability <https://www.elastic.co/observability>"
      ],
      license: "BSD-2-Clause",
      bugs: {
        url: "https://github.com/elastic/apm-agent-nodejs/issues"
      },
      homepage: "https://github.com/elastic/apm-agent-nodejs",
      dependencies: {
        "@elastic/ecs-pino-format": "^1.5.0",
        "@opentelemetry/api": "^1.4.1",
        "@opentelemetry/core": "^1.11.0",
        "@opentelemetry/sdk-metrics": "^1.12.0",
        "after-all-results": "^2.0.0",
        agentkeepalive: "^4.2.1",
        "async-value-promise": "^1.1.1",
        "basic-auth": "^2.0.1",
        "breadth-filter": "^2.0.0",
        cookie: "^0.6.0",
        "core-util-is": "^1.0.2",
        "end-of-stream": "^1.4.4",
        "error-callsites": "^2.0.4",
        "error-stack-parser": "^2.0.6",
        "escape-string-regexp": "^4.0.0",
        "fast-safe-stringify": "^2.0.7",
        "fast-stream-to-buffer": "^1.0.0",
        "http-headers": "^3.0.2",
        "import-in-the-middle": "1.11.0",
        "json-bigint": "^1.0.0",
        "lru-cache": "10.2.0",
        "measured-reporting": "^1.51.1",
        "module-details-from-path": "^1.0.3",
        "monitor-event-loop-delay": "^1.0.0",
        "object-filter-sequence": "^1.0.0",
        "object-identity-map": "^1.0.2",
        "original-url": "^1.2.3",
        pino: "^8.15.0",
        "readable-stream": "^3.6.2",
        "relative-microtime": "^2.0.0",
        "require-in-the-middle": "^7.1.1",
        semver: "^7.5.4",
        "shallow-clone-shim": "^2.0.0",
        "source-map": "^0.8.0-beta.0",
        "sql-summary": "^1.0.1",
        "stream-chopper": "^3.0.1",
        "unicode-byte-truncate": "^1.0.0"
      },
      devDependencies: {
        "@apollo/server": "^4.2.2",
        "@aws-sdk/client-dynamodb": "^3.379.1",
        "@aws-sdk/client-s3": "^3.379.1",
        "@aws-sdk/client-sns": "^3.379.1",
        "@aws-sdk/client-sqs": "^3.379.1",
        "@aws-sdk/s3-request-presigner": "^3.379.1",
        "@babel/cli": "^7.8.4",
        "@babel/core": "^7.8.4",
        "@babel/preset-env": "^7.8.4",
        "@elastic/elasticsearch": "^8.6.0",
        "@fastify/formbody": "^7.0.1",
        "@hapi/hapi": "^21.0.0",
        "@koa/router": "^12.0.0",
        "@types/node": "^22.0.0",
        ajv: "^8.12.0",
        "apollo-server-core": "^3.0.0",
        "apollo-server-express": "^3.0.0",
        "aws-sdk": "^2.1400.0",
        benchmark: "^2.1.4",
        bluebird: "^3.7.2",
        "body-parser": "^1.19.0",
        "cassandra-driver": "^4.4.0",
        columnify: "^1.5.4",
        connect: "^3.7.0",
        dashdash: "^2.0.0",
        "dependency-check": "^4.1.0",
        diagnostics_channel: "^1.1.0",
        elasticsearch: "^16.7.3",
        eslint: "^9.0.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-import": "^2.28.0",
        "eslint-plugin-license-header": "^0.6.0",
        "eslint-plugin-n": "^17.2.0",
        "eslint-plugin-prettier": "^5.0.0",
        "eslint-plugin-promise": "^7.0.0",
        express: "^4.17.1",
        "express-queue": "^0.0.13",
        fastify: "^4.16.3",
        finalhandler: "^1.1.2",
        "generic-pool": "^3.7.1",
        "get-port": "^5.1.1",
        glob: "^7.2.3",
        got: "^11.8.5",
        graphql: "^16.6.0",
        handlebars: "^4.7.3",
        "https-pem": "^3.0.0",
        ioredis: "^5.1.0",
        "js-yaml": "^4.1.0",
        json: "^11.0.0",
        kafkajs: "^2.2.4",
        knex: "^3.0.1",
        koa: "^2.11.0",
        "koa-bodyparser": "^4.3.0",
        "koa-router": "^12.0.0",
        "lambda-local": "^2.0.2",
        memcached: "^2.2.2",
        "mimic-response": "1.0.0",
        mkdirp: "^3.0.1",
        mongodb: "^6.0.0",
        "mongodb-core": "^3.2.7",
        mysql: "^2.18.1",
        mysql2: "^3.2.4",
        ndjson: "^2.0.0",
        numeral: "^2.0.6",
        once: "^1.4.0",
        pg: "^8.7.1",
        prettier: "^3.0.0",
        pug: "^3.0.1",
        redis: "^4.3.0",
        request: "^2.88.2",
        restify: "^11.0.0",
        rimraf: "^3.0.2",
        tape: "^5.0.0",
        tedious: "^18.1.0",
        "test-all-versions": "^6.1.0",
        thunky: "^1.1.0",
        "tree-kill": "^1.2.2",
        typescript: "^5.0.2",
        undici: "^6.2.1",
        vasync: "^2.2.0",
        "wait-on": "^7.0.1",
        ws: "^7.2.1"
      }
    };
  }
});

// node_modules/elastic-apm-node/lib/config/schema.js
var require_schema = __commonJS({
  "node_modules/elastic-apm-node/lib/config/schema.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var os = require("os");
    var path = require("path");
    var { URL: URL2 } = require("url");
    var AGENT_VERSION = require_package2().version;
    var { REDACTED } = require_constants2();
    var CONFIG_SCHEMA = [
      {
        name: "abortedErrorThreshold",
        configType: "durationSeconds",
        defaultValue: "25s",
        envVar: "ELASTIC_APM_ABORTED_ERROR_THRESHOLD"
      },
      {
        name: "active",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_ACTIVE"
      },
      {
        name: "addPatch",
        configType: "stringKeyValuePairs",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_ADD_PATCH"
      },
      {
        name: "apiRequestSize",
        configType: "byte",
        defaultValue: "768kb",
        envVar: "ELASTIC_APM_API_REQUEST_SIZE"
      },
      {
        name: "apiRequestTime",
        configType: "durationSeconds",
        defaultValue: "10s",
        envVar: "ELASTIC_APM_API_REQUEST_TIME"
      },
      {
        name: "breakdownMetrics",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_BREAKDOWN_METRICS"
      },
      {
        name: "captureBody",
        configType: "select(off,all,errors,transactions)",
        defaultValue: "off",
        envVar: "ELASTIC_APM_CAPTURE_BODY",
        centralConfigName: "capture_body",
        crossAgentName: "capture_body"
      },
      {
        name: "captureErrorLogStackTraces",
        configType: "select(messages,always)",
        defaultValue: "messages",
        envVar: "ELASTIC_APM_CAPTURE_ERROR_LOG_STACK_TRACES"
      },
      {
        name: "captureExceptions",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_CAPTURE_EXCEPTIONS"
      },
      {
        name: "captureHeaders",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_CAPTURE_HEADERS"
      },
      {
        name: "centralConfig",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_CENTRAL_CONFIG"
      },
      {
        name: "cloudProvider",
        configType: "select(auto,gcp,azure,aws,none)",
        defaultValue: "auto",
        envVar: "ELASTIC_APM_CLOUD_PROVIDER"
      },
      {
        name: "containerId",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_CONTAINER_ID"
      },
      {
        name: "contextPropagationOnly",
        configType: "boolean",
        defaultValue: false,
        envVar: "ELASTIC_APM_CONTEXT_PROPAGATION_ONLY"
      },
      {
        name: "customMetricsHistogramBoundaries",
        configType: "sortedNumberArray",
        // Exponential powers-of-2 bucket boundaries, rounded to 6 significant figures.
        //    2**N for N in [-8, -7.5, -7, ..., 16, 16.5, 17]
        // https://github.com/elastic/apm/blob/main/specs/agents/metrics-otel.md#histogram-aggregation
        defaultValue: [
          390625e-8,
          552427e-8,
          78125e-7,
          0.0110485,
          0.015625,
          0.0220971,
          0.03125,
          0.0441942,
          0.0625,
          0.0883883,
          0.125,
          0.176777,
          0.25,
          0.353553,
          0.5,
          0.707107,
          1,
          1.41421,
          2,
          2.82843,
          4,
          5.65685,
          8,
          11.3137,
          16,
          22.6274,
          32,
          45.2548,
          64,
          90.5097,
          128,
          181.019,
          256,
          362.039,
          512,
          724.077,
          1024,
          1448.15,
          2048,
          2896.31,
          4096,
          5792.62,
          8192,
          11585.2,
          16384,
          23170.5,
          32768,
          46341,
          65536,
          92681.9,
          131072
        ],
        envVar: "ELASTIC_APM_CUSTOM_METRICS_HISTOGRAM_BOUNDARIES"
      },
      {
        name: "disableInstrumentations",
        configType: "stringArray",
        defaultValue: [],
        envVar: "ELASTIC_APM_DISABLE_INSTRUMENTATIONS"
      },
      {
        name: "disableMetrics",
        configType: "stringArray",
        defaultValue: [],
        envVar: "ELASTIC_APM_DISABLE_METRICS"
      },
      {
        name: "disableMetricsRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["disableMetrics"]
      },
      {
        name: "disableSend",
        configType: "boolean",
        defaultValue: false,
        envVar: "ELASTIC_APM_DISABLE_SEND"
      },
      {
        name: "elasticsearchCaptureBodyUrls",
        configType: "stringArray",
        defaultValue: [
          "*/_search",
          "*/_search/template",
          "*/_msearch",
          "*/_msearch/template",
          "*/_async_search",
          "*/_count",
          "*/_sql",
          "*/_eql/search"
        ],
        envVar: "ELASTIC_APM_ELASTICSEARCH_CAPTURE_BODY_URLS"
      },
      {
        name: "elasticsearchCaptureBodyUrlsRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["elasticsearchCaptureBodyUrls"]
      },
      {
        name: "environment",
        configType: "string",
        defaultValue: process.env.NODE_ENV || "development",
        envVar: "ELASTIC_APM_ENVIRONMENT"
      },
      {
        name: "errorOnAbortedRequests",
        configType: "boolean",
        defaultValue: false,
        envVar: "ELASTIC_APM_ERROR_ON_ABORTED_REQUESTS"
      },
      {
        name: "exitSpanMinDuration",
        configType: "durationMilliseconds",
        defaultValue: "0ms",
        envVar: "ELASTIC_APM_EXIT_SPAN_MIN_DURATION",
        centralConfigName: "exit_span_min_duration",
        crossAgentName: "exit_span_min_duration"
      },
      {
        name: "globalLabels",
        configType: "stringKeyValuePairs",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_GLOBAL_LABELS"
      },
      {
        name: "ignoreMessageQueues",
        configType: "stringArray",
        defaultValue: [],
        envVar: "ELASTIC_APM_IGNORE_MESSAGE_QUEUES",
        centralConfigName: "ignore_message_queues",
        crossAgentName: "ignore_message_queues"
      },
      {
        name: "ignoreMessageQueuesRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["ignoreMessageQueues"]
      },
      {
        name: "instrument",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_INSTRUMENT"
      },
      {
        name: "instrumentIncomingHTTPRequests",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_INSTRUMENT_INCOMING_HTTP_REQUESTS"
      },
      {
        name: "kubernetesNamespace",
        configType: "string",
        defaultValue: void 0,
        envVar: "KUBERNETES_NAMESPACE"
      },
      {
        name: "kubernetesNodeName",
        configType: "string",
        defaultValue: void 0,
        envVar: "KUBERNETES_NODE_NAME"
      },
      {
        name: "kubernetesPodName",
        configType: "string",
        defaultValue: void 0,
        envVar: "KUBERNETES_POD_NAME"
      },
      {
        name: "kubernetesPodUID",
        configType: "string",
        defaultValue: void 0,
        envVar: "KUBERNETES_POD_UID"
      },
      {
        name: "logLevel",
        configType: "select(debug,info,warning,error,critical,off,trace)",
        defaultValue: "info",
        envVar: "ELASTIC_APM_LOG_LEVEL",
        centralConfigName: "log_level",
        crossAgentName: "log_level"
      },
      {
        name: "longFieldMaxLength",
        configType: "number",
        defaultValue: 1e4,
        envVar: "ELASTIC_APM_LONG_FIELD_MAX_LENGTH"
      },
      {
        name: "maxQueueSize",
        configType: "number",
        // Rough equivalent of the Java Agent's max_queue_size:
        // https://www.elastic.co/guide/en/apm/agent/java/current/config-reporter.html#config-max-queue-size
        defaultValue: 1024,
        envVar: "ELASTIC_APM_MAX_QUEUE_SIZE"
      },
      {
        name: "metricsInterval",
        configType: "durationSeconds",
        defaultValue: "30s",
        envVar: "ELASTIC_APM_METRICS_INTERVAL"
      },
      {
        name: "metricsLimit",
        configType: "number",
        defaultValue: 1e3,
        envVar: "ELASTIC_APM_METRICS_LIMIT"
      },
      {
        name: "opentelemetryBridgeEnabled",
        configType: "boolean",
        defaultValue: false,
        envVar: "ELASTIC_APM_OPENTELEMETRY_BRIDGE_ENABLED"
      },
      {
        name: "sanitizeFieldNames",
        configType: "stringArray",
        // These patterns are specified in the shared APM specs:
        // https://github.com/elastic/apm/blob/main/specs/agents/sanitization.md
        defaultValue: [
          "password",
          "passwd",
          "pwd",
          "secret",
          "*key",
          "*token*",
          "*session*",
          "*credit*",
          "*card*",
          "*auth*",
          "set-cookie",
          "*principal*",
          // These are default patterns only in the Node.js APM agent, historically
          // from when the "is-secret" dependency was used.
          "pw",
          "pass",
          "connect.sid"
        ],
        envVar: "ELASTIC_APM_SANITIZE_FIELD_NAMES",
        centralConfigName: "sanitize_field_names",
        crossAgentName: "sanitize_field_names"
      },
      {
        name: "sanitizeFieldNamesRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["sanitizeFieldNames"]
      },
      {
        name: "serviceNodeName",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SERVICE_NODE_NAME"
      },
      {
        name: "serverTimeout",
        configType: "durationSeconds",
        defaultValue: "30s",
        envVar: "ELASTIC_APM_SERVER_TIMEOUT"
      },
      {
        name: "serverUrl",
        configType: "url",
        defaultValue: "http://127.0.0.1:8200",
        envVar: "ELASTIC_APM_SERVER_URL",
        crossAgentName: "server_url",
        redactFn: sanitizeUrl
      },
      {
        name: "sourceLinesErrorAppFrames",
        configType: "number",
        defaultValue: 5,
        envVar: "ELASTIC_APM_SOURCE_LINES_ERROR_APP_FRAMES"
      },
      {
        name: "sourceLinesErrorLibraryFrames",
        configType: "number",
        defaultValue: 5,
        envVar: "ELASTIC_APM_SOURCE_LINES_ERROR_LIBRARY_FRAMES"
      },
      {
        name: "sourceLinesSpanAppFrames",
        configType: "number",
        defaultValue: 0,
        envVar: "ELASTIC_APM_SOURCE_LINES_SPAN_APP_FRAMES"
      },
      {
        name: "sourceLinesSpanLibraryFrames",
        configType: "number",
        defaultValue: 0,
        envVar: "ELASTIC_APM_SOURCE_LINES_SPAN_LIBRARY_FRAMES"
      },
      {
        name: "spanCompressionEnabled",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_SPAN_COMPRESSION_ENABLED"
      },
      {
        name: "spanCompressionExactMatchMaxDuration",
        configType: "durationCompression",
        defaultValue: "50ms",
        envVar: "ELASTIC_APM_SPAN_COMPRESSION_EXACT_MATCH_MAX_DURATION"
      },
      {
        name: "spanCompressionSameKindMaxDuration",
        configType: "durationCompression",
        defaultValue: "0ms",
        envVar: "ELASTIC_APM_SPAN_COMPRESSION_SAME_KIND_MAX_DURATION"
      },
      {
        name: "stackTraceLimit",
        configType: "number",
        defaultValue: 50,
        envVar: "ELASTIC_APM_STACK_TRACE_LIMIT"
      },
      {
        name: "traceContinuationStrategy",
        configType: "select(continue,restart,external)",
        defaultValue: "continue",
        envVar: "ELASTIC_APM_TRACE_CONTINUATION_STRATEGY",
        centralConfigName: "trace_continuation_strategy",
        crossAgentName: "trace_continuation_strategy"
      },
      {
        name: "transactionIgnoreUrls",
        configType: "stringArray",
        defaultValue: [],
        envVar: "ELASTIC_APM_TRANSACTION_IGNORE_URLS",
        centralConfigName: "transaction_ignore_urls",
        crossAgentName: "transaction_ignore_urls"
      },
      {
        name: "transactionIgnoreUrlRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["transactionIgnoreUrls"]
      },
      {
        name: "transactionMaxSpans",
        configType: "numberInfinity",
        defaultValue: 500,
        envVar: "ELASTIC_APM_TRANSACTION_MAX_SPANS",
        centralConfigName: "transaction_max_spans",
        crossAgentName: "transaction_max_spans"
      },
      {
        name: "transactionSampleRate",
        configType: "sampleRate",
        defaultValue: 1,
        envVar: "ELASTIC_APM_TRANSACTION_SAMPLE_RATE",
        centralConfigName: "transaction_sample_rate",
        crossAgentName: "transaction_sample_rate"
      },
      {
        name: "useElasticTraceparentHeader",
        configType: "boolean",
        defaultValue: false,
        envVar: "ELASTIC_APM_USE_ELASTIC_TRACEPARENT_HEADER"
      },
      {
        name: "usePathAsTransactionName",
        configType: "boolean",
        defaultValue: false,
        envVar: "ELASTIC_APM_USE_PATH_AS_TRANSACTION_NAME"
      },
      {
        name: "verifyServerCert",
        configType: "boolean",
        defaultValue: true,
        envVar: "ELASTIC_APM_VERIFY_SERVER_CERT"
      },
      {
        name: "errorMessageMaxLength",
        configType: "byte",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_ERROR_MESSAGE_MAX_LENGTH",
        deprecated: "Deprecated in: v3.21.0, use longFieldMaxLength"
      },
      {
        name: "spanStackTraceMinDuration",
        configType: "durationMillisecondsNegative",
        // 'spanStackTraceMinDuration' is explicitly *not* defined in DEFAULTS
        // because normalizeSpanStackTraceMinDuration() needs to know if a value
        // was provided by the user.
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SPAN_STACK_TRACE_MIN_DURATION",
        centralConfigName: "span_stack_trace_min_duration",
        crossAgentName: "span_stack_trace_min_duration"
      },
      {
        name: "apiKey",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_API_KEY",
        crossAgentName: "api_key",
        redactFn: () => REDACTED
      },
      {
        name: "captureSpanStackTraces",
        configType: "boolean",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_CAPTURE_SPAN_STACK_TRACES",
        deprecated: "Deprecated in: v3.30.0, use spanStackTraceMinDuration"
      },
      {
        name: "contextManager",
        configType: "select(asynclocalstorage,asynchooks)",
        // 'contextManager' is explicitly *not* defined in DEFAULTS because
        // normalizeContextManager() needs to know if a value was provided by the
        // user.
        defaultValue: void 0,
        envVar: "ELASTIC_APM_CONTEXT_MANAGER"
      },
      {
        name: "frameworkName",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_FRAMEWORK_NAME"
      },
      {
        name: "frameworkVersion",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_FRAMEWORK_VERSION"
      },
      {
        name: "hostname",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_HOSTNAME"
      },
      {
        name: "payloadLogFile",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_PAYLOAD_LOG_FILE"
      },
      {
        name: "serverCaCertFile",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SERVER_CA_CERT_FILE"
      },
      {
        name: "secretToken",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SECRET_TOKEN",
        crossAgentName: "secret_token",
        redactFn: () => REDACTED
      },
      {
        name: "serviceName",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SERVICE_NAME",
        crossAgentName: "service_name"
      },
      {
        name: "serviceVersion",
        configType: "string",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SERVICE_VERSION",
        crossAgentName: "service_version"
      },
      {
        name: "spanFramesMinDuration",
        configType: "durationSecondsNegative",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_SPAN_FRAMES_MIN_DURATION",
        deprecated: "Deprecated in: v3.30.0, use spanStackTraceMinDuration"
      },
      { name: "ignoreUrls", configType: "stringArray", defaultValue: void 0 },
      {
        name: "ignoreUrlRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["ignoreUrls"]
      },
      {
        name: "ignoreUrlStr",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["ignoreUrls"]
      },
      {
        name: "ignoreUserAgents",
        configType: "stringArray",
        defaultValue: void 0
      },
      {
        name: "ignoreUserAgentRegExp",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["ignoreUserAgents"]
      },
      {
        name: "ignoreUserAgentStr",
        configType: "wildcardArray",
        defaultValue: [],
        deps: ["ignoreUserAgents"]
      },
      {
        name: "apmClientHeaders",
        configType: "stringKeyValuePairs",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_APM_CLIENT_HEADERS"
      },
      // Special options that
      // - may afect the whole config
      // - change the behavior of thelogger
      // - are for testing or internal use
      {
        name: "configFile",
        configType: "string",
        defaultValue: "elastic-apm-node.js",
        envVar: "ELASTIC_APM_CONFIG_FILE"
      },
      {
        name: "logger",
        configType: "logger",
        defaultValue: void 0,
        envVar: "ELASTIC_APM_LOGGER"
      },
      {
        name: "transport",
        configType: "function",
        defaultValue: void 0,
        internal: true
      }
    ];
    function getDefaultOptions() {
      return CONFIG_SCHEMA.reduce((acc, def) => {
        if (typeof def.defaultValue !== "undefined") {
          acc[def.name] = def.defaultValue;
        }
        return acc;
      }, {});
    }
    function getEnvironmentOptions() {
      return CONFIG_SCHEMA.reduce((acc, def) => {
        if ("environmentValue" in def) {
          acc[def.name] = def.environmentValue;
        }
        return acc;
      }, {});
    }
    function getFileOptions() {
      return CONFIG_SCHEMA.reduce((acc, def) => {
        if ("fileValue" in def) {
          acc[def.name] = def.fileValue;
        }
        return acc;
      }, {});
    }
    function readEnvOptions() {
      CONFIG_SCHEMA.forEach((def) => {
        if (def.envVar && process.env[def.envVar]) {
          def.environmentValue = process.env[def.envVar];
          def.source = "environment";
        } else if (def.envVar) {
          delete def.environmentValue;
          delete def.source;
        }
      });
    }
    function readFileOptions(confPath) {
      const configFileDef = CONFIG_SCHEMA.find((def) => def.name === "configFile");
      const defaultValue = configFileDef.defaultValue;
      const envValue = process.env[configFileDef.envVar];
      const filePath = path.resolve(confPath || envValue || defaultValue);
      if (fs.existsSync(filePath)) {
        try {
          return require(filePath);
        } catch (err) {
          console.error(
            "Elastic APM initialization error: Can't read config file %s",
            filePath
          );
          console.error(err.stack);
        }
      }
      return null;
    }
    function setStartOptions(options) {
      if (!options) {
        return;
      }
      const fileOpts2 = options.configFile && readFileOptions(options.configFile);
      CONFIG_SCHEMA.forEach((def) => {
        const source = def.source || "default";
        if (def.name in options) {
          def.startValue = options[def.name];
          if (source !== "environment") {
            def.source = "start";
          }
        } else if (fileOpts2 && def.name in fileOpts2) {
          def.fileValue = fileOpts2[def.name];
          if (source === "default") {
            def.source = "file";
          }
          console.log(def);
        }
      });
    }
    function getPreambleData(config) {
      const configFileDef = CONFIG_SCHEMA.find((def) => def.name === "configFile");
      const configFilePath = path.resolve(
        configFileDef.environmentValue || configFileDef.startValue || configFileDef.defaultValue
      );
      const result = {
        agentVersion: AGENT_VERSION,
        env: {
          pid: process.pid,
          proctitle: process.title,
          // For darwin: https://en.wikipedia.org/wiki/Darwin_%28operating_system%29#Release_history
          os: `${os.platform()} ${os.release()}`,
          arch: os.arch(),
          host: os.hostname(),
          timezone: getTimezoneUtc(),
          runtime: `Node.js ${process.version}`
        },
        config: {}
      };
      const excludedKeys = /* @__PURE__ */ new Set(["logger", "transport"]);
      const mandatoryKeys = /* @__PURE__ */ new Set([
        "serviceName",
        "serviceVersion",
        "serverUrl",
        "logLevel"
      ]);
      CONFIG_SCHEMA.forEach((def) => {
        if (excludedKeys.has(def.name) || !def.source && !mandatoryKeys.has(def.name)) {
          return;
        }
        const details = {
          source: def.source || "default",
          value: config[def.name]
        };
        const sourceVal = def[`${details.source}Value`];
        if (def.crossAgentName) {
          details.commonName = def.crossAgentName;
        }
        if (def.source === "file") {
          details.file = configFilePath;
        }
        if (typeof def.redactFn === "function") {
          details.value = def.redactFn(details.value);
        } else if (sourceVal !== details.value) {
          details.sourceValue = sourceVal;
        }
        result.config[def.name] = details;
      });
      return result;
    }
    function getTimezoneUtc() {
      const offsetHours = -((/* @__PURE__ */ new Date()).getTimezoneOffset() / 60);
      const offsetSign = offsetHours >= 0 ? "+" : "-";
      const offsetPad = Math.abs(offsetHours) < 10 ? "0" : "";
      return `UTC${offsetSign}${offsetPad}${Math.abs(offsetHours * 100)}`;
    }
    function sanitizeUrl(urlStr) {
      if (!urlStr) {
        return "";
      }
      const url = new URL2(urlStr);
      if (url.username) {
        url.username = REDACTED;
      }
      if (url.password) {
        url.password = REDACTED;
      }
      return decodeURIComponent(url.href);
    }
    var depSet = /* @__PURE__ */ new Set();
    var fileOpts = readFileOptions();
    CONFIG_SCHEMA.forEach((def) => {
      if (depSet.has(def.name)) {
        throw Error(`config option ${def.name} duplicated.`);
      }
      if (def.deps && def.deps.some((d) => !depSet.has(d))) {
        throw Error(
          `config option ${def.name} dependencies (${def.deps}) need to be defined before.`
        );
      }
      depSet.add(def.name);
      if (def.envVar && process.env[def.envVar]) {
        def.environmentValue = process.env[def.envVar];
        def.source = "environment";
      } else if (fileOpts && typeof fileOpts[def.name] !== "undefined") {
        def.fileValue = fileOpts[def.name];
        def.source = "file";
      }
    });
    function getConfigName(def) {
      return def.name;
    }
    function optsOfTypes(types) {
      if (!Array.isArray(types)) {
        types = [types];
      }
      return CONFIG_SCHEMA.filter((def) => types.indexOf(def.configType) !== -1);
    }
    var BOOL_OPTS = optsOfTypes("boolean").map(getConfigName);
    var NUM_OPTS = optsOfTypes(["number", "numberInfinity"]).map(getConfigName);
    var BYTES_OPTS = optsOfTypes("byte").map(getConfigName);
    var URL_OPTS = optsOfTypes("url").map(getConfigName);
    var ARRAY_OPTS = optsOfTypes("stringArray").map(getConfigName);
    var KEY_VALUE_OPTS = optsOfTypes("stringKeyValuePairs").map(getConfigName);
    var MINUS_ONE_EQUAL_INFINITY = optsOfTypes(["numberInfinity"]).map(
      getConfigName
    );
    var CENTRAL_CONFIG_OPTS = CONFIG_SCHEMA.filter(
      (def) => def.centralConfigName
    ).reduce((acc, def) => {
      acc[def.centralConfigName] = def.name;
      return acc;
    }, {});
    var DURATION_OPTS = [
      {
        name: "abortedErrorThreshold",
        defaultUnit: "s",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: false
      },
      {
        name: "apiRequestTime",
        defaultUnit: "s",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: false
      },
      {
        name: "exitSpanMinDuration",
        defaultUnit: "ms",
        allowedUnits: ["us", "ms", "s", "m"],
        allowNegative: false
      },
      {
        name: "metricsInterval",
        defaultUnit: "s",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: false
      },
      {
        name: "serverTimeout",
        defaultUnit: "s",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: false
      },
      {
        name: "spanCompressionExactMatchMaxDuration",
        defaultUnit: "ms",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: false
      },
      {
        name: "spanCompressionSameKindMaxDuration",
        defaultUnit: "ms",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: false
      },
      {
        // Deprecated: use `spanStackTraceMinDuration`.
        name: "spanFramesMinDuration",
        defaultUnit: "s",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: true
      },
      {
        name: "spanStackTraceMinDuration",
        defaultUnit: "ms",
        allowedUnits: ["ms", "s", "m"],
        allowNegative: true
      }
    ];
    var CROSS_AGENT_CONFIG_VAR_NAME = CONFIG_SCHEMA.filter(
      (def) => def.crossAgentName
    ).reduce((acc, def) => {
      acc[def.name] = def.crossAgentName;
      return acc;
    }, {});
    var ENV_TABLE = CONFIG_SCHEMA.filter((def) => def.envVar).reduce(
      (acc, def) => {
        acc[def.name] = def.envVar;
        return acc;
      },
      {}
    );
    module2.exports = {
      BOOL_OPTS,
      NUM_OPTS,
      DURATION_OPTS,
      BYTES_OPTS,
      MINUS_ONE_EQUAL_INFINITY,
      ARRAY_OPTS,
      KEY_VALUE_OPTS,
      URL_OPTS,
      CROSS_AGENT_CONFIG_VAR_NAME,
      CENTRAL_CONFIG_OPTS,
      ENV_TABLE,
      CONFIG_SCHEMA,
      getDefaultOptions,
      getEnvironmentOptions,
      getFileOptions,
      setStartOptions,
      getPreambleData,
      readEnvOptions
    };
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/elastic-apm-node/lib/wildcard-matcher.js
var require_wildcard_matcher = __commonJS({
  "node_modules/elastic-apm-node/lib/wildcard-matcher.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var starMatchToRegex = (pattern) => {
      let regexOpts = ["i"];
      if (pattern.startsWith("(?-i)")) {
        regexOpts = [];
        pattern = pattern.slice(5);
      }
      const patternLength = pattern.length;
      const reChars = ["^"];
      for (let i = 0; i < patternLength; i++) {
        const char = pattern[i];
        switch (char) {
          case "*":
            reChars.push(".*");
            break;
          default:
            reChars.push(escapeStringRegexp(char));
        }
      }
      reChars.push("$");
      return new RegExp(reChars.join(""), regexOpts.join(""));
    };
    var WildcardMatcher = class {
      compile(pattern) {
        return starMatchToRegex(pattern);
      }
      match(string, pattern) {
        const re2 = this.compile(pattern);
        return string.search(re2) !== -1;
      }
    };
    module2.exports = { WildcardMatcher };
  }
});

// node_modules/elastic-apm-node/lib/config/normalizers.js
var require_normalizers = __commonJS({
  "node_modules/elastic-apm-node/lib/config/normalizers.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var { WildcardMatcher } = require_wildcard_matcher();
    var {
      TRACE_CONTINUATION_STRATEGY_CONTINUE,
      TRACE_CONTINUATION_STRATEGY_RESTART,
      TRACE_CONTINUATION_STRATEGY_RESTART_EXTERNAL,
      CONTEXT_MANAGER_ASYNCHOOKS,
      CONTEXT_MANAGER_ASYNCLOCALSTORAGE
    } = require_constants2();
    function normalizeKeyValuePairs(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (key in opts) {
          if (typeof opts[key] === "object" && !Array.isArray(opts[key])) {
            opts[key] = Object.entries(opts[key]);
            continue;
          }
          if (!Array.isArray(opts[key]) && typeof opts[key] === "string") {
            opts[key] = opts[key].split(",").map((v) => v.trim());
          }
          if (Array.isArray(opts[key])) {
            opts[key] = opts[key].map(
              (value) => typeof value === "string" ? value.split("=") : value
            );
          }
        }
      }
    }
    function normalizeNumbers(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (key in opts) opts[key] = Number(opts[key]);
      }
    }
    function normalizeInfinity(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (opts[key] === -1) opts[key] = Infinity;
      }
    }
    function bytes(input, key, logger) {
      const matches = input.match(/^(\d+)(b|kb|mb|gb)$/i);
      if (!matches) {
        logger.warn(
          'units missing in size value "%s" for "%s" config option. Use one of b|kb|mb|gb',
          input,
          key
        );
        return Number(input);
      }
      const suffix = matches[2].toLowerCase();
      let value = Number(matches[1]);
      if (!suffix || suffix === "b") {
        return value;
      }
      value *= 1024;
      if (suffix === "kb") {
        return value;
      }
      value *= 1024;
      if (suffix === "mb") {
        return value;
      }
      value *= 1024;
      if (suffix === "gb") {
        return value;
      }
    }
    function normalizeBytes(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (key in opts) {
          opts[key] = bytes(String(opts[key]), key, logger);
          if (key === "errorMessageMaxLength") {
            logger.warn(
              'config option "errorMessageMaxLength" is deprecated. Use "longFieldMaxLength"'
            );
          }
        }
      }
    }
    function secondsFromDuration(duration, defaultUnit, allowedUnits, allowNegative, key, logger) {
      let val;
      let unit;
      if (typeof duration === "string") {
        let match;
        if (allowNegative) {
          match = /^(-?\d+)(\w+)?$/.exec(duration);
        } else {
          match = /^(\d+)(\w+)?$/.exec(duration);
        }
        if (!match) {
          return null;
        }
        val = Number(match[1]);
        if (isNaN(val) || !Number.isFinite(val)) {
          return null;
        }
        unit = match[2];
        if (!unit) {
          logger.warn(
            'units missing in duration value "%s" for "%s" config option: using default units "%s"',
            duration,
            key,
            defaultUnit
          );
          unit = defaultUnit;
        }
        if (!allowedUnits.includes(unit)) {
          return null;
        }
      } else if (typeof duration === "number") {
        if (isNaN(duration)) {
          return null;
        } else if (duration < 0 && !allowNegative) {
          return null;
        }
        val = duration;
        unit = defaultUnit;
      } else {
        return null;
      }
      switch (unit) {
        case "us":
          val /= 1e6;
          break;
        case "ms":
          val /= 1e3;
          break;
        case "s":
          break;
        case "m":
          val *= 60;
          break;
        default:
          throw new Error(`unknown unit "${unit}" from "${duration}"`);
      }
      return val;
    }
    function normalizeDurationOptions(opts, fields, defaults, logger) {
      for (const optSpec of fields) {
        const key = optSpec.name;
        if (key in opts) {
          const val = secondsFromDuration(
            opts[key],
            optSpec.defaultUnit,
            optSpec.allowedUnits,
            optSpec.allowNegative,
            key,
            logger
          );
          if (val === null) {
            if (key in defaults) {
              const def = defaults[key];
              logger.warn(
                'invalid duration value "%s" for "%s" config option: using default "%s"',
                opts[key],
                key,
                def
              );
              opts[key] = secondsFromDuration(
                def,
                optSpec.defaultUnit,
                optSpec.allowedUnits,
                optSpec.allowNegative,
                key,
                logger
              );
            } else {
              logger.warn(
                'invalid duration value "%s" for "%s" config option: ignoring this option',
                opts[key],
                key
              );
              delete opts[key];
            }
          } else {
            opts[key] = val;
          }
        }
      }
    }
    function normalizeArrays(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (key in opts && typeof opts[key] === "string") {
          opts[key] = opts[key].split(",").map((v) => v.trim());
        }
      }
    }
    function strictBool(logger, key, value) {
      if (typeof value === "boolean") {
        return value;
      }
      switch (value) {
        case "false":
          return false;
        case "true":
          return true;
        default: {
          logger.warn('unrecognized boolean value "%s" for "%s"', value, key);
        }
      }
    }
    function normalizeBools(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (key in opts) opts[key] = strictBool(logger, key, opts[key]);
      }
    }
    function normalizeUrls(opts, fields, defaults, logger) {
      for (const key of fields) {
        if (key in opts) {
          try {
            const url = new URL2(opts[key]);
          } catch (err) {
            logger.warn('Invalid "%s" config value, it must be a valid URL', key);
            opts[key] = null;
          }
        }
      }
    }
    function normalizeIgnoreOptions(opts, fields, defaults, logger) {
      if (opts.transactionIgnoreUrls) {
        opts.transactionIgnoreUrlRegExp = [];
        const wildcard = new WildcardMatcher();
        for (const ptn of opts.transactionIgnoreUrls) {
          const re2 = wildcard.compile(ptn);
          opts.transactionIgnoreUrlRegExp.push(re2);
        }
      }
      if (opts.ignoreUrls) {
        opts.ignoreUrlStr = [];
        opts.ignoreUrlRegExp = [];
        for (const ptn of opts.ignoreUrls) {
          if (typeof ptn === "string") {
            opts.ignoreUrlStr.push(ptn);
          } else {
            opts.ignoreUrlRegExp.push(ptn);
          }
        }
        delete opts.ignoreUrls;
      }
      if (opts.ignoreUserAgents) {
        opts.ignoreUserAgentStr = [];
        opts.ignoreUserAgentRegExp = [];
        for (const ptn of opts.ignoreUserAgents) {
          if (typeof ptn === "string") {
            opts.ignoreUserAgentStr.push(ptn);
          } else {
            opts.ignoreUserAgentRegExp.push(ptn);
          }
        }
        delete opts.ignoreUserAgents;
      }
      if (opts.ignoreMessageQueues) {
        opts.ignoreMessageQueuesRegExp = [];
        const wildcard = new WildcardMatcher();
        for (const ptn of opts.ignoreMessageQueues) {
          const re2 = wildcard.compile(ptn);
          opts.ignoreMessageQueuesRegExp.push(re2);
        }
      }
    }
    function normalizeSanitizeFieldNames(opts) {
      if (opts.sanitizeFieldNames) {
        opts.sanitizeFieldNamesRegExp = [];
        const wildcard = new WildcardMatcher();
        for (const ptn of opts.sanitizeFieldNames) {
          const re2 = wildcard.compile(ptn);
          opts.sanitizeFieldNamesRegExp.push(re2);
        }
      }
    }
    function normalizeDisableMetrics(opts) {
      if (opts.disableMetrics) {
        opts.disableMetricsRegExp = [];
        const wildcard = new WildcardMatcher();
        for (const ptn of opts.disableMetrics) {
          const re2 = wildcard.compile(ptn);
          opts.disableMetricsRegExp.push(re2);
        }
      }
    }
    function normalizeElasticsearchCaptureBodyUrls(opts) {
      if (opts.elasticsearchCaptureBodyUrls) {
        opts.elasticsearchCaptureBodyUrlsRegExp = [];
        const wildcard = new WildcardMatcher();
        for (const ptn of opts.elasticsearchCaptureBodyUrls) {
          const re2 = wildcard.compile(ptn);
          opts.elasticsearchCaptureBodyUrlsRegExp.push(re2);
        }
      }
    }
    function normalizeCloudProvider(opts, fields, defaults, logger) {
      if ("cloudProvider" in opts) {
        const allowedValues = ["auto", "gcp", "azure", "aws", "none"];
        if (allowedValues.indexOf(opts.cloudProvider) === -1) {
          logger.warn(
            'Invalid "cloudProvider" config value %s, falling back to default %s',
            opts.cloudProvider,
            defaults.cloudProvider
          );
          opts.cloudProvider = defaults.cloudProvider;
        }
      }
    }
    function normalizeCustomMetricsHistogramBoundaries(opts, fields, defaults, logger) {
      if (!("customMetricsHistogramBoundaries" in opts)) {
        return;
      }
      let val = opts.customMetricsHistogramBoundaries;
      if (typeof val === "string") {
        val = val.split(",").map((v) => Number(v.trim()));
      }
      let errReason = null;
      if (!Array.isArray(val)) {
        errReason = "value is not an array";
      } else if (val.some((el) => typeof el !== "number" || isNaN(el))) {
        errReason = "array includes non-numbers";
      } else {
        for (let i = 0; i < val.length - 1; i++) {
          if (val[i] === val[i + 1]) {
            errReason = "array has duplicate values";
            break;
          } else if (val[i] > val[i + 1]) {
            errReason = "array is not sorted";
            break;
          }
        }
      }
      if (errReason) {
        logger.warn(
          'Invalid "customMetricsHistogramBoundaries" config value %j, %s; falling back to default',
          opts.customMetricsHistogramBoundaries,
          errReason
        );
        opts.customMetricsHistogramBoundaries = defaults.customMetricsHistogramBoundaries;
      } else {
        opts.customMetricsHistogramBoundaries = val;
      }
    }
    function normalizeTransactionSampleRate(opts, fields, defaults, logger) {
      if ("transactionSampleRate" in opts) {
        const rate = opts.transactionSampleRate;
        if (isNaN(rate) || rate < 0 || rate > 1) {
          opts.transactionSampleRate = defaults.transactionSampleRate;
          logger.warn(
            'Invalid "transactionSampleRate" config value %s, falling back to default %s',
            rate,
            opts.transactionSampleRate
          );
        } else if (rate > 0 && rate < 1e-4) {
          opts.transactionSampleRate = 1e-4;
        } else {
          opts.transactionSampleRate = Math.round(rate * 1e4) / 1e4;
        }
      }
    }
    var ALLOWED_TRACE_CONTINUATION_STRATEGY = {
      [TRACE_CONTINUATION_STRATEGY_CONTINUE]: true,
      [TRACE_CONTINUATION_STRATEGY_RESTART]: true,
      [TRACE_CONTINUATION_STRATEGY_RESTART_EXTERNAL]: true
    };
    function normalizeTraceContinuationStrategy(opts, fields, defaults, logger) {
      if ("traceContinuationStrategy" in opts && !(opts.traceContinuationStrategy in ALLOWED_TRACE_CONTINUATION_STRATEGY)) {
        logger.warn(
          'Invalid "traceContinuationStrategy" config value %j, falling back to default %j',
          opts.traceContinuationStrategy,
          defaults.traceContinuationStrategy
        );
        opts.traceContinuationStrategy = defaults.traceContinuationStrategy;
      }
    }
    var ALLOWED_CONTEXT_MANAGER = {
      [CONTEXT_MANAGER_ASYNCHOOKS]: true,
      [CONTEXT_MANAGER_ASYNCLOCALSTORAGE]: true
    };
    function normalizeContextManager(opts, fields, defaults, logger) {
      if (opts.contextManager === "") {
        delete opts.contextManager;
      }
      if ("contextManager" in opts && !(opts.contextManager in ALLOWED_CONTEXT_MANAGER)) {
        logger.warn(
          'Invalid "contextManager" config value %j, falling back to default behavior',
          opts.contextManager
        );
        delete opts.contextManager;
      }
    }
    function normalizeSpanStackTraceMinDuration(opts, fields, defaults, logger) {
      const before = {};
      if (opts.captureSpanStackTraces !== void 0)
        before.captureSpanStackTraces = opts.captureSpanStackTraces;
      if (opts.spanFramesMinDuration !== void 0)
        before.spanFramesMinDuration = opts.spanFramesMinDuration;
      if (opts.spanStackTraceMinDuration !== void 0)
        before.spanStackTraceMinDuration = opts.spanStackTraceMinDuration;
      if ("spanStackTraceMinDuration" in opts) {
      } else if (opts.captureSpanStackTraces === false) {
        opts.spanStackTraceMinDuration = -1;
      } else if ("spanFramesMinDuration" in opts) {
        if (opts.spanFramesMinDuration === 0) {
          opts.spanStackTraceMinDuration = -1;
        } else if (opts.spanFramesMinDuration < 0) {
          opts.spanStackTraceMinDuration = 0;
        } else {
          opts.spanStackTraceMinDuration = opts.spanFramesMinDuration;
        }
      } else if (opts.captureSpanStackTraces === true) {
        opts.spanStackTraceMinDuration = 10 / 1e3;
      } else {
        opts.spanStackTraceMinDuration = -1;
      }
      delete opts.captureSpanStackTraces;
      delete opts.spanFramesMinDuration;
      if (Object.keys(before).length > 0) {
        const after = { spanStackTraceMinDuration: opts.spanStackTraceMinDuration };
        logger.trace({ before, after }, "normalizeSpanStackTraceMinDuration");
      }
    }
    module2.exports = {
      normalizeArrays,
      normalizeBools,
      normalizeBytes,
      normalizeCloudProvider,
      normalizeCustomMetricsHistogramBoundaries,
      normalizeDisableMetrics,
      normalizeDurationOptions,
      normalizeElasticsearchCaptureBodyUrls,
      normalizeIgnoreOptions,
      normalizeInfinity,
      normalizeKeyValuePairs,
      normalizeNumbers,
      normalizeSanitizeFieldNames,
      normalizeTransactionSampleRate,
      secondsFromDuration,
      normalizeTraceContinuationStrategy,
      normalizeContextManager,
      normalizeSpanStackTraceMinDuration,
      normalizeUrls
    };
  }
});

// node_modules/elastic-apm-node/lib/config/config.js
var require_config = __commonJS({
  "node_modules/elastic-apm-node/lib/config/config.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var truncate = require_unicode_byte_truncate();
    var { INTAKE_STRING_MAX_SIZE, REDACTED } = require_constants2();
    var logging = require_logging();
    var { NoopApmClient } = require_noop_apm_client();
    var { isLambdaExecutionEnvironment } = require_lambda();
    var {
      isAzureFunctionsEnvironment
    } = require_azure_functions();
    var {
      BOOL_OPTS,
      NUM_OPTS,
      DURATION_OPTS,
      BYTES_OPTS,
      MINUS_ONE_EQUAL_INFINITY,
      ARRAY_OPTS,
      KEY_VALUE_OPTS,
      URL_OPTS,
      getDefaultOptions,
      getEnvironmentOptions,
      getFileOptions,
      setStartOptions,
      getPreambleData,
      readEnvOptions
    } = require_schema();
    var {
      normalizeUrls,
      normalizeArrays,
      normalizeBools,
      normalizeBytes,
      normalizeDurationOptions,
      normalizeIgnoreOptions,
      normalizeInfinity,
      normalizeKeyValuePairs,
      normalizeNumbers,
      normalizeElasticsearchCaptureBodyUrls,
      normalizeDisableMetrics,
      normalizeSanitizeFieldNames,
      normalizeCloudProvider,
      normalizeCustomMetricsHistogramBoundaries,
      normalizeTransactionSampleRate,
      normalizeTraceContinuationStrategy,
      normalizeContextManager,
      normalizeSpanStackTraceMinDuration
    } = require_normalizers();
    var EXCLUDE_FIELDS = {
      logger: true,
      transport: true
    };
    var REDACT_FIELDS = {
      apiKey: true,
      secretToken: true,
      serverUrl: true
    };
    var NICE_REGEXPS_FIELDS = {
      disableMetricsRegExp: true,
      ignoreUrlRegExp: true,
      ignoreUserAgentRegExp: true,
      transactionIgnoreUrlRegExp: true,
      sanitizeFieldNamesRegExp: true,
      ignoreMessageQueuesRegExp: true
    };
    var confDefaultOptions = getDefaultOptions();
    var confEnvOpts = getEnvironmentOptions();
    var confFileOpts = getFileOptions();
    function configLogger(opts = {}) {
      const logLevel = confEnvOpts.logLevel || opts.logLevel || confFileOpts && confFileOpts.logLevel || confDefaultOptions.logLevel;
      let customLogger = null;
      if (process.env.ELASTIC_APM_LOGGER !== "false") {
        customLogger = opts.logger || confFileOpts && confFileOpts.logger;
      }
      return logging.createLogger(logLevel, customLogger);
    }
    function initialConfig(logger) {
      const cfg = Object.assign({}, confDefaultOptions);
      normalize(cfg, logger);
      cfg.transport = new NoopApmClient();
      return cfg;
    }
    function createConfig(opts, logger) {
      return new Config(opts, logger);
    }
    var Config = class {
      constructor(opts, logger) {
        readEnvOptions();
        const isLambda = isLambdaExecutionEnvironment();
        const envOptions = getEnvironmentOptions();
        setStartOptions(opts);
        Object.assign(
          this,
          confDefaultOptions,
          // default options
          getFileOptions(),
          // options read from config file
          opts,
          // options passed in to agent.start()
          envOptions
          // options read from environment variables
        );
        const customLogger = process.env.ELASTIC_APM_LOGGER === "false" ? null : this.logger;
        if (!customLogger && logger) {
          logging.setLogLevel(logger, this.logLevel);
          this.logger = logger;
        } else {
          this.logger = logging.createLogger(this.logLevel, customLogger);
        }
        if (this.serviceName) {
          try {
            validateServiceName(this.serviceName);
          } catch (err) {
            this.logger.error(
              'serviceName "%s" is invalid: %s',
              this.serviceName,
              err.message
            );
            this.serviceName = null;
          }
        } else {
          if (isLambda) {
            this.serviceName = process.env.AWS_LAMBDA_FUNCTION_NAME;
          } else if (isAzureFunctionsEnvironment && process.env.WEBSITE_SITE_NAME) {
            this.serviceName = process.env.WEBSITE_SITE_NAME;
          }
          if (this.serviceName) {
            try {
              validateServiceName(this.serviceName);
            } catch (err) {
              this.logger.warn(
                '"%s" is not a valid serviceName: %s',
                this.serviceName,
                err.message
              );
              this.serviceName = null;
            }
          }
          if (!this.serviceName) {
            try {
              this.serviceName = serviceNameFromPackageJson();
            } catch (err) {
              this.logger.warn(err.message);
            }
            if (!this.serviceName) {
              this.serviceName = "unknown-nodejs-service";
            }
          }
        }
        if (this.serviceVersion) {
        } else if (isLambda) {
          this.serviceVersion = process.env.AWS_LAMBDA_FUNCTION_VERSION;
        } else if (isAzureFunctionsEnvironment && process.env.WEBSITE_SITE_NAME) {
        } else {
          try {
            this.serviceVersion = serviceVersionFromPackageJson();
          } catch (err) {
          }
        }
        normalize(this, this.logger);
        if (isLambda || isAzureFunctionsEnvironment) {
          this.metricsInterval = 0;
          this.cloudProvider = "none";
          this.centralConfig = false;
        }
        if (this.metricsInterval === 0) {
          this.breakdownMetrics = false;
        }
        this.loggingPreambleData = getPreambleData(this);
      }
      // Return a reasonably loggable object for this Config instance.
      // Exclude undefined fields and complex objects like `logger`.
      toJSON() {
        const loggable = {};
        for (const k in this) {
          if (EXCLUDE_FIELDS[k] || this[k] === void 0) {
          } else if (REDACT_FIELDS[k]) {
            loggable[k] = REDACTED;
          } else if (NICE_REGEXPS_FIELDS[k] && Array.isArray(this[k])) {
            loggable[k] = this[k].map(
              (r) => r instanceof RegExp ? r.toString() : r
            );
          } else {
            loggable[k] = this[k];
          }
        }
        return loggable;
      }
    };
    function validateServiceName(s) {
      if (typeof s !== "string") {
        throw new Error("not a string");
      } else if (!/^[a-zA-Z0-9 _-]+$/.test(s)) {
        throw new Error(
          "contains invalid characters (allowed: a-z, A-Z, 0-9, _, -, <space>)"
        );
      }
    }
    var pkgInfoCache;
    function findPkgInfo() {
      if (pkgInfoCache === void 0) {
        let startDir = require.main && require.main.filename && path.dirname(require.main.filename);
        if (!startDir && process.argv[1]) {
          startDir = path.dirname(process.argv[1]);
        }
        if (!startDir) {
          startDir = process.cwd();
        }
        pkgInfoCache = {
          startDir,
          path: null,
          data: {}
        };
        const { root } = path.parse(startDir);
        let dir = startDir;
        while (true) {
          const pj = path.resolve(dir, "package.json");
          if (fs.existsSync(pj)) {
            pkgInfoCache.path = pj;
            break;
          }
          if (dir === root) {
            break;
          }
          dir = path.dirname(dir);
        }
        if (pkgInfoCache.path) {
          try {
            const data = JSON.parse(fs.readFileSync(pkgInfoCache.path));
            if (data.name) {
              pkgInfoCache.data.name = data.name.trim();
            }
            if (data.version) {
              pkgInfoCache.data.version = data.version;
            }
          } catch (_err) {
          }
        }
      }
      return pkgInfoCache;
    }
    function serviceNameFromPackageJson() {
      const pkg = findPkgInfo();
      if (!pkg.path) {
        throw new Error(
          `could not infer serviceName: could not find package.json up from ${pkg.startDir}`
        );
      }
      if (!pkg.data.name) {
        throw new Error(
          `could not infer serviceName: "${pkg.path}" does not contain a "name"`
        );
      }
      if (typeof pkg.data.name !== "string") {
        throw new Error(
          `could not infer serviceName: "name" in "${pkg.path}" is not a string`
        );
      }
      let serviceName = pkg.data.name;
      const match = /^@([^/]+)\/([^/]+)$/.exec(serviceName);
      if (match) {
        serviceName = match[1] + "-" + match[2];
      }
      const SERVICE_NAME_BAD_CHARS = /[^a-zA-Z0-9 _-]/g;
      serviceName = serviceName.replace(SERVICE_NAME_BAD_CHARS, "_");
      const ALL_NON_ALPHANUMERIC = /^[ _-]*$/;
      if (ALL_NON_ALPHANUMERIC.test(serviceName)) {
        serviceName = null;
      }
      if (!serviceName) {
        throw new Error(
          `could not infer serviceName from name="${pkg.data.name}" in "${pkg.path}"`
        );
      }
      return serviceName;
    }
    function serviceVersionFromPackageJson() {
      const pkg = findPkgInfo();
      if (!pkg.path) {
        throw new Error(
          `could not infer serviceVersion: could not find package.json up from ${pkg.startDir}`
        );
      }
      if (!pkg.data.version) {
        throw new Error(
          `could not infer serviceVersion: "${pkg.path}" does not contain a "version"`
        );
      }
      if (typeof pkg.data.version !== "string") {
        throw new Error(
          `could not infer serviceVersion: "version" in "${pkg.path}" is not a string`
        );
      }
      return pkg.data.version;
    }
    function normalize(opts, logger) {
      const defaults = confDefaultOptions;
      normalizeKeyValuePairs(opts, KEY_VALUE_OPTS, defaults, logger);
      normalizeNumbers(opts, NUM_OPTS, defaults, logger);
      normalizeInfinity(opts, MINUS_ONE_EQUAL_INFINITY, defaults, logger);
      normalizeBytes(opts, BYTES_OPTS, defaults, logger);
      normalizeArrays(opts, ARRAY_OPTS, defaults, logger);
      normalizeDurationOptions(opts, DURATION_OPTS, defaults, logger);
      normalizeBools(opts, BOOL_OPTS, defaults, logger);
      normalizeIgnoreOptions(opts);
      normalizeElasticsearchCaptureBodyUrls(opts);
      normalizeDisableMetrics(opts);
      normalizeSanitizeFieldNames(opts);
      normalizeContextManager(opts, [], defaults, logger);
      normalizeCloudProvider(opts, [], defaults, logger);
      normalizeTransactionSampleRate(opts, [], defaults, logger);
      normalizeTraceContinuationStrategy(opts, [], defaults, logger);
      normalizeCustomMetricsHistogramBoundaries(opts, [], defaults, logger);
      normalizeUrls(opts, URL_OPTS, defaults, logger);
      normalizeSpanStackTraceMinDuration(opts, [], defaults, logger);
      truncateOptions(opts);
    }
    function truncateOptions(opts) {
      if (opts.serviceVersion)
        opts.serviceVersion = truncate(
          String(opts.serviceVersion),
          INTAKE_STRING_MAX_SIZE
        );
      if (opts.hostname)
        opts.hostname = truncate(String(opts.hostname), INTAKE_STRING_MAX_SIZE);
    }
    module2.exports = {
      configLogger,
      initialConfig,
      createConfig,
      normalize
    };
  }
});

// node_modules/elastic-apm-node/lib/middleware/connect.js
var require_connect = __commonJS({
  "node_modules/elastic-apm-node/lib/middleware/connect.js"(exports2, module2) {
    "use strict";
    module2.exports = function connectMiddleware() {
      var agent = this;
      return function(err, req, res, next) {
        agent.captureError(err, { request: req }, function elasticAPMMiddleware() {
          next(err);
        });
      };
    };
  }
});

// node_modules/error-callsites/lib/internal/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/error-callsites/lib/internal/symbols.js"(exports2) {
    "use strict";
    exports2.callsitesSym = Symbol("callsites");
  }
});

// node_modules/error-callsites/lib/node-0.10-formatter.js
var require_node_0_10_formatter = __commonJS({
  "node_modules/error-callsites/lib/node-0.10-formatter.js"(exports2, module2) {
    "use strict";
    module2.exports = function FormatStackTrace(error, frames) {
      var lines = [];
      try {
        lines.push(error.toString());
      } catch (e) {
        try {
          lines.push("<error: " + e + ">");
        } catch (ee) {
          lines.push("<error>");
        }
      }
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        var line;
        try {
          line = frame.toString();
        } catch (e) {
          try {
            line = "<error: " + e + ">";
          } catch (ee) {
            line = "<error>";
          }
        }
        lines.push("    at " + line);
      }
      return lines.join("\n");
    };
  }
});

// node_modules/error-callsites/index.js
var require_error_callsites = __commonJS({
  "node_modules/error-callsites/index.js"(exports2, module2) {
    "use strict";
    var { callsitesSym } = require_symbols3();
    var fallback = Error.prepareStackTrace || require_node_0_10_formatter();
    var lastPrepareStackTrace = fallback;
    Object.defineProperty(Error, "prepareStackTrace", {
      configurable: true,
      enumerable: true,
      get: function() {
        return csPrepareStackTrace;
      },
      set: function(fn) {
        if (fn === csPrepareStackTrace || fn === void 0) {
          lastPrepareStackTrace = fallback;
        } else {
          lastPrepareStackTrace = fn;
        }
      }
    });
    module2.exports = function(err) {
      err.stack;
      return err[callsitesSym];
    };
    function csPrepareStackTrace(err, callsites) {
      if (Object.prototype.hasOwnProperty.call(err, callsitesSym)) {
        return fallback(err, callsites);
      }
      Object.defineProperty(err, callsitesSym, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: callsites
      });
      return lastPrepareStackTrace(err, callsites);
    }
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      let encoded = "";
      let digit;
      let vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
  }
});

// node_modules/source-map/lib/url.js
var require_url = __commonJS({
  "node_modules/source-map/lib/url.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof URL === "function" ? URL : require("url").URL;
  }
});

// node_modules/source-map/lib/util.js
var require_util2 = __commonJS({
  "node_modules/source-map/lib/util.js"(exports2) {
    var URL2 = require_url();
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      }
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports2.getArg = getArg;
    var supportsNullProto = function() {
      const obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      const length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (let i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    var PROTOCOL = "http:";
    var PROTOCOL_AND_HOST = `${PROTOCOL}//host`;
    function createSafeHandler(cb) {
      return (input) => {
        const type = getURLType(input);
        const base = buildSafeBase(input);
        const url = new URL2(input, base);
        cb(url);
        const result = url.toString();
        if (type === "absolute") {
          return result;
        } else if (type === "scheme-relative") {
          return result.slice(PROTOCOL.length);
        } else if (type === "path-absolute") {
          return result.slice(PROTOCOL_AND_HOST.length);
        }
        return computeRelativeURL(base, result);
      };
    }
    function withBase(url, base) {
      return new URL2(url, base).toString();
    }
    function buildUniqueSegment(prefix, str) {
      let id = 0;
      do {
        const ident = prefix + id++;
        if (str.indexOf(ident) === -1) return ident;
      } while (true);
    }
    function buildSafeBase(str) {
      const maxDotParts = str.split("..").length - 1;
      const segment = buildUniqueSegment("p", str);
      let base = `${PROTOCOL_AND_HOST}/`;
      for (let i = 0; i < maxDotParts; i++) {
        base += `${segment}/`;
      }
      return base;
    }
    var ABSOLUTE_SCHEME = /^[A-Za-z0-9\+\-\.]+:/;
    function getURLType(url) {
      if (url[0] === "/") {
        if (url[1] === "/") return "scheme-relative";
        return "path-absolute";
      }
      return ABSOLUTE_SCHEME.test(url) ? "absolute" : "path-relative";
    }
    function computeRelativeURL(rootURL, targetURL) {
      if (typeof rootURL === "string") rootURL = new URL2(rootURL);
      if (typeof targetURL === "string") targetURL = new URL2(targetURL);
      const targetParts = targetURL.pathname.split("/");
      const rootParts = rootURL.pathname.split("/");
      if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {
        rootParts.pop();
      }
      while (targetParts.length > 0 && rootParts.length > 0 && targetParts[0] === rootParts[0]) {
        targetParts.shift();
        rootParts.shift();
      }
      const relativePath = rootParts.map(() => "..").concat(targetParts).join("/");
      return relativePath + targetURL.search + targetURL.hash;
    }
    var ensureDirectory = createSafeHandler((url) => {
      url.pathname = url.pathname.replace(/\/?$/, "/");
    });
    var trimFilename = createSafeHandler((url) => {
      url.href = new URL2(".", url.toString()).toString();
    });
    var normalize = createSafeHandler((url) => {
    });
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      const pathType = getURLType(aPath);
      const rootType = getURLType(aRoot);
      aRoot = ensureDirectory(aRoot);
      if (pathType === "absolute") {
        return withBase(aPath, void 0);
      }
      if (rootType === "absolute") {
        return withBase(aPath, aRoot);
      }
      if (pathType === "scheme-relative") {
        return normalize(aPath);
      }
      if (rootType === "scheme-relative") {
        return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL.length);
      }
      if (pathType === "path-absolute") {
        return normalize(aPath);
      }
      if (rootType === "path-absolute") {
        return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(PROTOCOL_AND_HOST.length);
      }
      const base = buildSafeBase(aPath + aRoot);
      const newPath = withBase(aPath, withBase(aRoot, base));
      return computeRelativeURL(base, newPath);
    }
    exports2.join = join;
    function relative(rootURL, targetURL) {
      const result = relativeIfPossible(rootURL, targetURL);
      return typeof result === "string" ? result : normalize(targetURL);
    }
    exports2.relative = relative;
    function relativeIfPossible(rootURL, targetURL) {
      const urlType = getURLType(rootURL);
      if (urlType !== getURLType(targetURL)) {
        return null;
      }
      const base = buildSafeBase(rootURL + targetURL);
      const root = new URL2(rootURL, base);
      const target = new URL2(targetURL, base);
      try {
        new URL2("", target.toString());
      } catch (err) {
        return null;
      }
      if (target.protocol !== root.protocol || target.user !== root.user || target.password !== root.password || target.hostname !== root.hostname || target.port !== root.port) {
        return null;
      }
      return computeRelativeURL(root, target);
    }
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceRoot && getURLType(sourceURL) === "path-absolute") {
        sourceURL = sourceURL.replace(/^\//, "");
      }
      let url = normalize(sourceURL || "");
      if (sourceRoot) url = join(sourceRoot, url);
      if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);
      return url;
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports2) {
    var ArraySet = class _ArraySet {
      constructor() {
        this._array = [];
        this._set = /* @__PURE__ */ new Map();
      }
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      static fromArray(aArray, aAllowDuplicates) {
        const set = new _ArraySet();
        for (let i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      }
      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      size() {
        return this._set.size;
      }
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      add(aStr, aAllowDuplicates) {
        const isDuplicate = this.has(aStr);
        const idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set.set(aStr, idx);
        }
      }
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      has(aStr) {
        return this._set.has(aStr);
      }
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      indexOf(aStr) {
        const idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
        throw new Error('"' + aStr + '" is not in the set.');
      }
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      }
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      toArray() {
        return this._array.slice();
      }
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util2();
    function generatedPositionAfter(mappingA, mappingB) {
      const lineA = mappingA.generatedLine;
      const lineB = mappingB.generatedLine;
      const columnA = mappingA.generatedColumn;
      const columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    var MappingList = class {
      constructor() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      unsortedForEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      }
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      }
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      }
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util2();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    var SourceMapGenerator = class _SourceMapGenerator {
      constructor(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      static fromSourceMap(aSourceMapConsumer) {
        const sourceRoot = aSourceMapConsumer.sourceRoot;
        const generator = new _SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          const newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          let sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      }
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      addMapping(aArgs) {
        const generated = util.getArg(aArgs, "generated");
        const original = util.getArg(aArgs, "original", null);
        let source = util.getArg(aArgs, "source", null);
        let name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      }
      /**
       * Set the source content for a source file.
       */
      setSourceContent(aSourceFile, aSourceContent) {
        let source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      }
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        let sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        const sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        const newSources = this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;
        const newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            const original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          const source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          const name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(srcFile) {
          const content = aSourceMapConsumer.sourceContentFor(srcFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              srcFile = util.join(aSourceMapPath, srcFile);
            }
            if (sourceRoot != null) {
              srcFile = util.relative(sourceRoot, srcFile);
            }
            this.setSourceContent(srcFile, content);
          }
        }, this);
      }
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      _validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      }
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      _serializeMappings() {
        let previousGeneratedColumn = 0;
        let previousGeneratedLine = 1;
        let previousOriginalColumn = 0;
        let previousOriginalLine = 0;
        let previousName = 0;
        let previousSource = 0;
        let result = "";
        let next;
        let mapping;
        let nameIdx;
        let sourceIdx;
        const mappings = this._mappings.toArray();
        for (let i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      }
      _generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          const key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      }
      /**
       * Externalize the source map.
       */
      toJSON() {
        const map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      }
      /**
       * Render the source map being generated to a string.
       */
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    SourceMapGenerator.prototype._version = 3;
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      const mid = Math.floor((aHigh - aLow) / 2) + aLow;
      const cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        }
        return mid;
      }
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      }
      return aLow < 0 ? -1 : aLow;
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      let index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/read-wasm.js
var require_read_wasm = __commonJS({
  "node_modules/source-map/lib/read-wasm.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    module2.exports = function readWasm() {
      return new Promise((resolve, reject) => {
        const wasmPath = path.join(__dirname, "mappings.wasm");
        fs.readFile(wasmPath, null, (error, data) => {
          if (error) {
            reject(error);
            return;
          }
          resolve(data.buffer);
        });
      });
    };
    module2.exports.initialize = (_) => {
      console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
    };
  }
});

// node_modules/source-map/lib/wasm.js
var require_wasm = __commonJS({
  "node_modules/source-map/lib/wasm.js"(exports2, module2) {
    var readWasm = require_read_wasm();
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.lastGeneratedColumn = null;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var cachedWasm = null;
    module2.exports = function wasm() {
      if (cachedWasm) {
        return cachedWasm;
      }
      const callbackStack = [];
      cachedWasm = readWasm().then((buffer) => {
        return WebAssembly.instantiate(buffer, {
          env: {
            mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {
              const mapping = new Mapping();
              mapping.generatedLine = generatedLine + 1;
              mapping.generatedColumn = generatedColumn;
              if (hasLastGeneratedColumn) {
                mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
              }
              if (hasOriginal) {
                mapping.source = source;
                mapping.originalLine = originalLine + 1;
                mapping.originalColumn = originalColumn;
                if (hasName) {
                  mapping.name = name;
                }
              }
              callbackStack[callbackStack.length - 1](mapping);
            },
            start_all_generated_locations_for() {
              console.time("all_generated_locations_for");
            },
            end_all_generated_locations_for() {
              console.timeEnd("all_generated_locations_for");
            },
            start_compute_column_spans() {
              console.time("compute_column_spans");
            },
            end_compute_column_spans() {
              console.timeEnd("compute_column_spans");
            },
            start_generated_location_for() {
              console.time("generated_location_for");
            },
            end_generated_location_for() {
              console.timeEnd("generated_location_for");
            },
            start_original_location_for() {
              console.time("original_location_for");
            },
            end_original_location_for() {
              console.timeEnd("original_location_for");
            },
            start_parse_mappings() {
              console.time("parse_mappings");
            },
            end_parse_mappings() {
              console.timeEnd("parse_mappings");
            },
            start_sort_by_generated_location() {
              console.time("sort_by_generated_location");
            },
            end_sort_by_generated_location() {
              console.timeEnd("sort_by_generated_location");
            },
            start_sort_by_original_location() {
              console.time("sort_by_original_location");
            },
            end_sort_by_original_location() {
              console.timeEnd("sort_by_original_location");
            }
          }
        });
      }).then((Wasm) => {
        return {
          exports: Wasm.instance.exports,
          withMappingCallback: (mappingCallback, f) => {
            callbackStack.push(mappingCallback);
            try {
              f();
            } finally {
              callbackStack.pop();
            }
          }
        };
      }).then(null, (e) => {
        cachedWasm = null;
        throw e;
      });
      return cachedWasm;
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util2();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var readWasm = require_read_wasm();
    var wasm = require_wasm();
    var INTERNAL = Symbol("smcInternal");
    var SourceMapConsumer = class _SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        if (aSourceMap == INTERNAL) {
          return Promise.resolve(this);
        }
        return _factory(aSourceMap, aSourceMapURL);
      }
      static initialize(opts) {
        readWasm.initialize(opts["lib/mappings.wasm"]);
      }
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return _factoryBSM(aSourceMap, aSourceMapURL);
      }
      /**
       * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`
       * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async
       * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait
       * for `f` to complete, call `destroy` on the consumer, and return `f`'s return
       * value.
       *
       * You must not use the consumer after `f` completes!
       *
       * By using `with`, you do not have to remember to manually call `destroy` on
       * the consumer, since it will be called automatically once `f` completes.
       *
       * ```js
       * const xSquared = await SourceMapConsumer.with(
       *   myRawSourceMap,
       *   null,
       *   async function (consumer) {
       *     // Use `consumer` inside here and don't worry about remembering
       *     // to call `destroy`.
       *
       *     const x = await whatever(consumer);
       *     return x * x;
       *   }
       * );
       *
       * // You may not use that `consumer` anymore out here; it has
       * // been destroyed. But you can use `xSquared`.
       * console.log(xSquared);
       * ```
       */
      static async with(rawSourceMap, sourceMapUrl, f) {
        const consumer = await new _SourceMapConsumer(rawSourceMap, sourceMapUrl);
        try {
          return await f(consumer);
        } finally {
          consumer.destroy();
        }
      }
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      eachMapping(aCallback, aContext, aOrder) {
        throw new Error("Subclasses must implement eachMapping");
      }
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number is 1-based.
       *   - column: Optional. the column number in the original source.
       *    The column number is 0-based.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *    line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *    The column number is 0-based.
       */
      allGeneratedPositionsFor(aArgs) {
        throw new Error("Subclasses must implement allGeneratedPositionsFor");
      }
      destroy() {
        throw new Error("Subclasses must implement destroy");
      }
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    exports2.SourceMapConsumer = SourceMapConsumer;
    var BasicSourceMapConsumer = class _BasicSourceMapConsumer extends SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version = util.getArg(sourceMap, "version");
          const sources = util.getArg(sourceMap, "sources").map(String);
          const names = util.getArg(sourceMap, "names", []);
          const sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
          const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
          const mappings = util.getArg(sourceMap, "mappings");
          const file = util.getArg(sourceMap, "file", null);
          if (version != that._version) {
            throw new Error("Unsupported version: " + version);
          }
          that._sourceLookupCache = /* @__PURE__ */ new Map();
          that._names = ArraySet.fromArray(names.map(String), true);
          that._sources = ArraySet.fromArray(sources, true);
          that._absoluteSources = ArraySet.fromArray(that._sources.toArray().map(function(s) {
            return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
          }), true);
          that.sourceRoot = sourceRoot;
          that.sourcesContent = sourcesContent;
          that._mappings = mappings;
          that._sourceMapURL = aSourceMapURL;
          that.file = file;
          that._computedColumnSpans = false;
          that._mappingsPtr = 0;
          that._wasm = null;
          return wasm().then((w) => {
            that._wasm = w;
            return that;
          });
        });
      }
      /**
       * Utility function to find the index of a source.  Returns -1 if not
       * found.
       */
      _findSourceIndex(aSource) {
        const cachedIndex = this._sourceLookupCache.get(aSource);
        if (typeof cachedIndex === "number") {
          return cachedIndex;
        }
        const sourceAsMapRelative = util.computeSourceURL(null, aSource, this._sourceMapURL);
        if (this._absoluteSources.has(sourceAsMapRelative)) {
          const index = this._absoluteSources.indexOf(sourceAsMapRelative);
          this._sourceLookupCache.set(aSource, index);
          return index;
        }
        const sourceAsSourceRootRelative = util.computeSourceURL(this.sourceRoot, aSource, this._sourceMapURL);
        if (this._absoluteSources.has(sourceAsSourceRootRelative)) {
          const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);
          this._sourceLookupCache.set(aSource, index);
          return index;
        }
        return -1;
      }
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @param String aSourceMapURL
       *        The URL at which the source map can be found (optional)
       * @returns BasicSourceMapConsumer
       */
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return new _BasicSourceMapConsumer(aSourceMap.toString());
      }
      get sources() {
        return this._absoluteSources.toArray();
      }
      _getMappingsPtr() {
        if (this._mappingsPtr === 0) {
          this._parseMappings();
        }
        return this._mappingsPtr;
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings() {
        const aStr = this._mappings;
        const size = aStr.length;
        const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
        const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
        for (let i = 0; i < size; i++) {
          mappingsBuf[i] = aStr.charCodeAt(i);
        }
        const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);
        if (!mappingsPtr) {
          const error = this._wasm.exports.get_last_error();
          let msg = `Error parsing mappings (code ${error}): `;
          switch (error) {
            case 1:
              msg += "the mappings contained a negative line, column, source index, or name index";
              break;
            case 2:
              msg += "the mappings contained a number larger than 2**32";
              break;
            case 3:
              msg += "reached EOF while in the middle of parsing a VLQ";
              break;
            case 4:
              msg += "invalid base 64 character while parsing a VLQ";
              break;
            default:
              msg += "unknown error code";
              break;
          }
          throw new Error(msg);
        }
        this._mappingsPtr = mappingsPtr;
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context2 = aContext || null;
        const order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        this._wasm.withMappingCallback(
          (mapping) => {
            if (mapping.source !== null) {
              mapping.source = this._absoluteSources.at(mapping.source);
              if (mapping.name !== null) {
                mapping.name = this._names.at(mapping.name);
              }
            }
            if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {
              mapping.lastGeneratedColumn = Infinity;
            }
            aCallback.call(context2, mapping);
          },
          () => {
            switch (order) {
              case SourceMapConsumer.GENERATED_ORDER:
                this._wasm.exports.by_generated_location(this._getMappingsPtr());
                break;
              case SourceMapConsumer.ORIGINAL_ORDER:
                this._wasm.exports.by_original_location(this._getMappingsPtr());
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }
          }
        );
      }
      allGeneratedPositionsFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        const originalLine = util.getArg(aArgs, "line");
        const originalColumn = aArgs.column || 0;
        source = this._findSourceIndex(source);
        if (source < 0) {
          return [];
        }
        if (originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        this._wasm.withMappingCallback(
          (m) => {
            let lastColumn = m.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            mappings.push({
              line: m.generatedLine,
              column: m.generatedColumn,
              lastColumn
            });
          },
          () => {
            this._wasm.exports.all_generated_locations_for(
              this._getMappingsPtr(),
              source,
              originalLine - 1,
              "column" in aArgs,
              originalColumn
            );
          }
        );
        return mappings;
      }
      destroy() {
        if (this._mappingsPtr !== 0) {
          this._wasm.exports.free_mappings(this._mappingsPtr);
          this._mappingsPtr = 0;
        }
      }
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      computeColumnSpans() {
        if (this._computedColumnSpans) {
          return;
        }
        this._wasm.exports.compute_column_spans(this._getMappingsPtr());
        this._computedColumnSpans = true;
      }
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        if (needle.generatedLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.generatedColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.original_location_for(
            this._getMappingsPtr(),
            needle.generatedLine - 1,
            needle.generatedColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.generatedLine === needle.generatedLine) {
            let source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._absoluteSources.at(source);
            }
            let name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      }
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        const index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      generatedPositionFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        const needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.generated_location_for(
            this._getMappingsPtr(),
            needle.source,
            needle.originalLine - 1,
            needle.originalColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.source === needle.source) {
            let lastColumn = mapping.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
    };
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    var IndexedSourceMapConsumer = class extends SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version = util.getArg(sourceMap, "version");
          const sections = util.getArg(sourceMap, "sections");
          if (version != that._version) {
            throw new Error("Unsupported version: " + version);
          }
          let lastOffset = {
            line: -1,
            column: 0
          };
          return Promise.all(sections.map((s) => {
            if (s.url) {
              throw new Error("Support for url field in sections not implemented.");
            }
            const offset = util.getArg(s, "offset");
            const offsetLine = util.getArg(offset, "line");
            const offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
              throw new Error("Section offsets must be ordered and non-overlapping.");
            }
            lastOffset = offset;
            const cons = new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL);
            return cons.then((consumer) => {
              return {
                generatedOffset: {
                  // The offset fields are 0-based, but we use 1-based indices when
                  // encoding/decoding from VLQ.
                  generatedLine: offsetLine + 1,
                  generatedColumn: offsetColumn + 1
                },
                consumer
              };
            });
          })).then((s) => {
            that._sections = s;
            return that;
          });
        });
      }
      /**
       * The list of original sources.
       */
      get sources() {
        const sources = [];
        for (let i = 0; i < this._sections.length; i++) {
          for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        const sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(aNeedle, section2) {
            const cmp = aNeedle.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return aNeedle.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        const section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      }
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      }
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      sourceContentFor(aSource, nullOnMissing) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
      _findSectionIndex(source) {
        for (let i = 0; i < this._sections.length; i++) {
          const { consumer } = this._sections[i];
          if (consumer._findSourceIndex(source) !== -1) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      generatedPositionFor(aArgs) {
        const index = this._findSectionIndex(util.getArg(aArgs, "source"));
        const section = index >= 0 ? this._sections[index] : null;
        const nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;
        const generatedPosition = section && section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition && generatedPosition.line !== null) {
          const lineShift = section.generatedOffset.generatedLine - 1;
          const columnShift = section.generatedOffset.generatedColumn - 1;
          if (generatedPosition.line === 1) {
            generatedPosition.column += columnShift;
            if (typeof generatedPosition.lastColumn === "number") {
              generatedPosition.lastColumn += columnShift;
            }
          }
          if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {
            generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;
          }
          generatedPosition.line += lineShift;
          return generatedPosition;
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      allGeneratedPositionsFor(aArgs) {
        const index = this._findSectionIndex(util.getArg(aArgs, "source"));
        const section = index >= 0 ? this._sections[index] : null;
        const nextSection = index >= 0 && index + 1 < this._sections.length ? this._sections[index + 1] : null;
        if (!section) return [];
        return section.consumer.allGeneratedPositionsFor(aArgs).map(
          (generatedPosition) => {
            const lineShift = section.generatedOffset.generatedLine - 1;
            const columnShift = section.generatedOffset.generatedColumn - 1;
            if (generatedPosition.line === 1) {
              generatedPosition.column += columnShift;
              if (typeof generatedPosition.lastColumn === "number") {
                generatedPosition.lastColumn += columnShift;
              }
            }
            if (generatedPosition.lastColumn === Infinity && nextSection && generatedPosition.line === nextSection.generatedOffset.generatedLine) {
              generatedPosition.lastColumn = nextSection.generatedOffset.generatedColumn - 2;
            }
            generatedPosition.line += lineShift;
            return generatedPosition;
          }
        );
      }
      eachMapping(aCallback, aContext, aOrder) {
        this._sections.forEach((section, index) => {
          const nextSection = index + 1 < this._sections.length ? this._sections[index + 1] : null;
          const { generatedOffset } = section;
          const lineShift = generatedOffset.generatedLine - 1;
          const columnShift = generatedOffset.generatedColumn - 1;
          section.consumer.eachMapping(function(mapping) {
            if (mapping.generatedLine === 1) {
              mapping.generatedColumn += columnShift;
              if (typeof mapping.lastGeneratedColumn === "number") {
                mapping.lastGeneratedColumn += columnShift;
              }
            }
            if (mapping.lastGeneratedColumn === Infinity && nextSection && mapping.generatedLine === nextSection.generatedOffset.generatedLine) {
              mapping.lastGeneratedColumn = nextSection.generatedOffset.generatedColumn - 2;
            }
            mapping.generatedLine += lineShift;
            aCallback.call(this, mapping);
          }, aContext, aOrder);
        });
      }
      computeColumnSpans() {
        for (let i = 0; i < this._sections.length; i++) {
          this._sections[i].consumer.computeColumnSpans();
        }
      }
      destroy() {
        for (let i = 0; i < this._sections.length; i++) {
          this._sections[i].consumer.destroy();
        }
      }
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    function _factory(aSourceMap, aSourceMapURL) {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      return Promise.resolve(consumer);
    }
    function _factoryBSM(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    }
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util2();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    var SourceNode = class _SourceNode {
      constructor(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        const node = new _SourceNode();
        const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        let remainingLinesIndex = 0;
        const shiftNextLine = function() {
          const lineContents = getNextLine();
          const newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        let lastGeneratedLine = 1, lastGeneratedColumn = 0;
        let lastMapping = null;
        let nextLine;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              nextLine = remainingLines[remainingLinesIndex] || "";
              const code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            const source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new _SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      }
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (let i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      walk(aFn) {
        let chunk;
        for (let i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      join(aSep) {
        let newChildren;
        let i;
        const len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      }
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      replaceRight(aPattern, aReplacement) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      }
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      }
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      walkSourceContents(aFn) {
        for (let i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        const sources = Object.keys(this.sourceContents);
        for (let i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      }
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      toString() {
        let str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      }
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      toStringWithSourceMap(aArgs) {
        const generated = {
          code: "",
          line: 1,
          column: 0
        };
        const map = new SourceMapGenerator(aArgs);
        let sourceMappingActive = false;
        let lastOriginalSource = null;
        let lastOriginalLine = null;
        let lastOriginalColumn = null;
        let lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (let idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      }
    };
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/elastic-apm-node/lib/load-source-map.js
var require_load_source_map = __commonJS({
  "node_modules/elastic-apm-node/lib/load-source-map.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var INLINE_SOURCEMAP_REGEX = /^data:application\/json[^,]+base64,/;
    var SOURCEMAP_REGEX = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*(?:\*\/)[ \t]*$)/;
    var READ_FILE_OPTS = { encoding: "utf8" };
    module2.exports = function readSourceMap(filename, cb) {
      fs.readFile(filename, READ_FILE_OPTS, function(err, sourceFile) {
        if (err) {
          return cb(err);
        }
        var sourceMapUrl = resolveSourceMapUrl(sourceFile, path.dirname(filename));
        if (!sourceMapUrl) {
          return cb();
        }
        if (isInlineMap(sourceMapUrl)) {
          return onMapRead(null, decodeInlineMap(sourceMapUrl));
        }
        fs.readFile(sourceMapUrl, READ_FILE_OPTS, onMapRead);
        function onMapRead(readErr, sourceMap) {
          if (readErr) {
            readErr.message = 'Error reading sourcemap for file "' + filename + '":\n' + readErr.message;
            return cb(readErr);
          }
          try {
            new SourceMapConsumer(sourceMap).then(function onConsumerReady(consumer) {
              return cb(null, consumer);
            }, onConsumerError);
          } catch (parseErr) {
            onConsumerError(parseErr);
          }
        }
        function onConsumerError(parseErr) {
          parseErr.message = 'Error parsing sourcemap for file "' + filename + '":\n' + parseErr.message;
          return cb(parseErr);
        }
      });
    };
    function resolveSourceMapUrl(sourceFile, sourcePath) {
      var lines = sourceFile.split(/\r?\n/);
      var sourceMapUrl = null;
      for (var i = lines.length - 1; i >= 0 && !sourceMapUrl; i--) {
        sourceMapUrl = lines[i].match(SOURCEMAP_REGEX);
      }
      if (!sourceMapUrl) {
        return null;
      }
      return isInlineMap(sourceMapUrl[1]) ? sourceMapUrl[1] : path.resolve(sourcePath, sourceMapUrl[1]);
    }
    function isInlineMap(url) {
      return INLINE_SOURCEMAP_REGEX.test(url);
    }
    function decodeInlineMap(data) {
      var rawData = data.slice(data.indexOf(",") + 1);
      return Buffer.from(rawData, "base64").toString();
    }
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // properties coming in from the options of these, only max and maxSize
      // really *need* to be protected. The rest can be modified, as they just
      // set defaults for various methods.
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context2) => c.#backgroundFetch(k, index, options, context2),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the remaining TTL time for a given entry key
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.delete(this.#keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string description of an object.
       * Called by the built-in method Object.prototype.toString.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to Array.find().  fn is called as fn(value, key, cache).
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from
       * most recently used to least recently used.  fn is called as
       * fn(value, key, cache).  Does not update age or recenty of use.
       * Does not iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.delete(this.#keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
       * single key. Always returns stale values, if their info is found in the
       * cache, so be sure to check for expired TTLs if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to cache.load()
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       * Note that the shape of the resulting cache may be different if the
       * same options are not used in both caches.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context2) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context: context2
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context: context2,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context2);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context2);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.clear();
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, "delete");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, "delete"]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/elastic-apm-node/lib/stacktraces.js
var require_stacktraces = __commonJS({
  "node_modules/elastic-apm-node/lib/stacktraces.js"(exports2, module2) {
    "use strict";
    var fsPromises = require("fs/promises");
    var path = require("path");
    var { promisify } = require("util");
    var errorCallsites;
    function initStackTraceCollection() {
      errorCallsites = require_error_callsites();
    }
    var errorStackParser = require_error_stack_parser();
    var loadSourceMap = require_load_source_map();
    var { LRUCache } = require_commonjs();
    var fileCache = new LRUCache({
      max: 500,
      // fileCacheMax
      fetchMethod: async (file, _staleValue, { signal }) => {
        const data = await fsPromises.readFile(file, { encoding: "utf8" });
        if (signal.aborted) {
          return;
        }
        return data.split(/\r?\n/);
      }
    });
    var sourceMapCache = new LRUCache({
      max: 500,
      // sourceMapCacheMax
      fetchMethod: async (filename, _staleValue, { signal }) => {
        if (!filename) {
          return null;
        }
        const sourcemap = await promisify(loadSourceMap)(filename);
        if (signal.aborted) {
          return;
        }
        return sourcemap || null;
      },
      dispose: function(sourcemap, _filename, _reason) {
        if (sourcemap) {
          sourcemap.destroy();
        }
      }
    });
    var frameCache = new LRUCache({ max: 1e3 });
    var frameCacheStats = {
      hits: 0,
      misses: 0
    };
    var lastCwd = process.cwd();
    function getCwd(log) {
      let cwd;
      try {
        cwd = process.cwd();
      } catch (ex) {
        log.trace(ex, "error getting cwd: fallback back to %s", lastCwd);
        return lastCwd;
      }
      lastCwd = cwd;
      return cwd;
    }
    function stackTraceFromErrStackString(log, err) {
      const stacktrace = [];
      err = err.originalError || err;
      if (err.stack === null) {
        return [];
      }
      let frames = null;
      try {
        frames = errorStackParser.parse(err);
      } catch (parseErr) {
        log.debug("could not parse err.stack string: %s", parseErr);
      }
      if (frames) {
        const cwd = getCwd(log);
        for (var i = 0; i < frames.length; i++) {
          const frame = frames[i];
          const filename = frame.getFileName() || "";
          stacktrace.push({
            filename: getRelativeFileName(filename, cwd),
            function: frame.getFunctionName(),
            lineno: frame.getLineNumber(),
            library_frame: !isStackFrameApp(frame),
            abs_path: filename
          });
        }
      }
      return stacktrace;
    }
    var NODE_MODULES_PATH_SEG = "node_modules" + path.sep;
    function isStackFrameApp(stackframe) {
      if (isStackFrameNode(stackframe)) {
        return false;
      } else {
        const fileName = stackframe.getFileName();
        if (!fileName) {
          return true;
        } else if (fileName.indexOf(NODE_MODULES_PATH_SEG) === -1) {
          return true;
        } else {
          return false;
        }
      }
    }
    function isStackFrameNode(stackframe) {
      if (stackframe.isNative) {
        return true;
      } else {
        const fileName = stackframe.getFileName();
        if (!fileName) {
          return true;
        } else {
          return !path.isAbsolute(fileName) && fileName[0] !== ".";
        }
      }
    }
    function isCallSiteApp(callsite) {
      if (isCallSiteNode(callsite)) {
        return false;
      } else {
        const fileName = callsite.getFileName();
        if (!fileName) {
          return true;
        } else if (fileName.indexOf(NODE_MODULES_PATH_SEG) === -1) {
          return true;
        } else {
          return false;
        }
      }
    }
    function isCallSiteNode(callsite) {
      if (callsite.isNative()) {
        return true;
      } else {
        const fileName = callsite.getFileName();
        if (!fileName) {
          return true;
        } else {
          return !path.isAbsolute(fileName) && fileName[0] !== ".";
        }
      }
    }
    function isValidCallsites(callsites) {
      return Array.isArray(callsites) && callsites.length > 0 && typeof callsites[0] === "object" && typeof callsites[0].getFileName === "function";
    }
    function getCallSiteTypeNameSafely(callsite) {
      try {
        return callsite.getTypeName();
      } catch (e) {
        return null;
      }
    }
    function getCallSiteFunctionNameSanitized(callsite) {
      var fnName = callsite.getFunctionName();
      if (fnName) return fnName;
      var typeName = getCallSiteTypeNameSafely(callsite);
      if (typeName)
        return typeName + "." + (callsite.getMethodName() || "<anonymous>");
      return "<anonymous>";
    }
    function addSourceContextToFrame(frame, lines, lineNum, n) {
      var index = lineNum - 1;
      var nBefore = Math.ceil((n - 1) / 2);
      var nAfter = Math.floor((n - 1) / 2);
      frame.pre_context = lines.slice(Math.max(0, index - nBefore), index);
      frame.context_line = lines[index];
      frame.post_context = lines.slice(index + 1, index + 1 + nAfter);
    }
    function getRelativeFileName(filename, relTo) {
      if (filename.startsWith(relTo + path.sep)) {
        return filename.slice(relTo.length + 1);
      } else {
        return filename;
      }
    }
    async function getSourceMapConsumer(callsite) {
      if (isCallSiteNode(callsite)) {
        return null;
      } else {
        var filename = callsite.getFileName();
        if (!filename) {
          return null;
        } else {
          return sourceMapCache.fetch(filename);
        }
      }
    }
    async function frameFromCallSite(log, callsite, cwd, sourceLinesAppFrames, sourceLinesLibraryFrames) {
      const filename = callsite.getFileName() || "";
      const lineno = callsite.getLineNumber();
      const colno = callsite.getColumnNumber();
      const cacheKey = [
        filename,
        lineno,
        colno,
        sourceLinesAppFrames,
        sourceLinesLibraryFrames
      ].join(":");
      const cachedFrame = frameCache.get(cacheKey);
      if (cachedFrame !== void 0) {
        frameCacheStats.hits++;
        const clonedFrame = Object.assign({}, cachedFrame);
        if (clonedFrame.pre_context) {
          clonedFrame.pre_context = clonedFrame.pre_context.slice();
        }
        if (clonedFrame.post_context) {
          clonedFrame.post_context = clonedFrame.post_context.slice();
        }
        return clonedFrame;
      }
      function cacheIt(frame2) {
        frameCacheStats.misses++;
        frameCache.set(cacheKey, frame2);
      }
      let mappedFilename = null;
      let absMappedFilename = null;
      let mappedLineno = null;
      let sourceMapConsumer = null;
      try {
        sourceMapConsumer = await getSourceMapConsumer(callsite);
      } catch (sourceMapErr) {
        log.debug(
          { filename, err: sourceMapErr },
          "could not process file source map"
        );
      }
      if (sourceMapConsumer) {
        let pos;
        try {
          pos = sourceMapConsumer.originalPositionFor({
            line: lineno,
            column: colno
          });
        } catch (posErr) {
          log.debug(
            { filename, line: lineno, err: posErr },
            "could not get position from sourcemap"
          );
          pos = {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        if (pos.source !== null) {
          mappedFilename = pos.source;
          absMappedFilename = path.resolve(path.dirname(filename), mappedFilename);
        }
        if (pos.line !== null) {
          mappedLineno = pos.line;
        }
      }
      const isApp = isCallSiteApp(callsite);
      const frame = {
        filename: getRelativeFileName(absMappedFilename || filename, cwd),
        lineno: mappedLineno || lineno,
        function: getCallSiteFunctionNameSanitized(callsite),
        library_frame: !isApp
      };
      if (!Number.isFinite(frame.lineno)) {
        frame.lineno = 0;
      }
      if (filename) {
        frame.abs_path = absMappedFilename || filename;
      }
      var linesOfContext = isApp ? sourceLinesAppFrames : sourceLinesLibraryFrames;
      if (linesOfContext === 0 || !filename || isCallSiteNode(callsite)) {
        cacheIt(frame);
        return frame;
      }
      if (sourceMapConsumer && mappedFilename && mappedLineno) {
        const sourceFilename = sourceMapConsumer.sourceRoot ? path.relative(sourceMapConsumer.sourceRoot, mappedFilename) : mappedFilename;
        var source = sourceMapConsumer.sourceContentFor(sourceFilename, true);
        log.trace(
          {
            sourceRoot: sourceMapConsumer.sourceRoot,
            mappedFilename,
            sourceFilename,
            haveSourceContent: !!source
          },
          "sourcemap sourceContent lookup"
        );
        if (source) {
          addSourceContextToFrame(
            frame,
            source.split(/\r?\n/g),
            mappedLineno,
            linesOfContext
          );
          cacheIt(frame);
          return frame;
        }
      }
      if (filename.endsWith(".min.js")) {
        cacheIt(frame);
        return frame;
      }
      let lines;
      try {
        lines = await fileCache.fetch(frame.abs_path);
      } catch (fileErr) {
        log.debug(
          { filename: frame.abs_path, err: fileErr },
          "could not read file for source context"
        );
      }
      if (lines) {
        addSourceContextToFrame(frame, lines, frame.lineno, linesOfContext);
      }
      cacheIt(frame);
      return frame;
    }
    function gatherStackTrace(log, err, sourceLinesAppFrames, sourceLinesLibraryFrames, filterCallSite, cb) {
      let callsites = errorCallsites ? errorCallsites(err) : null;
      if (!isValidCallsites(callsites)) {
        log.debug('could not get valid callsites from error "%s"', err);
        setImmediate(cb, null, stackTraceFromErrStackString(log, err));
        return;
      }
      if (filterCallSite) {
        callsites = callsites.filter(filterCallSite);
        if (callsites.length === 0) {
          setImmediate(cb, null, stackTraceFromErrStackString(log, err));
          return;
        }
      }
      const cwd = getCwd(log);
      const promises = callsites.map(
        (callsite) => frameFromCallSite(
          log,
          callsite,
          cwd,
          sourceLinesAppFrames,
          sourceLinesLibraryFrames
        )
      );
      Promise.all(promises).then((stacktrace) => cb(null, stacktrace)).catch((frameErr) => {
        log.debug(
          { err, frameErr },
          "error getting a stack frame from one or more callsites"
        );
        cb(null, stackTraceFromErrStackString(log, err));
      });
    }
    module2.exports = {
      gatherStackTrace,
      frameCacheStats,
      initStackTraceCollection,
      // Exported for testing only.
      stackTraceFromErrStackString
    };
  }
});

// node_modules/elastic-apm-node/lib/errors.js
var require_errors = __commonJS({
  "node_modules/elastic-apm-node/lib/errors.js"(exports2, module2) {
    "use strict";
    var crypto2 = require("crypto");
    var path = require("path");
    var util = require("util");
    var { gatherStackTrace } = require_stacktraces();
    var MYSQL_ERROR_MSG_RE = /(ER_[A-Z_]+): /;
    function culpritFromStacktrace(frames) {
      if (frames.length === 0) return;
      var filename = frames[0].filename;
      var fnName = frames[0].function;
      for (var n = 0; n < frames.length; n++) {
        if (!frames[n].library_frame) {
          filename = frames[n].filename;
          fnName = frames[n].function;
          break;
        }
      }
      return filename ? fnName + " (" + filename + ")" : fnName;
    }
    function _moduleNameFromFrames(frames) {
      if (frames.length === 0) {
        return null;
      }
      var frame = frames[0];
      if (!frame.library_frame) {
        return null;
      }
      var idx = frame.filename.lastIndexOf("node_modules" + path.sep);
      if (idx === -1) {
        return null;
      }
      var parts = frame.filename.slice(idx).split(path.sep);
      if (!parts[1]) {
        return null;
      } else if (parts[1].startsWith("@")) {
        if (!parts[2]) {
          return null;
        } else {
          return parts[1] + "/" + parts[2];
        }
      } else {
        return parts[1];
      }
    }
    function attributesFromErr(err) {
      let n = 0;
      const attrs = {};
      const keys = Object.keys(err);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key === "stack") {
          continue;
        }
        if (key === "code") {
          continue;
        }
        let val = err[key];
        if (val === null) {
          continue;
        }
        switch (typeof val) {
          case "function":
            continue;
          case "object":
            if (typeof val.toISOString !== "function" || typeof val.getTime !== "function") {
              continue;
            } else if (Number.isNaN(val.getTime())) {
              val = "Invalid Date";
            } else {
              val = val.toISOString();
            }
        }
        attrs[key] = val;
        n++;
      }
      return n ? attrs : void 0;
    }
    function generateErrorId() {
      return crypto2.randomBytes(16).toString("hex");
    }
    function createAPMError(args, cb) {
      let numAsyncStepsRemaining = 0;
      const error = {
        id: args.id,
        timestamp: args.timestampUs
      };
      if (args.traceContext) {
        error.parent_id = args.traceContext.traceparent.id;
        error.trace_id = args.traceContext.traceparent.traceId;
      }
      if (args.trans) {
        error.transaction_id = args.trans.id;
        error.transaction = {
          name: args.trans.name,
          type: args.trans.type,
          sampled: args.trans.sampled
        };
      }
      if (args.errorContext) {
        error.context = args.errorContext;
      }
      if (args.exception) {
        const err = args.exception;
        const errMsg = String(err.message);
        error.exception = {
          message: errMsg,
          type: args.exceptionType || String(err.name),
          handled: args.handled
        };
        if ("code" in err) {
          error.exception.code = String(err.code);
        } else {
          var match = errMsg.match(MYSQL_ERROR_MSG_RE);
          if (match) {
            error.exception.code = match[1];
          }
        }
        if (args.message && typeof args.message === "string") {
          error.log = { message: args.message };
        }
        if (args.shouldCaptureAttributes) {
          const attrs = attributesFromErr(err);
          if (attrs) {
            error.exception.attributes = attrs;
          }
        }
        numAsyncStepsRemaining++;
        gatherStackTrace(
          args.log,
          args.exception,
          args.sourceLinesAppFrames,
          args.sourceLinesLibraryFrames,
          null,
          // filterCallSite
          function(_err, stacktrace) {
            const culprit = culpritFromStacktrace(stacktrace);
            if (culprit) {
              error.culprit = culprit;
            }
            const moduleName = _moduleNameFromFrames(stacktrace);
            if (moduleName) {
              error.exception.module = moduleName;
            }
            error.exception.stacktrace = stacktrace;
            finish();
          }
        );
      } else {
        error.log = {};
        const msg = args.logMessage;
        if (typeof msg === "string") {
          error.log.message = msg;
        } else if (typeof msg === "object" && msg !== null) {
          if (msg.message) {
            error.log.message = util.format.apply(
              this,
              [msg.message].concat(msg.params)
            );
            error.log.param_message = msg.message;
          } else {
            error.log.message = util.inspect(msg);
          }
        } else {
          error.log.message = String(msg);
        }
      }
      if (args.callSiteLoc) {
        numAsyncStepsRemaining++;
        gatherStackTrace(
          args.log,
          args.callSiteLoc,
          args.sourceLinesAppFrames,
          args.sourceLinesLibraryFrames,
          null,
          // filterCallSite
          function(_err, stacktrace) {
            if (stacktrace) {
              if (!error.log) {
                error.log = { message: error.exception.message };
              }
              error.log.stacktrace = stacktrace;
              finish();
            }
          }
        );
      } else {
        numAsyncStepsRemaining++;
        setImmediate(finish);
      }
      function finish() {
        numAsyncStepsRemaining--;
        if (numAsyncStepsRemaining === 0) {
          cb(null, error);
        }
      }
    }
    module2.exports = {
      generateErrorId,
      createAPMError,
      // Exported for testing.
      attributesFromErr,
      _moduleNameFromFrames
    };
  }
});

// node_modules/elastic-apm-node/lib/InflightEventSet.js
var require_InflightEventSet = __commonJS({
  "node_modules/elastic-apm-node/lib/InflightEventSet.js"(exports2, module2) {
    "use strict";
    var InflightEventSet = class extends Set {
      // Set a `fn` to be called *once* when the set size next goes to zero.
      // If the optional `timeoutMs` is given, then `fn(err)` will be called if
      // the set hasn't yet drained.
      setDrainHandler(fn, timeoutMs) {
        this._drainHandler = fn;
        if (timeoutMs) {
          this._drainTimeout = setTimeout(() => {
            this._drain(new Error("inflight event set drain timeout"));
          }, timeoutMs).unref();
        }
      }
      // Call the drain handler, if there is one.
      _drain(err) {
        if (this._drainHandler) {
          if (this._drainTimeout) {
            clearTimeout(this._drainTimeout);
            this._drainTimeout = null;
          }
          this._drainHandler(err);
          this._drainHandler = null;
        }
      }
      delete(key) {
        super.delete(key);
        if (this.size === 0) {
          this._drain();
        }
      }
    };
    module2.exports = {
      InflightEventSet
    };
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller2 = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3",
      "node:test/mock_loader": ">= 22.3",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path = require("path");
    var caller = require_caller2();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR") return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT") cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2) cb(err2);
          else init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2) cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function onfile(err2, m, pkg) {
        if (err2) cb(err2);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3) cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0) return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg) onpkg(null, pkg);
          else loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2) return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r) return load(
                [""].concat(extensions.slice()),
                path.resolve(dir, r),
                pkg
              );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2) return cb2(err2);
            if (ex) return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/") return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex) return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3) cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr) return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2) return cb2(err2);
            if (!ex) return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3) return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4) return cb2(err4);
                  if (m) return cb2(null, m, pkg2);
                  if (!pkg2) return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5) return cb2(err5);
                    if (n) return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0) return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2) return cb2(err2);
          if (!isdir2) return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2) return cb2(err2);
          if (m) return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2) return cb2(err2);
          if (n) return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller2();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2) return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2) return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2) return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2) return n2;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// node_modules/require-in-the-middle/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/require-in-the-middle/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/require-in-the-middle/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/require-in-the-middle/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/require-in-the-middle/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/require-in-the-middle/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/require-in-the-middle/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/require-in-the-middle/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/require-in-the-middle/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/require-in-the-middle/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  "node_modules/module-details-from-path/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    module2.exports = function(file) {
      var segments = file.split(path.sep);
      var index = segments.lastIndexOf("node_modules");
      if (index === -1) return;
      if (!segments[index + 1]) return;
      var scoped = segments[index + 1][0] === "@";
      var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
      var offset = scoped ? 3 : 2;
      return {
        name,
        basedir: segments.slice(0, index + offset).join(path.sep),
        path: segments.slice(index + offset).join(path.sep)
      };
    };
  }
});

// node_modules/require-in-the-middle/package.json
var require_package3 = __commonJS({
  "node_modules/require-in-the-middle/package.json"(exports2, module2) {
    module2.exports = {
      name: "require-in-the-middle",
      version: "7.4.0",
      description: "Module to hook into the Node.js require function",
      main: "index.js",
      types: "types/index.d.ts",
      dependencies: {
        debug: "^4.3.5",
        "module-details-from-path": "^1.0.3",
        resolve: "^1.22.8"
      },
      devDependencies: {
        "@babel/core": "^7.9.0",
        "@babel/preset-env": "^7.9.5",
        "@babel/preset-typescript": "^7.9.0",
        "@babel/register": "^7.9.0",
        "ipp-printer": "^1.0.0",
        patterns: "^1.0.3",
        roundround: "^0.2.0",
        semver: "^6.3.0",
        standard: "^14.3.1",
        tape: "^4.11.0"
      },
      scripts: {
        test: "npm run test:lint && npm run test:tape && npm run test:babel",
        "test:lint": "standard",
        "test:tape": "tape test/*.js",
        "test:babel": "node test/babel/babel-register.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/elastic/require-in-the-middle.git"
      },
      keywords: [
        "require",
        "hook",
        "shim",
        "shimmer",
        "shimming",
        "patch",
        "monkey",
        "monkeypatch",
        "module",
        "load"
      ],
      files: [
        "types"
      ],
      author: "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)",
      license: "MIT",
      bugs: {
        url: "https://github.com/elastic/require-in-the-middle/issues"
      },
      homepage: "https://github.com/elastic/require-in-the-middle#readme",
      engines: {
        node: ">=8.6.0"
      }
    };
  }
});

// node_modules/require-in-the-middle/index.js
var require_require_in_the_middle = __commonJS({
  "node_modules/require-in-the-middle/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var Module = require("module");
    var resolve = require_resolve();
    var debug = require_src()("require-in-the-middle");
    var moduleDetailsFromPath = require_module_details_from_path();
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    var isCore;
    if (Module.isBuiltin) {
      isCore = Module.isBuiltin;
    } else {
      const [major2, minor] = process.versions.node.split(".").map(Number);
      if (major2 === 8 && minor < 8) {
        isCore = (moduleName) => {
          if (moduleName === "http2") {
            return true;
          }
          return !!resolve.core[moduleName];
        };
      } else {
        isCore = (moduleName) => {
          return !!resolve.core[moduleName];
        };
      }
    }
    var normalize = /([/\\]index)?(\.js)?$/;
    var ExportsCache = class {
      constructor() {
        this._localCache = /* @__PURE__ */ new Map();
        this._kRitmExports = Symbol("RitmExports");
      }
      has(filename, isBuiltin) {
        if (this._localCache.has(filename)) {
          return true;
        } else if (!isBuiltin) {
          const mod = require.cache[filename];
          return !!(mod && this._kRitmExports in mod);
        } else {
          return false;
        }
      }
      get(filename, isBuiltin) {
        const cachedExports = this._localCache.get(filename);
        if (cachedExports !== void 0) {
          return cachedExports;
        } else if (!isBuiltin) {
          const mod = require.cache[filename];
          return mod && mod[this._kRitmExports];
        }
      }
      set(filename, exports3, isBuiltin) {
        if (isBuiltin) {
          this._localCache.set(filename, exports3);
        } else if (filename in require.cache) {
          require.cache[filename][this._kRitmExports] = exports3;
        } else {
          debug('non-core module is unexpectedly not in require.cache: "%s"', filename);
          this._localCache.set(filename, exports3);
        }
      }
    };
    function Hook(modules, options, onrequire) {
      if (this instanceof Hook === false) return new Hook(modules, options, onrequire);
      if (typeof modules === "function") {
        onrequire = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        onrequire = options;
        options = null;
      }
      if (typeof Module._resolveFilename !== "function") {
        console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!", typeof Module._resolveFilename);
        console.error("Please report this error as an issue related to Node.js %s at %s", process.version, require_package3().bugs.url);
        return;
      }
      this._cache = new ExportsCache();
      this._unhooked = false;
      this._origRequire = Module.prototype.require;
      const self2 = this;
      const patching = /* @__PURE__ */ new Set();
      const internals = options ? options.internals === true : false;
      const hasWhitelist = Array.isArray(modules);
      debug("registering require hook");
      this._require = Module.prototype.require = function(id) {
        if (self2._unhooked === true) {
          debug("ignoring require call - module is soft-unhooked");
          return self2._origRequire.apply(this, arguments);
        }
        return patchedRequire.call(this, arguments, false);
      };
      if (typeof process.getBuiltinModule === "function") {
        this._origGetBuiltinModule = process.getBuiltinModule;
        this._getBuiltinModule = process.getBuiltinModule = function(id) {
          if (self2._unhooked === true) {
            debug("ignoring process.getBuiltinModule call - module is soft-unhooked");
            return self2._origGetBuiltinModule.apply(this, arguments);
          }
          return patchedRequire.call(this, arguments, true);
        };
      }
      function patchedRequire(args, coreOnly) {
        const id = args[0];
        const core = isCore(id);
        let filename;
        if (core) {
          filename = id;
          if (id.startsWith("node:")) {
            const idWithoutPrefix = id.slice(5);
            if (isCore(idWithoutPrefix)) {
              filename = idWithoutPrefix;
            }
          }
        } else if (coreOnly) {
          debug("call to process.getBuiltinModule with unknown built-in id");
          return self2._origGetBuiltinModule.apply(this, args);
        } else {
          try {
            filename = Module._resolveFilename(id, this);
          } catch (resolveErr) {
            debug('Module._resolveFilename("%s") threw %j, calling original Module.require', id, resolveErr.message);
            return self2._origRequire.apply(this, args);
          }
        }
        let moduleName, basedir;
        debug("processing %s module require('%s'): %s", core === true ? "core" : "non-core", id, filename);
        if (self2._cache.has(filename, core) === true) {
          debug("returning already patched cached module: %s", filename);
          return self2._cache.get(filename, core);
        }
        const isPatching = patching.has(filename);
        if (isPatching === false) {
          patching.add(filename);
        }
        const exports3 = coreOnly ? self2._origGetBuiltinModule.apply(this, args) : self2._origRequire.apply(this, args);
        if (isPatching === true) {
          debug("module is in the process of being patched already - ignoring: %s", filename);
          return exports3;
        }
        patching.delete(filename);
        if (core === true) {
          if (hasWhitelist === true && modules.includes(filename) === false) {
            debug("ignoring core module not on whitelist: %s", filename);
            return exports3;
          }
          moduleName = filename;
        } else if (hasWhitelist === true && modules.includes(filename)) {
          const parsedPath = path.parse(filename);
          moduleName = parsedPath.name;
          basedir = parsedPath.dir;
        } else {
          const stat = moduleDetailsFromPath(filename);
          if (stat === void 0) {
            debug("could not parse filename: %s", filename);
            return exports3;
          }
          moduleName = stat.name;
          basedir = stat.basedir;
          const fullModuleName = resolveModuleName(stat);
          debug("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)", moduleName, id, fullModuleName, basedir);
          let matchFound = false;
          if (hasWhitelist) {
            if (!id.startsWith(".") && modules.includes(id)) {
              moduleName = id;
              matchFound = true;
            }
            if (!modules.includes(moduleName) && !modules.includes(fullModuleName)) {
              return exports3;
            }
            if (modules.includes(fullModuleName) && fullModuleName !== moduleName) {
              moduleName = fullModuleName;
              matchFound = true;
            }
          }
          if (!matchFound) {
            let res;
            try {
              res = resolve.sync(moduleName, { basedir });
            } catch (e) {
              debug("could not resolve module: %s", moduleName);
              self2._cache.set(filename, exports3, core);
              return exports3;
            }
            if (res !== filename) {
              if (internals === true) {
                moduleName = moduleName + path.sep + path.relative(basedir, filename);
                debug("preparing to process require of internal file: %s", moduleName);
              } else {
                debug("ignoring require of non-main module file: %s", res);
                self2._cache.set(filename, exports3, core);
                return exports3;
              }
            }
          }
        }
        self2._cache.set(filename, exports3, core);
        debug("calling require hook: %s", moduleName);
        const patchedExports = onrequire(exports3, moduleName, basedir);
        self2._cache.set(filename, patchedExports, core);
        debug("returning module: %s", moduleName);
        return patchedExports;
      }
    }
    Hook.prototype.unhook = function() {
      this._unhooked = true;
      if (this._require === Module.prototype.require) {
        Module.prototype.require = this._origRequire;
        debug("require unhook successful");
      } else {
        debug("require unhook unsuccessful");
      }
      if (process.getBuiltinModule !== void 0) {
        if (this._getBuiltinModule === process.getBuiltinModule) {
          process.getBuiltinModule = this._origGetBuiltinModule;
          debug("process.getBuiltinModule unhook successful");
        } else {
          debug("process.getBuiltinModule unhook unsuccessful");
        }
      }
    };
    function resolveModuleName(stat) {
      const normalizedPath = path.sep !== "/" ? stat.path.split(path.sep).join("/") : stat.path;
      return path.posix.join(stat.name, normalizedPath).replace(normalize, "");
    }
  }
});

// node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  "node_modules/import-in-the-middle/lib/register.js"(exports2) {
    var importHooks = [];
    var setters = /* @__PURE__ */ new WeakMap();
    var specifiers = /* @__PURE__ */ new Map();
    var toHook = [];
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value);
      },
      defineProperty(target, property, descriptor) {
        if (!("value" in descriptor)) {
          throw new Error("Getters/setters are not supported for exports property descriptors.");
        }
        return setters.get(target)[property](descriptor.value);
      }
    };
    function register(name, namespace, set, specifier) {
      specifiers.set(name, specifier);
      setters.set(namespace, set);
      const proxy = new Proxy(namespace, proxyHandler);
      importHooks.forEach((hook) => hook(name, proxy));
      toHook.push([name, proxy]);
    }
    exports2.register = register;
    exports2.importHooks = importHooks;
    exports2.specifiers = specifiers;
    exports2.toHook = toHook;
  }
});

// node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  "node_modules/import-in-the-middle/index.js"(exports2, module2) {
    var path = require("path");
    var parse = require_module_details_from_path();
    var { fileURLToPath } = require("url");
    var { MessageChannel } = require("worker_threads");
    var {
      importHooks,
      specifiers,
      toHook
    } = require_register();
    function addHook(hook) {
      importHooks.push(hook);
      toHook.forEach(([name, namespace]) => hook(name, namespace));
    }
    function removeHook(hook) {
      const index = importHooks.indexOf(hook);
      if (index > -1) {
        importHooks.splice(index, 1);
      }
    }
    function callHookFn(hookFn, namespace, name, baseDir) {
      const newDefault = hookFn(namespace, name, baseDir);
      if (newDefault && newDefault !== namespace) {
        namespace.default = newDefault;
      }
    }
    var sendModulesToLoader;
    function createAddHookMessageChannel() {
      const { port1, port2 } = new MessageChannel();
      let pendingAckCount = 0;
      let resolveFn;
      sendModulesToLoader = (modules) => {
        pendingAckCount++;
        port1.postMessage(modules);
      };
      port1.on("message", () => {
        pendingAckCount--;
        if (resolveFn && pendingAckCount <= 0) {
          resolveFn();
        }
      }).unref();
      function waitForAllMessagesAcknowledged() {
        const timer = setInterval(() => {
        }, 1e3);
        const promise = new Promise((resolve) => {
          resolveFn = resolve;
        }).then(() => {
          clearInterval(timer);
        });
        if (pendingAckCount === 0) {
          resolveFn();
        }
        return promise;
      }
      const addHookMessagePort = port2;
      const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
      return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
    }
    function Hook(modules, options, hookFn) {
      if (this instanceof Hook === false) return new Hook(modules, options, hookFn);
      if (typeof modules === "function") {
        hookFn = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        hookFn = options;
        options = null;
      }
      const internals = options ? options.internals === true : false;
      if (sendModulesToLoader && Array.isArray(modules)) {
        sendModulesToLoader(modules);
      }
      this._iitmHook = (name, namespace) => {
        const filename = name;
        const isBuiltin = name.startsWith("node:");
        let baseDir;
        if (isBuiltin) {
          name = name.replace(/^node:/, "");
        } else {
          if (name.startsWith("file://")) {
            try {
              name = fileURLToPath(name);
            } catch (e) {
            }
          }
          const details = parse(name);
          if (details) {
            name = details.name;
            baseDir = details.basedir;
          }
        }
        if (modules) {
          for (const moduleName of modules) {
            if (moduleName === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
                } else {
                  if (!baseDir.endsWith(specifiers.get(filename))) continue;
                }
              }
              callHookFn(hookFn, namespace, name, baseDir);
            }
          }
        } else {
          callHookFn(hookFn, namespace, name, baseDir);
        }
      };
      addHook(this._iitmHook);
    }
    Hook.prototype.unhook = function() {
      removeHook(this._iitmHook);
    };
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.addHook = addHook;
    module2.exports.removeHook = removeHook;
    module2.exports.createAddHookMessageChannel = createAddHookMessageChannel;
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/ids.js
var require_ids = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/ids.js"(exports2, module2) {
    "use strict";
    var { stringify } = require("querystring");
    var Ids = class {
      toString() {
        return stringify(this, " ", "=");
      }
    };
    var SpanIds = class extends Ids {
      constructor(span) {
        super();
        this["trace.id"] = span.traceId;
        this["span.id"] = span.id;
        Object.freeze(this);
      }
    };
    var TransactionIds = class extends Ids {
      constructor(transaction) {
        super();
        this["trace.id"] = transaction.traceId;
        this["transaction.id"] = transaction.id;
        Object.freeze(this);
      }
    };
    module2.exports = {
      Ids,
      SpanIds,
      TransactionIds
    };
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range2 = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range2();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/es-object-atoms/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "node_modules/es-object-atoms/RequireObjectCoercible.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    module2.exports = function RequireObjectCoercible(value) {
      if (value == null) {
        throw new $TypeError(arguments.length > 0 && arguments[1] || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/object.entries/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object.entries/implementation.js"(exports2, module2) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module2.exports = function entries(O) {
      var obj = RequireObjectCoercible(O);
      var entrys = [];
      for (var key in obj) {
        if ($isEnumerable(obj, key)) {
          $push(entrys, [key, obj[key]]);
        }
      }
      return entrys;
    };
  }
});

// node_modules/object.entries/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object.entries/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      return typeof Object.entries === "function" ? Object.entries : implementation;
    };
  }
});

// node_modules/object.entries/shim.js
var require_shim = __commonJS({
  "node_modules/object.entries/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module2.exports = function shimEntries() {
      var polyfill = getPolyfill();
      define2(Object, { entries: polyfill }, {
        entries: function testEntries() {
          return Object.entries !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object.entries/index.js
var require_object = __commonJS({
  "node_modules/object.entries/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/object-identity-map/index.js
var require_object_identity_map = __commonJS({
  "node_modules/object-identity-map/index.js"(exports2, module2) {
    var entries = require_object();
    function sortEntriesByKey([a], [b]) {
      return a > b ? 1 : -1;
    }
    function rebuildReducer(target, [key, value]) {
      target[key] = rebuildAsOrdered(value);
      return target;
    }
    function rebuildAsOrdered(source) {
      let target;
      if (Array.isArray(source)) {
        target = [];
      } else if (source && typeof source === "object") {
        target = {};
      } else {
        return source;
      }
      return entries(source).sort(sortEntriesByKey).reduce(rebuildReducer, target);
    }
    function labelsToKey(labels) {
      return JSON.stringify(rebuildAsOrdered(labels));
    }
    var ObjectIdentityMap = class extends Map {
      has(labels) {
        return super.has(labelsToKey(labels));
      }
      get(labels) {
        return super.get(labelsToKey(labels));
      }
      set(labels, value) {
        return super.set(labelsToKey(labels), value);
      }
      delete(labels) {
        return super.delete(labelsToKey(labels));
      }
      ensure(labels, build) {
        const key = labelsToKey(labels);
        if (!super.has(key)) {
          super.set(key, build(labels));
        }
        return super.get(key);
      }
    };
    module2.exports = ObjectIdentityMap;
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/dropped-spans-stats.js
var require_dropped_spans_stats = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/dropped-spans-stats.js"(exports2, module2) {
    "use strict";
    var MAX_DROPPED_SPANS_STATS = 128;
    var DroppedSpansStats = class {
      constructor() {
        this.statsMap = /* @__PURE__ */ new Map();
      }
      /**
       * Record this span in dropped spans stats.
       *
       * @param {Span} span
       * @returns {boolean} True iff this span was added to stats. This return value
       *    is only used for testing.
       */
      captureDroppedSpan(span) {
        if (!span) {
          return false;
        }
        const serviceTargetType = span._serviceTarget && span._serviceTarget.type;
        const serviceTargetName = span._serviceTarget && span._serviceTarget.name;
        const resource = span._destination && span._destination.service && span._destination.service.resource;
        if (!span._exitSpan || !(serviceTargetType || serviceTargetName) || !resource) {
          return false;
        }
        const stats = this._getOrCreateStats(
          serviceTargetType,
          serviceTargetName,
          resource,
          span.outcome
        );
        if (!stats) {
          return false;
        }
        stats.duration.count++;
        stats.duration.sum.us += span._duration * 1e3;
        return true;
      }
      _getOrCreateStats(serviceTargetType, serviceTargetName, resource, outcome) {
        const key = [serviceTargetType, serviceTargetName, resource, outcome].join(
          ""
        );
        let stats = this.statsMap.get(key);
        if (stats) {
          return stats;
        }
        if (this.statsMap.size >= MAX_DROPPED_SPANS_STATS) {
          return;
        }
        stats = {
          duration: {
            count: 0,
            sum: {
              us: 0
            }
          },
          destination_service_resource: resource,
          outcome
        };
        if (serviceTargetType) {
          stats.service_target_type = serviceTargetType;
        }
        if (serviceTargetName) {
          stats.service_target_name = serviceTargetName;
        }
        this.statsMap.set(key, stats);
        return stats;
      }
      encode() {
        const result = [];
        for (const stats of this.statsMap.values()) {
          stats.duration.sum.us = Math.round(stats.duration.sum.us);
          result.push(stats);
        }
        return result;
      }
      size() {
        return this.statsMap.size;
      }
    };
    module2.exports = {
      DroppedSpansStats,
      // Exported for testing-only.
      MAX_DROPPED_SPANS_STATS
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/express-utils.js
var require_express_utils = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/express-utils.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var symbols = require_symbols();
    function normalizeSlash(value) {
      return value[0] === "/" ? value : "/" + value;
    }
    function excludeRoot(value) {
      return value !== "/";
    }
    function join(parts) {
      if (!parts) return;
      return parts.filter(excludeRoot).map(normalizeSlash).join("") || "/";
    }
    function routePath(route) {
      if (!route) return;
      return route.path || route.regexp && route.regexp.source;
    }
    function getStackPath(req) {
      var stack = req[symbols.expressMountStack];
      return join(stack);
    }
    function getPathFromRequest(req, useBase, usePathAsTransactionName) {
      if (req[symbols.staticFile]) {
        return "static file";
      }
      var path = getStackPath(req);
      var route = routePath(req.route);
      if (route) {
        return path ? join([path, route]) : route;
      } else if (path && (path !== "/" || useBase)) {
        return path;
      }
      if (usePathAsTransactionName) {
        let base;
        try {
          const url2 = new url2.URL("http://" + (req.headers && req.headers.host));
          base = "http://" + url2.hostname;
        } catch (err) {
          base = "http://undefined";
        }
        const parsed = req.url.startsWith("/") ? new url.URL(base + req.url) : new url.URL(req.url, base);
        return parsed && parsed.pathname;
      }
    }
    module2.exports = {
      getPathFromRequest,
      getStackPath,
      routePath
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/span-compression.js
var require_span_compression = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/span-compression.js"(exports2, module2) {
    "use strict";
    var STRATEGY_EXACT_MATCH = "exact_match";
    var STRATEGY_SAME_KIND = "same_kind";
    var SpanCompression = class {
      constructor(agent) {
        this._bufferedSpan = null;
        this._agent = agent;
        this.timestamp = null;
        this.duration = 0;
        this.composite = {
          count: 0,
          sum: 0,
          compression_strategy: null
        };
      }
      setBufferedSpan(span) {
        this._bufferedSpan = span;
      }
      getBufferedSpan() {
        return this._bufferedSpan;
      }
      // Compares two spans and returns which compression strategy to use
      // or returns false if the second span can't be compressed into the
      // first.
      //
      // @param Span compositeSpan
      // @param Span toCompressSpan
      // @returns boolean|String
      _getCompressionStrategy(compositeSpan, toCompressSpan) {
        if (!this._isEnabled() || !compositeSpan._serviceTarget || !toCompressSpan._serviceTarget) {
          return false;
        }
        const isSameKind = this.isSameKind(compositeSpan, toCompressSpan);
        if (!isSameKind) {
          return false;
        }
        let strategy = STRATEGY_SAME_KIND;
        if (compositeSpan.name === toCompressSpan.name) {
          strategy = STRATEGY_EXACT_MATCH;
        }
        return strategy;
      }
      isSameKind(compositeSpan, toCompressSpan) {
        return compositeSpan.type === toCompressSpan.type && compositeSpan.subtype === toCompressSpan.subtype && compositeSpan._serviceTarget.type === toCompressSpan._serviceTarget.type && compositeSpan._serviceTarget.name === toCompressSpan._serviceTarget.name;
      }
      // Sets initial composite values or confirms strategy matches
      //
      // Returns true if spanToCompress can be compressed into compositeSpan,
      // returns false otherwise.
      //
      // @param Span compositeSpan
      // @param Span spanToCompress
      // @returns boolean
      _initCompressionStrategy(compositeSpan, spanToCompress) {
        if (!this.composite.compression_strategy) {
          this.composite.compression_strategy = this._getCompressionStrategy(
            compositeSpan,
            spanToCompress
          );
          if (!this.composite.compression_strategy) {
            return false;
          }
          this.timestamp = compositeSpan.timestamp;
          this.composite.count = 1;
          this.composite.sum = compositeSpan._duration;
        } else {
          const strat = this._getCompressionStrategy(compositeSpan, spanToCompress);
          if (strat !== this.composite.compression_strategy) {
            return false;
          }
        }
        return true;
      }
      // Attempts to compression the second span into the first
      //
      // @param Span compositeSpan
      // @param Span spanToCompress
      // @return boolean
      tryToCompress(compositeSpan, spanToCompress) {
        if (!this._isEnabled()) {
          return false;
        }
        if (!this._initCompressionStrategy(compositeSpan, spanToCompress)) {
          return false;
        }
        const isAlreadyComposite = this.isComposite();
        const canBeCompressed = isAlreadyComposite ? this.tryToCompressComposite(compositeSpan, spanToCompress) : this.tryToCompressRegular(compositeSpan, spanToCompress);
        if (!canBeCompressed) {
          return false;
        }
        if (!isAlreadyComposite) {
          this.composite.count = 1;
          this.composite.sum = compositeSpan._duration;
        }
        this.composite.count++;
        this.composite.sum += spanToCompress._duration;
        this.duration = (spanToCompress._endTimestamp - compositeSpan.timestamp) / 1e3;
        return true;
      }
      tryToCompressRegular(compositeSpan, spanToCompress) {
        if (!this.isSameKind(compositeSpan, spanToCompress)) {
          return false;
        }
        if (compositeSpan.name === spanToCompress.name) {
          if (this.duration <= this._agent._conf.spanCompressionExactMatchMaxDuration * 1e3 && spanToCompress._duration <= this._agent._conf.spanCompressionExactMatchMaxDuration * 1e3) {
            this.composite.compression_strategy = STRATEGY_EXACT_MATCH;
            return true;
          }
          return false;
        }
        if (this.duration <= this._agent._conf.spanCompressionSameKindMaxDuration * 1e3 && spanToCompress._duration <= this._agent._conf.spanCompressionSameKindMaxDuration * 1e3) {
          this.composite.compression_strategy = STRATEGY_SAME_KIND;
          compositeSpan.name = this._spanNameFromCompositeSpan(compositeSpan);
          return true;
        }
        return false;
      }
      tryToCompressComposite(compositeSpan, spanToCompress) {
        switch (this.composite.compression_strategy) {
          case STRATEGY_EXACT_MATCH:
            return this.isSameKind(compositeSpan, spanToCompress) && compositeSpan.name === spanToCompress.name && spanToCompress._duration <= this._agent._conf.spanCompressionExactMatchMaxDuration * 1e3;
          case STRATEGY_SAME_KIND:
            return this.isSameKind(compositeSpan, spanToCompress) && spanToCompress._duration <= this._agent._conf.spanCompressionSameKindMaxDuration * 1e3;
        }
      }
      _spanNameFromCompositeSpan(compositeSpan) {
        const prefix = "Calls to ";
        const serviceTarget = compositeSpan._serviceTarget;
        if (!serviceTarget.type) {
          if (!serviceTarget.name) {
            return prefix + "unknown";
          } else {
            return prefix + serviceTarget.name;
          }
        } else if (!serviceTarget.name) {
          return prefix + serviceTarget.type;
        } else {
          return prefix + serviceTarget.type + "/" + serviceTarget.name;
        }
      }
      _isEnabled() {
        return this._agent._conf.spanCompressionEnabled;
      }
      isCompositeSameKind() {
        return this.composite.compression_strategy === STRATEGY_SAME_KIND;
      }
      isComposite() {
        return this.composite.count > 1;
      }
      // Encodes/Serializes composite span properties
      // @return Object
      encode() {
        return {
          compression_strategy: this.composite.compression_strategy,
          count: this.composite.count,
          sum: this.composite.sum
        };
      }
    };
    module2.exports = {
      SpanCompression,
      constants: {
        STRATEGY_EXACT_MATCH,
        STRATEGY_SAME_KIND
      }
    };
  }
});

// node_modules/relative-microtime/index.js
var require_relative_microtime = __commonJS({
  "node_modules/relative-microtime/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function sync() {
      const nanoStart = process.hrtime();
      const microStart = Date.now() * 1e3;
      return function microtime() {
        const diff = process.hrtime(nanoStart);
        const microRemainder = diff[1] / 1e3 | 0;
        const microDelta = diff[0] * 1e6 + microRemainder;
        return microStart + microDelta;
      };
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/timer.js
var require_timer = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/timer.js"(exports2, module2) {
    "use strict";
    var microtime = require_relative_microtime();
    function maybeTime(timer, time) {
      if (time >= 0) {
        return time * 1e3;
      } else {
        return timer._timer();
      }
    }
    module2.exports = class Timer {
      // `startTime`: millisecond float
      constructor(parentTimer, startTime) {
        this._parent = parentTimer;
        this._timer = parentTimer ? parentTimer._timer : microtime();
        this.start = maybeTime(this, startTime);
        this.endTimestamp = null;
        this.duration = null;
        this.selfTime = null;
        this.activeChildren = 0;
        this.childStart = 0;
        this.childDuration = 0;
        if (this._parent) {
          this._parent.startChild(startTime);
        }
      }
      startChild(startTime) {
        if (++this.activeChildren === 1) {
          this.childStart = maybeTime(this, startTime);
        }
      }
      endChild(endTime) {
        if (--this.activeChildren === 0) {
          this.incrementChildDuration(endTime);
        }
      }
      incrementChildDuration(endTime) {
        this.childDuration += (maybeTime(this, endTime) - this.childStart) / 1e3;
        this.childStart = 0;
      }
      // `endTime`: millisecond float
      end(endTime) {
        if (this.duration !== null) return;
        this.duration = this.elapsed(endTime);
        if (this.activeChildren) {
          this.incrementChildDuration(endTime);
        }
        this.selfTime = this.duration - this.childDuration;
        if (this._parent) {
          this._parent.endChild(endTime);
        }
        this.endTimestamp = this._timer();
      }
      // `endTime`: millisecond float
      // returns: millisecond float
      elapsed(endTime) {
        return (maybeTime(this, endTime) - this.start) / 1e3;
      }
    };
  }
});

// node_modules/elastic-apm-node/lib/tracecontext/traceparent.js
var require_traceparent = __commonJS({
  "node_modules/elastic-apm-node/lib/tracecontext/traceparent.js"(exports2, module2) {
    "use strict";
    var { randomFillSync } = require("crypto");
    var SIZES = {
      version: 1,
      traceId: 16,
      id: 8,
      flags: 1,
      parentId: 8,
      // Aggregate sizes
      ids: 24,
      // traceId + id
      all: 34
    };
    var OFFSETS = {
      version: 0,
      traceId: SIZES.version,
      id: SIZES.version + SIZES.traceId,
      flags: SIZES.version + SIZES.ids,
      // Additional parentId is stored after the header content
      parentId: SIZES.version + SIZES.ids + SIZES.flags
    };
    var FLAGS = {
      recorded: 1
    };
    function defineLazyProp(obj, prop, fn) {
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        get() {
          const value = fn();
          if (value !== void 0) {
            Object.defineProperty(obj, prop, {
              configurable: true,
              enumerable: true,
              value
            });
          }
          return value;
        }
      });
    }
    function hexSliceFn(buffer, offset, length) {
      return () => buffer.slice(offset, length).toString("hex");
    }
    function maybeHexSliceFn(buffer, offset, length) {
      const fn = hexSliceFn(buffer, offset, length);
      return () => {
        const value = fn();
        if (/[1-9a-f]/.test(value)) {
          return value;
        }
      };
    }
    function makeChild(buffer) {
      buffer.copy(buffer, OFFSETS.parentId, OFFSETS.id, OFFSETS.flags);
      randomFillSync(buffer, OFFSETS.id, SIZES.id);
      return new TraceParent(buffer);
    }
    function isValidHeader(header) {
      return /^[\da-f]{2}-[\da-f]{32}-[\da-f]{16}-[\da-f]{2}$/.test(header);
    }
    function headerToBuffer(header) {
      const buffer = Buffer.alloc(SIZES.all);
      buffer.write(header.replace(/-/g, ""), "hex");
      return buffer;
    }
    function resume(header) {
      return makeChild(headerToBuffer(header));
    }
    function start(sampled = false) {
      const buffer = Buffer.alloc(SIZES.all);
      randomFillSync(buffer, OFFSETS.traceId, SIZES.ids);
      if (sampled) {
        buffer[OFFSETS.flags] |= FLAGS.recorded;
      }
      return new TraceParent(buffer);
    }
    var bufferSymbol = Symbol("trace-context-buffer");
    var TraceParent = class _TraceParent {
      constructor(buffer) {
        this[bufferSymbol] = buffer;
        Object.defineProperty(this, "recorded", {
          enumerable: true,
          get: function() {
            return !!(this[bufferSymbol][OFFSETS.flags] & FLAGS.recorded);
          }
        });
        defineLazyProp(
          this,
          "version",
          hexSliceFn(buffer, OFFSETS.version, OFFSETS.traceId)
        );
        defineLazyProp(
          this,
          "traceId",
          hexSliceFn(buffer, OFFSETS.traceId, OFFSETS.id)
        );
        defineLazyProp(this, "id", hexSliceFn(buffer, OFFSETS.id, OFFSETS.flags));
        defineLazyProp(
          this,
          "flags",
          hexSliceFn(buffer, OFFSETS.flags, OFFSETS.parentId)
        );
        defineLazyProp(this, "parentId", maybeHexSliceFn(buffer, OFFSETS.parentId));
      }
      static startOrResume(childOf, conf) {
        if (childOf instanceof _TraceParent) return childOf.child();
        if (childOf && childOf._context instanceof _TraceParent)
          return childOf._context.child();
        return isValidHeader(childOf) ? resume(childOf) : start(Math.random() <= conf.transactionSampleRate);
      }
      static fromString(header) {
        return new _TraceParent(headerToBuffer(header));
      }
      ensureParentId() {
        let id = this.parentId;
        if (!id) {
          randomFillSync(this[bufferSymbol], OFFSETS.parentId, SIZES.id);
          id = this.parentId;
        }
        return id;
      }
      child() {
        return makeChild(Buffer.from(this[bufferSymbol]));
      }
      setRecorded(value) {
        if (value) {
          this[bufferSymbol][OFFSETS.flags] |= FLAGS.recorded;
        } else {
          this[bufferSymbol][OFFSETS.flags] &= ~FLAGS.recorded;
        }
      }
      toString() {
        return `${this.version}-${this.traceId}-${this.id}-${this.flags}`;
      }
    };
    TraceParent.FLAGS = FLAGS;
    module2.exports = {
      TraceParent
    };
  }
});

// node_modules/elastic-apm-node/lib/tracecontext/tracestate.js
var require_tracestate = __commonJS({
  "node_modules/elastic-apm-node/lib/tracecontext/tracestate.js"(exports2, module2) {
    "use strict";
    function getLogger() {
      return require_elastic_apm_node().logger;
    }
    var TraceState = class _TraceState {
      constructor(sourceBuffer, listMemberNamespace = "es", defaultValues = {}) {
        if (!this._validateVendorKey(listMemberNamespace)) {
          throw new Error("Vendor namespace failed validation.");
        }
        this.buffer = sourceBuffer;
        this.listMemberNamespace = listMemberNamespace;
        this.values = {};
        for (const key in defaultValues) {
          const value = defaultValues[key];
          this.setValue(key, value);
        }
      }
      setValue(key, value) {
        const strKey = String(key);
        const strValue = String(value);
        if (!this._validateElasicKeyAndValue(strKey, strValue)) {
          getLogger().trace(
            "could not set tracestate key, invalid characters detected"
          );
          return false;
        }
        const isFirstSet = Object.keys(this.values).length === 0;
        const oldValue = this.values[strKey];
        this.values[strKey] = value;
        const serializedValue = this._serializeValues(this.values);
        if (serializedValue.length > 256 && typeof oldValue === "undefined") {
          delete this.values[strKey];
          return false;
        }
        if (serializedValue.length > 256 && typeof oldValue !== "undefined") {
          this.values[strKey] = oldValue;
          return false;
        }
        if (isFirstSet && Object.keys(this.values).length === 1) {
          const [buffer, values] = _TraceState._removeMemberNamespaceFromBuffer(
            this.buffer,
            this.listMemberNamespace
          );
          this.buffer = buffer;
          this.values = values;
          values[strKey] = value;
        }
        return true;
      }
      getValue(keyToGet) {
        const allValues = this.toObject();
        const rawValue = allValues[this.listMemberNamespace];
        if (!rawValue) {
          return rawValue;
        }
        const values = _TraceState._parseValues(rawValue);
        return values[keyToGet];
      }
      toHexString() {
        const newBuffer = Buffer.alloc(this.buffer.length);
        let newBufferOffset = 0;
        for (let i = 0; i < this.buffer.length; i++) {
          const byte = this.buffer[i];
          if (byte === 0) {
            const indexOfKeyLength = i + 1;
            const indexOfKey = i + 2;
            const lengthKey = this.buffer[indexOfKeyLength];
            const indexOfValueLength = indexOfKey + lengthKey;
            const indexOfValue = indexOfValueLength + 1;
            const lengthValue = this.buffer[indexOfValueLength];
            const key = this.buffer.slice(indexOfKey, indexOfKey + lengthKey).toString();
            if (key === this.listMemberNamespace) {
              continue;
            }
            this.buffer.copy(
              newBuffer,
              newBufferOffset,
              i,
              indexOfValue + lengthValue
            );
            newBufferOffset += indexOfValue + lengthValue;
            i = indexOfValue + lengthValue - 1;
            continue;
          }
        }
        const ourBytes = [];
        if (Object.keys(this.values).length > 0) {
          ourBytes.push(0);
          ourBytes.push(this.listMemberNamespace.length);
          for (let i = 0; i < this.listMemberNamespace.length; i++) {
            ourBytes.push(this.listMemberNamespace.charCodeAt(i));
          }
          const serializedValue = this._serializeValues(this.values);
          ourBytes.push(serializedValue.length);
          for (let i = 0; i < serializedValue.length; i++) {
            ourBytes.push(serializedValue.charCodeAt(i));
          }
        }
        const ourBuffer = Buffer.from(ourBytes);
        return Buffer.concat(
          [newBuffer, ourBuffer],
          newBuffer.length + ourBuffer.length
        ).toString("hex");
      }
      /**
       * Returns JSON reprenstation of tracestate key/value pairs
       *
       * Does not parse the mutable list namespace
       */
      toObject() {
        const map = this.toMap();
        const obj = {};
        for (const key of map.keys()) {
          obj[key] = map.get(key);
        }
        return obj;
      }
      toMap() {
        const map = /* @__PURE__ */ new Map();
        if (Object.keys(this.values).length) {
          map.set(this.listMemberNamespace, this._serializeValues(this.values));
        }
        for (let i = 0; i < this.buffer.length; i++) {
          const byte = this.buffer[i];
          if (byte === 0) {
            const indexOfKeyLength = i + 1;
            const indexOfKey = i + 2;
            const lengthKey = this.buffer[indexOfKeyLength];
            const indexOfValueLength = indexOfKey + lengthKey;
            const indexOfValue = indexOfValueLength + 1;
            const lengthValue = this.buffer[indexOfValueLength];
            const key = this.buffer.slice(indexOfKey, indexOfKey + lengthKey).toString();
            const value = this.buffer.slice(indexOfValue, indexOfValue + lengthValue).toString();
            map.set(key, value);
            i = indexOfValue + lengthValue - 1;
            continue;
          }
        }
        return map;
      }
      toString() {
        return this.toW3cString();
      }
      toW3cString() {
        const json = this.toObject();
        const chars = [];
        for (const key in json) {
          const value = json[key];
          if (!value) {
            continue;
          }
          chars.push(key);
          chars.push("=");
          chars.push(value);
          chars.push(",");
        }
        chars.pop();
        return chars.join("");
      }
      _serializeValues(keyValues) {
        const chars = [];
        for (const key in keyValues) {
          const value = keyValues[key];
          chars.push(`${key}:${value}`);
          chars.push(";");
        }
        chars.pop();
        return chars.join("");
      }
      _validateVendorKey(key) {
        if (key.length > 256 || key.length < 1) {
          return false;
        }
        const re2 = /^[abcdefghijklmnopqrstuvwxyz0123456789_\-*/]*$/;
        if (!key.match(re2)) {
          return false;
        }
        return true;
      }
      _validateElasicKeyAndValue(key, value) {
        const re2 = /^[ \][!"#$%&'()*+\-./0123456789<>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz{|}~]*$/;
        if (!key.match(re2) || !value.match(re2)) {
          return false;
        }
        if (key.length > 256 || value.length > 256) {
          return false;
        }
        return true;
      }
      static fromBinaryFormatHexString(string, listMemberNamespace = "es") {
        return new _TraceState(Buffer.from(string, "hex"), listMemberNamespace);
      }
      static fromStringFormatString(string = "", listMemberNamespace = "es") {
        const bytes = [];
        const parts = string.split(",");
        for (let part of parts) {
          part = part.trim();
          if (!part) {
            continue;
          }
          const [listMember, value] = part.split("=");
          if (!listMember || !value) {
            continue;
          }
          bytes.push(0);
          bytes.push(listMember.length);
          for (let i = 0; i < listMember.length; i++) {
            bytes.push(listMember.charCodeAt(i));
          }
          bytes.push(value.length);
          for (let i = 0; i < value.length; i++) {
            bytes.push(value.charCodeAt(i));
          }
        }
        return new _TraceState(Buffer.from(bytes), listMemberNamespace);
      }
      static _parseValues(rawValues) {
        const parsedValues = {};
        const parts = rawValues.split(";");
        for (const keyValue of parts) {
          if (!keyValue) {
            continue;
          }
          const [key, value] = keyValue.split(":");
          if (!key || !value) {
            continue;
          }
          parsedValues[key] = value;
        }
        return parsedValues;
      }
      static _removeMemberNamespaceFromBuffer(buffer, listMemberNamespace) {
        const newBuffer = Buffer.alloc(buffer.length);
        let newBufferOffset = 0;
        const values = {};
        for (let i = 0; i < buffer.length; i++) {
          const byte = buffer[i];
          if (byte === 0) {
            const indexOfKeyLength = i + 1;
            const indexOfKey = i + 2;
            const lengthKey = buffer[indexOfKeyLength];
            const indexOfValueLength = indexOfKey + lengthKey;
            const indexOfValue = indexOfValueLength + 1;
            const lengthValue = buffer[indexOfValueLength];
            const key = buffer.slice(indexOfKey, indexOfKey + lengthKey).toString();
            if (key === listMemberNamespace) {
              const rawValues = buffer.slice(indexOfValue, indexOfValue + lengthValue).toString();
              const parsedValues = _TraceState._parseValues(rawValues);
              for (const key2 in parsedValues) {
                values[key2] = parsedValues[key2];
              }
              continue;
            } else {
              buffer.copy(
                newBuffer,
                newBufferOffset,
                i,
                indexOfValue + lengthValue
              );
              newBufferOffset += indexOfValue + lengthValue - i;
            }
            i = indexOfValue + lengthValue - 1;
            continue;
          }
        }
        const trimmedBuffer = newBuffer.slice(0, newBufferOffset);
        return [trimmedBuffer, values];
      }
    };
    module2.exports = TraceState;
  }
});

// node_modules/elastic-apm-node/lib/tracecontext/index.js
var require_tracecontext = __commonJS({
  "node_modules/elastic-apm-node/lib/tracecontext/index.js"(exports2, module2) {
    "use strict";
    var { TraceParent } = require_traceparent();
    var TraceState = require_tracestate();
    var TraceContext = class _TraceContext {
      constructor(traceparent, tracestate, conf = {}) {
        this.traceparent = traceparent;
        this.tracestate = tracestate;
        this._conf = conf;
      }
      // Resume (a.k.a. continue) a trace if `childOf` includes trace-context.
      // Otherwise, make a sampling decision and start new trace-context.
      //
      // @param { Transaction | Span | TraceParent | string | undefined } childOf
      //    If this is a Transaction, Span, or TraceParent instance, or a valid
      //    W3C trace-context 'traceparent' string, then the trace is continued.
      //    Otherwise a sampling decision made based on
      //    `conf.transactionSampleRate` and a new trace is started.
      // @param { Object } conf - The agent configuration.
      // @param { TraceState | string } tracestateArg - A TraceState instance or
      //    a W3C trace-context 'tracestate' string.
      static startOrResume(childOf, conf, tracestateArg) {
        if (childOf && childOf._context instanceof _TraceContext)
          return childOf._context.child();
        const traceparent = TraceParent.startOrResume(childOf, conf);
        const tracestate = tracestateArg instanceof TraceState ? tracestateArg : TraceState.fromStringFormatString(tracestateArg);
        if (!childOf && traceparent.recorded) {
          tracestate.setValue("s", conf.transactionSampleRate);
        } else if (!childOf) {
          tracestate.setValue("s", 0);
        }
        return new _TraceContext(traceparent, tracestate, conf);
      }
      static fromString(header) {
        return TraceParent.fromString(header);
      }
      ensureParentId() {
        return this.traceparent.ensureParentId();
      }
      child() {
        const childTraceParent = this.traceparent.child();
        const childTraceContext = new _TraceContext(
          childTraceParent,
          this.tracestate,
          this._conf
        );
        return childTraceContext;
      }
      /**
       * Returns traceparent string only
       *
       * @todo legacy -- can we remove to avoid confusion?
       */
      toString() {
        return this.traceparent.toString();
      }
      toTraceStateString() {
        return this.tracestate.toW3cString();
      }
      toTraceParentString() {
        return this.traceparent.toString();
      }
      propagateTraceContextHeaders(carrier, setter) {
        if (!carrier || !setter) {
          return;
        }
        const traceparentStr = this.toTraceParentString();
        const tracestateStr = this.toTraceStateString();
        if (traceparentStr) {
          setter(carrier, "traceparent", traceparentStr);
          if (this._conf.useElasticTraceparentHeader) {
            setter(carrier, "elastic-apm-traceparent", traceparentStr);
          }
        }
        if (tracestateStr) {
          setter(carrier, "tracestate", tracestateStr);
        }
      }
      setRecorded() {
        return this.traceparent.setRecorded();
      }
      isRecorded() {
        return this.traceparent.recorded;
      }
    };
    TraceContext.FLAGS = TraceParent.FLAGS;
    module2.exports = TraceContext;
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/generic-span.js
var require_generic_span = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/generic-span.js"(exports2, module2) {
    "use strict";
    var truncate = require_unicode_byte_truncate();
    var { INTAKE_STRING_MAX_SIZE } = require_constants2();
    var constants = require_constants2();
    var { SpanCompression } = require_span_compression();
    var Timer = require_timer();
    var TraceContext = require_tracecontext();
    var { TraceParent } = require_traceparent();
    module2.exports = GenericSpan;
    function GenericSpan(agent, opts) {
      this._timer = new Timer(opts.timer, opts.startTime);
      this._context = TraceContext.startOrResume(
        opts.childOf,
        agent._conf,
        opts.tracestate
      );
      this._hasPropagatedTraceContext = false;
      this._parentSpan = null;
      if (opts.childOf instanceof GenericSpan) {
        this.setParentSpan(opts.childOf);
      }
      this._compression = new SpanCompression(agent);
      this._compression.setBufferedSpan(null);
      this._agent = agent;
      this._labels = null;
      this._ids = null;
      this._otelKind = null;
      this._otelAttributes = null;
      this._links = [];
      if (opts.links) {
        for (let i = 0; i < opts.links.length; i++) {
          const link = linkFromLinkArg(opts.links[i]);
          if (link) {
            this._links.push(link);
          }
        }
      }
      this.timestamp = this._timer.start;
      this.ended = false;
      this._duration = null;
      this._endTimestamp = null;
      this.outcome = constants.OUTCOME_UNKNOWN;
      this._isOutcomeFrozen = false;
    }
    Object.defineProperty(GenericSpan.prototype, "id", {
      enumerable: true,
      get() {
        return this._context.traceparent.id;
      }
    });
    Object.defineProperty(GenericSpan.prototype, "traceId", {
      enumerable: true,
      get() {
        return this._context.traceparent.traceId;
      }
    });
    Object.defineProperty(GenericSpan.prototype, "parentId", {
      enumerable: true,
      get() {
        return this._context.traceparent.parentId;
      }
    });
    Object.defineProperty(GenericSpan.prototype, "sampled", {
      enumerable: true,
      get() {
        return this._context.traceparent.recorded;
      }
    });
    Object.defineProperty(GenericSpan.prototype, "sampleRate", {
      enumerable: true,
      get() {
        const rate = parseFloat(this._context.tracestate.getValue("s"));
        if (rate >= 0 && rate <= 1) {
          return rate;
        }
        return null;
      }
    });
    Object.defineProperty(GenericSpan.prototype, "traceparent", {
      enumerable: true,
      get() {
        return this._context.toString();
      }
    });
    GenericSpan.prototype.duration = function() {
      if (!this.ended) {
        this._agent.logger.debug(
          "tried to call duration() on un-ended transaction/span %o",
          {
            id: this.id,
            parent: this.parentId,
            trace: this.traceId,
            name: this.name,
            type: this.type
          }
        );
        return null;
      }
      return this._duration;
    };
    GenericSpan.prototype.setLabel = function(key, value, stringify = true) {
      const makeLabelValue = () => {
        if (!stringify && (typeof value === "boolean" || typeof value === "number")) {
          return value;
        }
        return truncate(String(value), INTAKE_STRING_MAX_SIZE);
      };
      if (!key) return false;
      if (!this._labels) this._labels = {};
      var skey = key.replace(/[.*"]/g, "_");
      if (key !== skey) {
        this._agent.logger.warn("Illegal characters used in tag key: %s", key);
      }
      this._labels[skey] = makeLabelValue();
      return true;
    };
    GenericSpan.prototype.addLabels = function(labels, stringify) {
      if (!labels) return false;
      var keys = Object.keys(labels);
      for (const key of keys) {
        if (!this.setLabel(key, labels[key], stringify)) {
          return false;
        }
      }
      return true;
    };
    GenericSpan.prototype.addLinks = function(links) {
      if (links) {
        for (let i = 0; i < links.length; i++) {
          this.addLink(links[i]);
        }
      }
    };
    GenericSpan.prototype.addLink = function(linkArg) {
      const link = linkFromLinkArg(linkArg);
      if (link) {
        this._links.push(link);
      }
    };
    GenericSpan.prototype._freezeOutcome = function() {
      this._isOutcomeFrozen = true;
    };
    GenericSpan.prototype._isValidOutcome = function(outcome) {
      return outcome === constants.OUTCOME_FAILURE || outcome === constants.OUTCOME_SUCCESS || outcome === constants.OUTCOME_UNKNOWN;
    };
    GenericSpan.prototype.propagateTraceContextHeaders = function(carrier, setter) {
      this._hasPropagatedTraceContext = true;
      return this._context.propagateTraceContextHeaders(carrier, setter);
    };
    GenericSpan.prototype.setParentSpan = function(span) {
      this._parentSpan = span;
    };
    GenericSpan.prototype.getParentSpan = function(span) {
      return this._parentSpan;
    };
    GenericSpan.prototype.getBufferedSpan = function() {
      return this._compression.getBufferedSpan();
    };
    GenericSpan.prototype.setBufferedSpan = function(span) {
      return this._compression.setBufferedSpan(span);
    };
    GenericSpan.prototype.isCompositeSameKind = function() {
      return this._compression.isCompositeSameKind();
    };
    GenericSpan.prototype.isComposite = function() {
      return this._compression.isComposite();
    };
    GenericSpan.prototype.getCompositeSum = function() {
      return this._compression.composite.sum;
    };
    GenericSpan.prototype._setOTelKind = function(kind) {
      this._otelKind = kind;
    };
    GenericSpan.prototype._getOTelAttributes = function() {
      if (!this._otelAttributes) {
        this._otelAttributes = {};
      }
      return this._otelAttributes;
    };
    GenericSpan.prototype._serializeOTel = function(payload) {
      if (this._otelKind) {
        payload.otel = {
          span_kind: this._otelKind
        };
      }
      if (this._otelAttributes) {
        if (!payload.otel) {
          payload.otel = {};
        }
        payload.otel.attributes = this._otelAttributes;
      }
    };
    function linkFromLinkArg(linkArg) {
      if (!linkArg || !linkArg.context) {
        return null;
      }
      const ctx = linkArg.context;
      let traceId;
      let spanId;
      if (ctx.traceId && ctx.spanId) {
        traceId = ctx.traceId;
        spanId = ctx.spanId;
      } else if (ctx._context instanceof TraceContext) {
        traceId = ctx._context.traceparent.traceId;
        spanId = ctx._context.traceparent.id;
      } else if (ctx instanceof TraceParent) {
        traceId = ctx.traceId;
        spanId = ctx.id;
      } else if (typeof ctx === "string") {
        const traceparent = TraceParent.fromString(ctx);
        traceId = traceparent.traceId;
        spanId = traceparent.id;
      } else {
        return null;
      }
      return {
        trace_id: traceId,
        span_id: spanId
      };
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/basic-auth/index.js
var require_basic_auth = __commonJS({
  "node_modules/basic-auth/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    module2.exports = auth;
    module2.exports.parse = parse;
    var CREDENTIALS_REGEXP = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9._~+/-]+=*) *$/;
    var USER_PASS_REGEXP = /^([^:]*):(.*)$/;
    function auth(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      if (typeof req !== "object") {
        throw new TypeError("argument req is required to be an object");
      }
      var header = getAuthorization(req);
      return parse(header);
    }
    function decodeBase64(str) {
      return Buffer2.from(str, "base64").toString();
    }
    function getAuthorization(req) {
      if (!req.headers || typeof req.headers !== "object") {
        throw new TypeError("argument req is required to have headers property");
      }
      return req.headers.authorization;
    }
    function parse(string) {
      if (typeof string !== "string") {
        return void 0;
      }
      var match = CREDENTIALS_REGEXP.exec(string);
      if (!match) {
        return void 0;
      }
      var userPass = USER_PASS_REGEXP.exec(decodeBase64(match[1]));
      if (!userPass) {
        return void 0;
      }
      return new Credentials(userPass[1], userPass[2]);
    }
    function Credentials(name, pass) {
      this.name = name;
      this.pass = pass;
    }
  }
});

// node_modules/forwarded-parse/lib/error.js
var require_error = __commonJS({
  "node_modules/forwarded-parse/lib/error.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    function ParseError(message, input) {
      Error.captureStackTrace(this, ParseError);
      this.name = this.constructor.name;
      this.message = message;
      this.input = input;
    }
    util.inherits(ParseError, Error);
    module2.exports = ParseError;
  }
});

// node_modules/forwarded-parse/lib/ascii.js
var require_ascii = __commonJS({
  "node_modules/forwarded-parse/lib/ascii.js"(exports2, module2) {
    "use strict";
    function isDelimiter(code) {
      return code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code >= 58 && code <= 64 || code >= 91 && code <= 93 || code === 123 || code === 125;
    }
    function isTokenChar(code) {
      return code === 33 || code >= 35 && code <= 39 || code === 42 || code === 43 || code === 45 || code === 46 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 94 && code <= 122 || code === 124 || code === 126;
    }
    function isPrint(code) {
      return code >= 32 && code <= 126;
    }
    function isExtended(code) {
      return code >= 128 && code <= 255;
    }
    module2.exports = {
      isDelimiter,
      isTokenChar,
      isExtended,
      isPrint
    };
  }
});

// node_modules/forwarded-parse/index.js
var require_forwarded_parse = __commonJS({
  "node_modules/forwarded-parse/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ParseError = require_error();
    var ascii = require_ascii();
    var isDelimiter = ascii.isDelimiter;
    var isTokenChar = ascii.isTokenChar;
    var isExtended = ascii.isExtended;
    var isPrint = ascii.isPrint;
    function decode(str) {
      return str.replace(/\\(.)/g, "$1");
    }
    function unexpectedCharacterMessage(header, position) {
      return util.format(
        "Unexpected character '%s' at index %d",
        header.charAt(position),
        position
      );
    }
    function parse(header) {
      var mustUnescape = false;
      var isEscaping = false;
      var inQuotes = false;
      var forwarded = {};
      var output = [];
      var start = -1;
      var end = -1;
      var parameter;
      var code;
      for (var i = 0; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (parameter === void 0) {
          if (i !== 0 && start === -1 && (code === 32 || code === 9)) {
            continue;
          }
          if (isTokenChar(code)) {
            if (start === -1) start = i;
          } else if (code === 61 && start !== -1) {
            parameter = header.slice(start, i).toLowerCase();
            start = -1;
          } else {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
        } else {
          if (isEscaping && (code === 9 || isPrint(code) || isExtended(code))) {
            isEscaping = false;
          } else if (isTokenChar(code)) {
            if (end !== -1) {
              throw new ParseError(unexpectedCharacterMessage(header, i), header);
            }
            if (start === -1) start = i;
          } else if (isDelimiter(code) || isExtended(code)) {
            if (inQuotes) {
              if (code === 34) {
                inQuotes = false;
                end = i;
              } else if (code === 92) {
                if (start === -1) start = i;
                isEscaping = mustUnescape = true;
              } else if (start === -1) {
                start = i;
              }
            } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
              inQuotes = true;
            } else if ((code === 44 || code === 59) && (start !== -1 || end !== -1)) {
              if (start !== -1) {
                if (end === -1) end = i;
                forwarded[parameter] = mustUnescape ? decode(header.slice(start, end)) : header.slice(start, end);
              } else {
                forwarded[parameter] = "";
              }
              if (code === 44) {
                output.push(forwarded);
                forwarded = {};
              }
              parameter = void 0;
              start = end = -1;
            } else {
              throw new ParseError(unexpectedCharacterMessage(header, i), header);
            }
          } else if (code === 32 || code === 9) {
            if (end !== -1) continue;
            if (inQuotes) {
              if (start === -1) start = i;
            } else if (start !== -1) {
              end = i;
            } else {
              throw new ParseError(unexpectedCharacterMessage(header, i), header);
            }
          } else {
            throw new ParseError(unexpectedCharacterMessage(header, i), header);
          }
        }
      }
      if (parameter === void 0 || inQuotes || start === -1 && end === -1 || code === 32 || code === 9) {
        throw new ParseError("Unexpected end of input", header);
      }
      if (start !== -1) {
        if (end === -1) end = i;
        forwarded[parameter] = mustUnescape ? decode(header.slice(start, end)) : header.slice(start, end);
      } else {
        forwarded[parameter] = "";
      }
      output.push(forwarded);
      return output;
    }
    module2.exports = parse;
  }
});

// node_modules/original-url/index.js
var require_original_url = __commonJS({
  "node_modules/original-url/index.js"(exports2, module2) {
    "use strict";
    var parseUrl = require("url").parse;
    var parseForwarded = require_forwarded_parse();
    var net = require("net");
    module2.exports = function(req) {
      const raw = req.originalUrl || req.url;
      const url = parseUrl(raw || "");
      const secure = req.secure || req.connection && req.connection.encrypted;
      const result = { raw };
      let host;
      if (req.headers.forwarded) {
        let forwarded = getFirstHeader(req, "forwarded");
        try {
          forwarded = parseForwarded(forwarded)[0];
          host = parsePartialURL(forwarded.host);
          if (forwarded.for) {
            const conn = forwarded.for.split("]");
            const port = conn[conn.length - 1].split(":")[1];
            if (port) host.port = Number(port);
          }
          if (forwarded.proto) host.protocol = forwarded.proto + ":";
        } catch (e) {
        }
      } else if (req.headers["x-forwarded-host"]) {
        host = parsePartialURL(getFirstHeader(req, "x-forwarded-host"));
      }
      if (!host) {
        if (typeof req.headers.host === "string") {
          host = parsePartialURL(req.headers.host);
        } else {
          host = {};
        }
      }
      if (url.protocol) result.protocol = url.protocol;
      else if (req.headers["x-forwarded-proto"]) result.protocol = getFirstHeader(req, "x-forwarded-proto") + ":";
      else if (req.headers["x-forwarded-protocol"]) result.protocol = getFirstHeader(req, "x-forwarded-protocol") + ":";
      else if (req.headers["x-url-scheme"]) result.protocol = getFirstHeader(req, "x-url-scheme") + ":";
      else if (req.headers["front-end-https"]) result.protocol = getFirstHeader(req, "front-end-https") === "on" ? "https:" : "http:";
      else if (req.headers["x-forwarded-ssl"]) result.protocol = getFirstHeader(req, "x-forwarded-ssl") === "on" ? "https:" : "http:";
      else if (host.protocol) result.protocol = host.protocol;
      else if (secure) result.protocol = "https:";
      else result.protocol = "http:";
      if (url.hostname) result.hostname = url.hostname;
      else if (host.hostname) result.hostname = host.hostname;
      if (net.isIPv6(result.hostname)) result.hostname = "[" + result.hostname + "]";
      if (url.port) result.port = Number(url.port);
      else if (req.headers["x-forwarded-port"]) result.port = Number(getFirstHeader(req, "x-forwarded-port"));
      else if (host.port) result.port = Number(host.port);
      if (url.pathname) result.pathname = url.pathname;
      else if (host.pathname) result.pathname = host.pathname;
      if (url.search) result.search = url.search;
      else if (host.search) result.search = host.search;
      if (host.hash) result.hash = host.hash;
      if (result.protocol && result.hostname) {
        result.full = result.protocol + "//" + result.hostname;
        if (result.port) result.full += ":" + result.port;
        if (result.pathname) result.full += result.pathname;
        if (result.search) result.full += result.search;
        if (result.hash) result.full += result.hash;
      }
      return result;
    };
    function getFirstHeader(req, header) {
      const value = req.headers[header];
      return (Array.isArray(value) ? value[0] : value).split(", ")[0];
    }
    function parsePartialURL(url) {
      const containsProtocol = url.indexOf("://") !== -1;
      const result = parseUrl(containsProtocol ? url : "invalid://" + url);
      if (!containsProtocol) result.protocol = "";
      return result;
    }
  }
});

// node_modules/next-line/index.js
var require_next_line = __commonJS({
  "node_modules/next-line/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str) {
      var offset = 0;
      str = str.toString();
      return iterator;
      function iterator() {
        var i1 = str.indexOf("\r\n", offset);
        var i2 = str.indexOf("\n", offset);
        var i3 = str.indexOf("\r", offset);
        var indexes = [i1, i2, i3];
        var index = indexes.sort(function(a, b) {
          if (a > b) return 1;
          if (a < b) return -1;
          return 0;
        }).filter(function(index2) {
          return index2 !== -1;
        })[0];
        if (index !== void 0) return extract(index, index === i1 ? 2 : 1);
        var length = str.length;
        if (length === offset) return null;
        return extract(length, 0);
      }
      function extract(index, skip) {
        var line = str.substr(offset, index - offset);
        offset = index + skip;
        return line;
      }
    };
  }
});

// node_modules/http-headers/index.js
var require_http_headers = __commonJS({
  "node_modules/http-headers/index.js"(exports2, module2) {
    "use strict";
    var nextLine = require_next_line();
    var startLine = /^[A-Z_]+(\/\d\.\d)? /;
    var requestLine = /^([A-Z_]+) (.+) [A-Z]+\/(\d)\.(\d)$/;
    var statusLine = /^[A-Z]+\/(\d)\.(\d) (\d{3}) (.*)$/;
    module2.exports = function(data, onlyHeaders) {
      return parse(normalize(data), onlyHeaders);
    };
    function parse(str, onlyHeaders) {
      var line = firstLine(str);
      var match;
      if (onlyHeaders && startLine.test(line)) {
        return parseHeaders(str);
      } else if ((match = line.match(requestLine)) !== null) {
        return {
          method: match[1],
          url: match[2],
          version: { major: parseInt(match[3], 10), minor: parseInt(match[4], 10) },
          headers: parseHeaders(str)
        };
      } else if ((match = line.match(statusLine)) !== null) {
        return {
          version: { major: parseInt(match[1], 10), minor: parseInt(match[2], 10) },
          statusCode: parseInt(match[3], 10),
          statusMessage: match[4],
          headers: parseHeaders(str)
        };
      } else {
        return parseHeaders(str);
      }
    }
    function parseHeaders(str) {
      var headers = {};
      var next = nextLine(str);
      var line = next();
      var index, name, value;
      if (startLine.test(line)) line = next();
      while (line) {
        if (line[0] === " " || line[0] === "	") {
          value += " " + line.trim();
          line = next();
          continue;
        }
        if (name) addHeaderLine(name, value, headers);
        index = line.indexOf(":");
        name = line.substr(0, index);
        value = line.substr(index + 1).trim();
        line = next();
      }
      if (name) addHeaderLine(name, value, headers);
      return headers;
    }
    function normalize(str) {
      if (str && str._header) str = str._header;
      if (!str || typeof str.toString !== "function") return "";
      return str.toString().trim();
    }
    function firstLine(str) {
      var nl = str.indexOf("\r\n");
      if (nl === -1) return str;
      else return str.slice(0, nl);
    }
    function addHeaderLine(field, value, dest) {
      field = field.toLowerCase();
      switch (field) {
        // Array headers:
        case "set-cookie":
          if (dest[field] !== void 0) {
            dest[field].push(value);
          } else {
            dest[field] = [value];
          }
          break;
        // list is taken from:
        // https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp
        case "content-type":
        case "content-length":
        case "user-agent":
        case "referer":
        case "host":
        case "authorization":
        case "proxy-authorization":
        case "if-modified-since":
        case "if-unmodified-since":
        case "from":
        case "location":
        case "max-forwards":
        case "retry-after":
        case "etag":
        case "last-modified":
        case "server":
        case "age":
        case "expires":
          if (dest[field] === void 0) dest[field] = value;
          break;
        default:
          if (typeof dest[field] === "string") {
            dest[field] += ", " + value;
          } else {
            dest[field] = value;
          }
      }
    }
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports2) {
    "use strict";
    exports2.parse = parse;
    exports2.serialize = serialize;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
    module2.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/elastic-apm-node/lib/filters/sanitize-field-names.js
var require_sanitize_field_names = __commonJS({
  "node_modules/elastic-apm-node/lib/filters/sanitize-field-names.js"(exports2, module2) {
    "use strict";
    var querystring = require("querystring");
    var HEADER_FORM_URLENCODED = "application/x-www-form-urlencoded";
    var REDACTED = require_constants2().REDACTED;
    function redactKeysFromPostedFormVariables(body, requestHeaders, regexes) {
      if (HEADER_FORM_URLENCODED !== requestHeaders["content-type"]) {
        return body;
      }
      if (body !== null && !Buffer.isBuffer(body) && typeof body === "object") {
        return redactKeysFromObject(body, regexes);
      }
      if (typeof body === "string") {
        const objBody = redactKeysFromObject(querystring.parse(body), regexes);
        return querystring.stringify(objBody);
      }
      return body;
    }
    function redactKeysFromObject(obj, regexes, redactedStr = REDACTED) {
      if (!obj || !Array.isArray(regexes)) {
        return obj;
      }
      const result = {};
      for (const key of Object.keys(obj)) {
        const shouldRedact = regexes.some((regex) => regex.test(key));
        result[key] = shouldRedact ? redactedStr : obj[key];
      }
      return result;
    }
    module2.exports = {
      redactKeysFromObject,
      redactKeysFromPostedFormVariables
    };
  }
});

// node_modules/elastic-apm-node/lib/parsers.js
var require_parsers = __commonJS({
  "node_modules/elastic-apm-node/lib/parsers.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var basicAuth = require_basic_auth();
    var getUrlFromRequest = require_original_url();
    var parseHttpHeadersFromReqOrRes = require_http_headers();
    var cookie = require_cookie();
    var stringify = require_fast_safe_stringify();
    var REDACTED = require_constants2().REDACTED;
    var {
      redactKeysFromObject,
      redactKeysFromPostedFormVariables
    } = require_sanitize_field_names();
    var COOKIE_VAL_REDACTED = "REDACTED";
    function getContextFromRequest(req, conf, type) {
      var captureBody = conf.captureBody === type || conf.captureBody === "all";
      var context2 = {
        http_version: req.httpVersion,
        method: req.method,
        url: getUrlFromRequest(req),
        headers: void 0
      };
      if (req.socket && req.socket.remoteAddress) {
        context2.socket = {
          remote_address: req.socket.remoteAddress
        };
      }
      if (conf.captureHeaders) {
        context2.headers = redactKeysFromObject(
          req.headers,
          conf.sanitizeFieldNamesRegExp
        );
        if (context2.headers.cookie && context2.headers.cookie !== REDACTED) {
          let cookies = cookie.parse(req.headers.cookie);
          cookies = redactKeysFromObject(
            cookies,
            conf.sanitizeFieldNamesRegExp,
            COOKIE_VAL_REDACTED
          );
          try {
            context2.headers.cookie = Object.keys(cookies).map((k) => cookie.serialize(k, cookies[k])).join("; ");
          } catch (_err) {
            context2.headers.cookie = REDACTED;
          }
        }
      }
      var contentLength = parseInt(req.headers["content-length"], 10);
      var transferEncoding = req.headers["transfer-encoding"];
      var chunked = typeof transferEncoding === "string" && transferEncoding.toLowerCase() === "chunked";
      var body = req.json || req.body || req.payload;
      var haveBody = body && (chunked || contentLength > 0);
      if (haveBody) {
        if (!captureBody) {
          context2.body = "[REDACTED]";
        } else if (Buffer.isBuffer(body)) {
          context2.body = "<Buffer>";
        } else {
          if (typeof body === "string" && req.bodyIsBase64Encoded === true) {
            body = Buffer.from(body, "base64").toString("utf8");
          }
          body = redactKeysFromPostedFormVariables(
            body,
            req.headers,
            conf.sanitizeFieldNamesRegExp
          );
          if (typeof body !== "string") {
            body = tryJsonStringify(body) || stringify(body);
          }
          context2.body = body;
        }
      }
      if (context2.url && context2.url.port) {
        context2.url.port = String(context2.url.port);
      }
      return context2;
    }
    function getContextFromResponse(res, conf, isError) {
      var context2 = {
        status_code: res.statusCode,
        headers: void 0
      };
      if (conf.captureHeaders) {
        context2.headers = res.headers || parseHttpHeadersFromReqOrRes(res, true);
        context2.headers = redactKeysFromObject(
          context2.headers,
          conf.sanitizeFieldNamesRegExp
        );
      }
      if (isError) {
        context2.headers_sent = res.headersSent;
        if (typeof res.finished === "boolean") {
          context2.finished = res.finished;
        } else {
          context2.finished = res.writableEnded;
        }
      }
      return context2;
    }
    function getUserContextFromRequest(req) {
      var user = req.user || basicAuth(req) || req.session;
      if (!user) {
        return;
      }
      var context2 = {};
      if (typeof user.id === "string" || typeof user.id === "number") {
        context2.id = user.id;
      } else if (typeof user._id === "string" || typeof user._id === "number") {
        context2.id = user._id;
      }
      if (typeof user.username === "string") {
        context2.username = user.username;
      } else if (typeof user.name === "string") {
        context2.username = user.name;
      }
      if (typeof user.email === "string") {
        context2.email = user.email;
      }
      return context2;
    }
    function parseUrl(urlStr) {
      return new url.URL(urlStr, "relative:///");
    }
    function tryJsonStringify(obj) {
      try {
        return JSON.stringify(obj);
      } catch (e) {
      }
    }
    module2.exports = {
      getContextFromRequest,
      getContextFromResponse,
      getUserContextFromRequest,
      parseUrl
    };
  }
});

// node_modules/async-value/index.js
var require_async_value = __commonJS({
  "node_modules/async-value/index.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    module2.exports = class AsyncValue {
      constructor(value) {
        this.value = null;
        this.callbacks = [];
        if (value !== null && value !== void 0) {
          this.set(value);
        }
      }
      get(callback) {
        assert(typeof callback === "function", "callback must be a function");
        if (this.value !== null) {
          callback(this.value);
        } else {
          this.callbacks.push(callback);
        }
      }
      set(value) {
        assert(this.value === null, "value can only be set once");
        if (value instanceof AsyncValue) {
          value.send(this);
          return;
        }
        for (let callback of this.callbacks) {
          callback(value);
        }
        this.callbacks = null;
        this.value = value;
      }
      send(target) {
        assert(target instanceof AsyncValue, "send target must be an async value");
        this.get(target.set.bind(target));
      }
    };
  }
});

// node_modules/async-value-promise/index.js
var require_async_value_promise = __commonJS({
  "node_modules/async-value-promise/index.js"(exports2, module2) {
    "use strict";
    var AsyncValue = require_async_value();
    var assert = require("assert");
    function isDefined(thing) {
      return thing !== null & thing !== void 0;
    }
    module2.exports = class AsyncValuePromise {
      constructor(value, error) {
        this.value = new AsyncValue();
        this.error = new AsyncValue();
        if (isDefined(error)) {
          this.reject(error);
        } else if (isDefined(value)) {
          this.resolve(value);
        }
      }
      then(pass, fail) {
        const promise = new AsyncValuePromise();
        if (this.value) {
          if (!pass) {
            this.value.send(promise.value);
          } else {
            this.value.get((value) => {
              promise.resolve(pass(value));
            });
          }
        }
        if (this.error) {
          if (!fail) {
            this.error.send(promise.error);
          } else {
            this.error.get((error) => {
              try {
                promise.resolve(fail(error));
              } catch (err) {
                promise.reject(err);
              }
            });
          }
        }
        return promise;
      }
      resolve(value) {
        assert(this.value, "already rejected");
        if (value instanceof AsyncValuePromise) {
          value.value.send(this.value);
          if (this.error) {
            value.error.send(this.error);
          }
        } else {
          this.value.set(value);
          this.error = null;
        }
      }
      reject(error) {
        assert(this.error, "already resolved");
        if (error instanceof AsyncValuePromise) {
          error.error.send(this.error);
          if (this.value) {
            error.value.send(this.value);
          }
        } else {
          this.error.set(error);
          this.value = null;
        }
      }
      catch(fail) {
        return this.then(null, fail);
      }
      static resolve(value) {
        return new AsyncValuePromise(value);
      }
      static reject(error) {
        return new AsyncValuePromise(null, error);
      }
      static all(promises) {
        const promise = new AsyncValuePromise();
        const count = promises.length;
        const results = new Array(count);
        let remaining = count;
        let failed = false;
        function fail(error) {
          if (!failed) {
            promise.reject(error);
            failed = true;
          }
        }
        if (count === 0) {
          promise.resolve([]);
        } else {
          for (let i = 0; i < count; i++) {
            promises[i].then((value) => {
              if (failed) return;
              results[i] = value;
              if (--remaining === 0) {
                promise.resolve(results);
              }
            }).catch(fail);
          }
        }
        return promise;
      }
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/span.js
var require_span = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/span.js"(exports2, module2) {
    "use strict";
    var { executionAsyncId } = require("async_hooks");
    var { URL: URL2 } = require("url");
    var util = require("util");
    var Value = require_async_value_promise();
    var constants = require_constants2();
    var GenericSpan = require_generic_span();
    var { SpanIds } = require_ids();
    var { gatherStackTrace } = require_stacktraces();
    var TEST = process.env.ELASTIC_APM_TEST;
    module2.exports = Span;
    util.inherits(Span, GenericSpan);
    function Span(transaction, ...args) {
      const opts = typeof args[args.length - 1] === "object" ? args.pop() || {} : {};
      const [name, ...tsaArgs] = args;
      if (opts.timer) {
        delete opts.timer;
      }
      if (!opts.childOf) {
        const defaultChildOf = transaction._agent._instrumentation.currSpan() || transaction;
        opts.childOf = defaultChildOf;
        opts.timer = defaultChildOf._timer;
      } else if (opts.childOf._timer) {
        opts.timer = opts.childOf._timer;
      }
      this._exitSpan = !!opts.exitSpan;
      this.discardable = this._exitSpan;
      delete opts.exitSpan;
      this.type = null;
      this.subtype = null;
      this.action = null;
      this.setType(...tsaArgs);
      GenericSpan.call(this, transaction._agent, opts);
      this._db = null;
      this._http = null;
      this._destination = null;
      this._serviceTarget = null;
      this._excludeServiceTarget = false;
      this._message = null;
      this._stackObj = null;
      this._capturedStackTrace = null;
      this.sync = true;
      this._startXid = executionAsyncId();
      this.transaction = transaction;
      this.name = name || "unnamed";
      if (this._agent._conf.spanStackTraceMinDuration >= 0) {
        this._recordStackTrace();
      }
      this._agent.logger.debug("start span %o", {
        span: this.id,
        parent: this.parentId,
        trace: this.traceId,
        name: this.name,
        type: this.type,
        subtype: this.subtype,
        action: this.action
      });
    }
    Object.defineProperty(Span.prototype, "ids", {
      get() {
        return this._ids === null ? this._ids = new SpanIds(this) : this._ids;
      }
    });
    Span.prototype.setType = function(type = null, subtype = null, action = null) {
      this.type = type || constants.DEFAULT_SPAN_TYPE;
      this.subtype = subtype;
      this.action = action;
    };
    Span.prototype.toString = function() {
      return `Span(${this.id}, '${this.name}'${this.ended ? ", ended" : ""})`;
    };
    Span.prototype.customStackTrace = function(stackObj) {
      this._agent.logger.debug("applying custom stack trace to span %o", {
        span: this.id,
        parent: this.parentId,
        trace: this.traceId
      });
      this._recordStackTrace(stackObj);
    };
    Span.prototype.end = function(endTime) {
      if (this.ended) {
        this._agent.logger.debug(
          "tried to call span.end() on already ended span %o",
          {
            span: this.id,
            parent: this.parentId,
            trace: this.traceId,
            name: this.name,
            type: this.type,
            subtype: this.subtype,
            action: this.action
          }
        );
        return;
      }
      this._timer.end(endTime);
      this._endTimestamp = this._timer.endTimestamp;
      this._duration = this._timer.duration;
      if (executionAsyncId() !== this._startXid) {
        this.sync = false;
      }
      this._setOutcomeFromSpanEnd();
      this._inferServiceTargetAndDestinationService();
      this.ended = true;
      this._agent.logger.debug("ended span %o", {
        span: this.id,
        parent: this.parentId,
        trace: this.traceId,
        name: this.name,
        type: this.type,
        subtype: this.subtype,
        action: this.action
      });
      if (this._capturedStackTrace !== null && this._agent._conf.spanStackTraceMinDuration >= 0 && this._duration / 1e3 >= this._agent._conf.spanStackTraceMinDuration) {
        this._stackObj = new Value();
        var self2 = this;
        gatherStackTrace(
          this._agent.logger,
          this._capturedStackTrace,
          this._agent._conf.sourceLinesSpanAppFrames,
          this._agent._conf.sourceLinesSpanLibraryFrames,
          TEST ? null : filterCallSite,
          function(_err, stacktrace) {
            self2._stackObj.resolve(stacktrace);
          }
        );
      }
      this._agent._instrumentation.addEndedSpan(this);
      this.transaction._captureBreakdown(this);
    };
    Span.prototype._inferServiceTargetAndDestinationService = function() {
      if (this._excludeServiceTarget || !this._exitSpan) {
        this._serviceTarget = null;
      } else {
        if (!this._serviceTarget) {
          this._serviceTarget = {};
        }
        if (!("type" in this._serviceTarget)) {
          this._serviceTarget.type = this.subtype || this.type || constants.DEFAULT_SPAN_TYPE;
        }
        if (!("name" in this._serviceTarget)) {
          if (this._db) {
            if (this._db.instance) {
              this._serviceTarget.name = this._db.instance;
            }
          } else if (this._message) {
            if (this._message.queue && this._message.queue.name) {
              this._serviceTarget.name = this._message.queue.name;
            }
          } else if (this._http && this._http.url) {
            try {
              const defaultPorts = { "https:": "443", "http:": "80" };
              const url = new URL2(this._http.url);
              if (!url.port && defaultPorts[url.protocol]) {
                this._serviceTarget.name = `${url.host}:${defaultPorts[url.protocol]}`;
              } else {
                this._serviceTarget.name = url.host;
              }
            } catch (invalidUrlErr) {
              this._agent.logger.debug(
                'cannot set "service.target.name": %s (ignoring)',
                invalidUrlErr
              );
            }
          }
        }
        if (!this._destination) {
          this._destination = {};
        }
        if (!this._destination.service) {
          this._destination.service = {};
        }
        this._destination.service.type = "";
        this._destination.service.name = "";
        if (!this._destination.service.resource) {
          if (!this._serviceTarget.name) {
            this._destination.service.resource = this._serviceTarget.type;
          } else if (!this._serviceTarget.type) {
            this._destination.service.resource = this._serviceTarget.name;
          } else if (this.type === "external") {
            this._destination.service.resource = this._serviceTarget.name;
          } else {
            this._destination.service.resource = `${this._serviceTarget.type}/${this._serviceTarget.name}`;
          }
        }
      }
    };
    Span.prototype.setDbContext = function(context2) {
      if (!context2) return;
      this._db = Object.assign(this._db || {}, context2);
    };
    Span.prototype.setHttpContext = function(context2) {
      if (!context2) return;
      this._http = Object.assign(this._http || {}, context2);
    };
    Span.prototype.setDestinationContext = function(destCtx) {
      process.emitWarning(
        "<span>.setDestinationContext() was never a public API and will be removed, use <span>.setServiceTarget().",
        "DeprecationWarning",
        "ELASTIC_APM_SET_DESTINATION_CONTEXT"
      );
      if (destCtx.service && destCtx.service.resource) {
        this.setServiceTarget("", destCtx.service.resource);
      }
      const destCtxWithoutService = Object.assign({}, destCtx);
      delete destCtxWithoutService.service;
      this._setDestinationContext(destCtxWithoutService);
    };
    Span.prototype._setDestinationContext = function(destCtx) {
      this._destination = Object.assign(this._destination || {}, destCtx);
    };
    Span.prototype.setServiceTarget = function(type, name) {
      if (!type && !name) {
        this._excludeServiceTarget = true;
        this._serviceTarget = null;
        return;
      }
      if (typeof type === "string") {
        this._excludeServiceTarget = false;
        if (this._serviceTarget === null) {
          this._serviceTarget = { type };
        } else {
          this._serviceTarget.type = type;
        }
      } else if (type != null) {
        this._agent.logger.warn(
          '"type" argument to Span#setServiceTarget must be of type "string", got type "%s": ignoring',
          typeof type
        );
      }
      if (typeof name === "string") {
        this._excludeServiceTarget = false;
        if (this._serviceTarget === null) {
          this._serviceTarget = { name };
        } else {
          this._serviceTarget.name = name;
        }
      } else if (name != null) {
        this._agent.logger.warn(
          '"name" argument to Span#setServiceTarget must be of type "string", got type "%s": ignoring',
          typeof name
        );
      }
    };
    Span.prototype.setMessageContext = function(context2) {
      this._message = Object.assign(this._message || {}, context2);
    };
    Span.prototype.setOutcome = function(outcome) {
      if (!this._isValidOutcome(outcome)) {
        this._agent.logger.trace(
          "Unknown outcome [%s] seen in Span.setOutcome, ignoring",
          outcome
        );
        return;
      }
      if (this.ended) {
        this._agent.logger.debug(
          "tried to call Span.setOutcome() on already ended span %o",
          {
            span: this.id,
            parent: this.parentId,
            trace: this.traceId,
            name: this.name,
            type: this.type,
            subtype: this.subtype,
            action: this.action
          }
        );
        return;
      }
      this._freezeOutcome();
      this._setOutcome(outcome);
    };
    Span.prototype._setOutcomeFromErrorCapture = function(outcome) {
      if (this._isOutcomeFrozen) {
        return;
      }
      this._setOutcome(outcome);
    };
    Span.prototype._setOutcomeFromHttpStatusCode = function(statusCode) {
      if (this._isOutcomeFrozen) {
        return;
      }
      if (typeof statusCode !== "undefined") {
        if (statusCode >= 400) {
          this._setOutcome(constants.OUTCOME_FAILURE);
        } else {
          this._setOutcome(constants.OUTCOME_SUCCESS);
        }
      }
      this._freezeOutcome();
    };
    Span.prototype._setOutcomeFromSpanEnd = function() {
      if (this.outcome === constants.OUTCOME_UNKNOWN && !this._isOutcomeFrozen) {
        this._setOutcome(constants.OUTCOME_SUCCESS);
      }
    };
    Span.prototype._setOutcome = function(outcome) {
      this.outcome = outcome;
      if (outcome !== constants.OUTCOME_SUCCESS) {
        this.discardable = false;
      }
    };
    Span.prototype._recordStackTrace = function(obj) {
      if (!obj) {
        obj = {};
        Error.captureStackTrace(obj, Span);
      }
      this._capturedStackTrace = obj;
    };
    Span.prototype._encode = function(cb) {
      var self2 = this;
      if (!this.ended) {
        return cb(new Error("cannot encode un-ended span"));
      }
      const payload = {
        id: self2.id,
        transaction_id: self2.transaction.id,
        parent_id: self2.parentId,
        trace_id: self2.traceId,
        name: self2.name,
        type: self2.type || constants.DEFAULT_SPAN_TYPE,
        subtype: self2.subtype,
        action: self2.action,
        timestamp: self2.timestamp,
        duration: self2._duration,
        context: void 0,
        stacktrace: void 0,
        sync: self2.sync,
        outcome: self2.outcome
      };
      const sampleRate = self2.sampleRate;
      if (sampleRate !== null) {
        payload.sample_rate = sampleRate;
      }
      let haveContext = false;
      const context2 = {};
      if (self2._serviceTarget) {
        context2.service = { target: self2._serviceTarget };
        haveContext = true;
      }
      if (self2._destination) {
        context2.destination = self2._destination;
        haveContext = true;
      }
      if (self2._db) {
        context2.db = self2._db;
        haveContext = true;
      }
      if (self2._message) {
        context2.message = self2._message;
        haveContext = true;
      }
      if (self2._http) {
        context2.http = self2._http;
        haveContext = true;
      }
      if (self2._labels) {
        context2.tags = self2._labels;
        haveContext = true;
      }
      if (haveContext) {
        payload.context = context2;
      }
      if (self2.isComposite()) {
        payload.composite = self2._compression.encode();
        payload.timestamp = self2._compression.timestamp;
        payload.duration = self2._compression.duration;
      }
      this._serializeOTel(payload);
      if (this._links.length > 0) {
        payload.links = this._links;
      }
      if (this._stackObj) {
        this._stackObj.then(
          (value) => done(null, value),
          (error) => done(error)
        );
      } else {
        process.nextTick(done);
      }
      function done(err, frames) {
        if (err) {
          self2._agent.logger.debug("could not capture stack trace for span %o", {
            span: self2.id,
            parent: self2.parentId,
            trace: self2.traceId,
            name: self2.name,
            type: self2.type,
            subtype: self2.subtype,
            action: self2.action,
            err: err.message
          });
        } else if (frames) {
          payload.stacktrace = frames;
        }
        self2._db = null;
        self2._http = null;
        self2._message = null;
        self2._capturedStackTrace = null;
        self2._timer = null;
        self2._labels = null;
        cb(null, payload);
      }
    };
    Span.prototype.isCompressionEligible = function() {
      if (!this.getParentSpan()) {
        return false;
      }
      if (this.outcome !== constants.OUTCOME_UNKNOWN && this.outcome !== constants.OUTCOME_SUCCESS) {
        return false;
      }
      if (!this._exitSpan) {
        return false;
      }
      if (this._hasPropagatedTraceContext) {
        return false;
      }
      return true;
    };
    Span.prototype.tryToCompress = function(spanToCompress) {
      return this._compression.tryToCompress(this, spanToCompress);
    };
    Span.prototype.isRecorded = function() {
      return this._context.isRecorded();
    };
    Span.prototype.setRecorded = function(value) {
      return this._context.setRecorded(value);
    };
    Span.prototype.propagateTraceContextHeaders = function(carrier, setter) {
      this.discardable = false;
      return GenericSpan.prototype.propagateTraceContextHeaders.call(
        this,
        carrier,
        setter
      );
    };
    function filterCallSite(callsite) {
      var filename = callsite.getFileName();
      return filename ? filename.indexOf("/node_modules/elastic-apm-node/") === -1 : true;
    }
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/transaction.js
var require_transaction = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/transaction.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ObjectIdentityMap = require_object_identity_map();
    var constants = require_constants2();
    var { DroppedSpansStats } = require_dropped_spans_stats();
    var getPathFromRequest = require_express_utils().getPathFromRequest;
    var GenericSpan = require_generic_span();
    var parsers = require_parsers();
    var Span = require_span();
    var symbols = require_symbols();
    var {
      TRACE_CONTINUATION_STRATEGY_CONTINUE,
      TRACE_CONTINUATION_STRATEGY_RESTART,
      TRACE_CONTINUATION_STRATEGY_RESTART_EXTERNAL
    } = require_constants2();
    var { TransactionIds } = require_ids();
    var TraceState = require_tracestate();
    module2.exports = Transaction;
    util.inherits(Transaction, GenericSpan);
    function Transaction(agent, name, ...args) {
      const opts = typeof args[args.length - 1] === "object" ? args.pop() || {} : {};
      if (opts.timer) {
        delete opts.timer;
      }
      if (opts.tracestate) {
        opts.tracestate = TraceState.fromStringFormatString(opts.tracestate);
      }
      if (opts.childOf) {
        let traceContinuationStrategy = agent._conf.traceContinuationStrategy;
        if (traceContinuationStrategy === TRACE_CONTINUATION_STRATEGY_RESTART_EXTERNAL) {
          traceContinuationStrategy = TRACE_CONTINUATION_STRATEGY_RESTART;
          if (opts.tracestate && opts.tracestate.toMap().has("es")) {
            traceContinuationStrategy = TRACE_CONTINUATION_STRATEGY_CONTINUE;
          }
        }
        if (traceContinuationStrategy === TRACE_CONTINUATION_STRATEGY_RESTART) {
          if (!opts.links || !Array.isArray(opts.links)) {
            opts.links = [];
          }
          opts.links.push({ context: opts.childOf });
          delete opts.childOf;
          delete opts.tracestate;
        }
      }
      this.type = null;
      this.setType(...args);
      GenericSpan.call(this, agent, opts);
      const verb = this.parentId ? "continue" : "start";
      agent.logger.debug("%s trace %o", verb, {
        trans: this.id,
        parent: this.parentId,
        trace: this.traceId,
        name: this.name,
        type: this.type
      });
      this._defaultName = name || "";
      this._customName = "";
      this._user = null;
      this._custom = null;
      this._result = constants.RESULT_SUCCESS;
      this._builtSpans = 0;
      this._droppedSpans = 0;
      this._breakdownTimings = new ObjectIdentityMap();
      this._faas = void 0;
      this._service = void 0;
      this._message = void 0;
      this._cloud = void 0;
      this._droppedSpansStats = new DroppedSpansStats();
      this.outcome = constants.OUTCOME_UNKNOWN;
    }
    Object.defineProperty(Transaction.prototype, "name", {
      configurable: true,
      enumerable: true,
      get() {
        return this._customName || this._defaultName || (this.req ? this.req.method + " unknown route (unnamed)" : "unnamed");
      },
      set(name) {
        if (this.ended) {
          this._agent.logger.debug(
            "tried to set transaction.name on already ended transaction %o",
            { trans: this.id, parent: this.parentId, trace: this.traceId }
          );
          return;
        }
        this._agent.logger.debug("setting transaction name %o", {
          trans: this.id,
          parent: this.parentId,
          trace: this.traceId,
          name
        });
        this._customName = name;
      }
    });
    Object.defineProperty(Transaction.prototype, "result", {
      configurable: true,
      enumerable: true,
      get() {
        return this._result;
      },
      set(result) {
        if (this.ended) {
          this._agent.logger.debug(
            "tried to set transaction.result on already ended transaction %o",
            { trans: this.id, parent: this.parentId, trace: this.traceId }
          );
          return;
        }
        this._agent.logger.debug("setting transaction result %o", {
          trans: this.id,
          parent: this.parentId,
          trace: this.traceId,
          result
        });
        this._result = result;
      }
    });
    Object.defineProperty(Transaction.prototype, "ids", {
      get() {
        return this._ids === null ? this._ids = new TransactionIds(this) : this._ids;
      }
    });
    Transaction.prototype.setType = function(type = null) {
      this.type = type || constants.DEFAULT_SPAN_TYPE;
    };
    Transaction.prototype.toString = function() {
      return `Transaction(${this.id}, '${this.name}'${this.ended ? ", ended" : ""})`;
    };
    Transaction.prototype.setUserContext = function(context2) {
      if (!context2) return;
      this._user = Object.assign(this._user || {}, context2);
    };
    Transaction.prototype.setServiceContext = function(serviceContext) {
      if (!serviceContext) return;
      this._service = Object.assign(this._service || {}, serviceContext);
    };
    Transaction.prototype.setMessageContext = function(messageContext) {
      if (!messageContext) return;
      this._message = Object.assign(this._message || {}, messageContext);
    };
    Transaction.prototype.setFaas = function(faasFields) {
      if (!faasFields) return;
      this._faas = Object.assign(this._faas || {}, faasFields);
    };
    Transaction.prototype.setCustomContext = function(context2) {
      if (!context2) return;
      this._custom = Object.assign(this._custom || {}, context2);
    };
    Transaction.prototype.setCloudContext = function(cloudContext) {
      if (!cloudContext) return;
      this._cloud = Object.assign(this._cloud || {}, cloudContext);
    };
    Transaction.prototype.startSpan = function(...args) {
      const span = this.createSpan(...args);
      if (span) {
        this._agent._instrumentation.supersedeWithSpanRunContext(span);
      }
      return span;
    };
    Transaction.prototype.createSpan = function(...args) {
      if (!this.sampled) {
        return null;
      }
      const opts = typeof args[args.length - 1] === "object" ? args.pop() || {} : {};
      const [_name, type, subtype] = args;
      opts.childOf = opts.childOf || this._agent._instrumentation.currSpan() || this;
      const childOf = opts.childOf;
      if (childOf instanceof Span && childOf._exitSpan && !(childOf.type === type && childOf.subtype === subtype)) {
        this._agent.logger.trace(
          { exitSpanId: childOf.id, newSpanArgs: args },
          "createSpan: drop child span of exit span"
        );
        return null;
      }
      const span = new Span(this, ...args, opts);
      if (this._builtSpans >= this._agent._conf.transactionMaxSpans) {
        this._droppedSpans++;
        span.setRecorded(false);
      }
      this._builtSpans++;
      return span;
    };
    Transaction.prototype.toJSON = function() {
      var payload = {
        id: this.id,
        trace_id: this.traceId,
        parent_id: this.parentId,
        name: this.name,
        type: this.type || constants.DEFAULT_SPAN_TYPE,
        duration: this._duration,
        timestamp: this.timestamp,
        result: String(this.result),
        sampled: this.sampled,
        context: void 0,
        span_count: {
          started: this._builtSpans - this._droppedSpans
        },
        outcome: this.outcome,
        faas: this._faas
      };
      if (this.sampled) {
        payload.context = {
          user: Object.assign(
            {},
            this.req && parsers.getUserContextFromRequest(this.req),
            this._user
          ),
          tags: this._labels || {},
          custom: this._custom || {},
          service: this._service || {},
          cloud: this._cloud || {},
          message: this._message || {}
        };
        if (this._droppedSpans > 0) {
          payload.span_count.dropped = this._droppedSpans;
        }
        var conf = this._agent._conf;
        if (this.req) {
          payload.context.request = parsers.getContextFromRequest(
            this.req,
            conf,
            "transactions"
          );
        }
        if (this.res) {
          payload.context.response = parsers.getContextFromResponse(this.res, conf);
        }
      }
      const sampleRate = this.sampleRate;
      if (sampleRate !== null) {
        payload.sample_rate = sampleRate;
      }
      this._serializeOTel(payload);
      if (this._links.length > 0) {
        payload.links = this._links;
      }
      if (this._droppedSpansStats.size() > 0) {
        payload.dropped_spans_stats = this._droppedSpansStats.encode();
      }
      return payload;
    };
    Transaction.prototype._encode = function() {
      if (!this.ended) {
        this._agent.logger.error("cannot encode un-ended transaction: %o", {
          trans: this.id,
          parent: this.parentId,
          trace: this.traceId
        });
        return null;
      }
      return this.toJSON();
    };
    Transaction.prototype.setDefaultName = function(name) {
      this._agent.logger.debug("setting default transaction name: %s %o", name, {
        trans: this.id,
        parent: this.parentId,
        trace: this.traceId
      });
      this._defaultName = name;
    };
    Transaction.prototype.setDefaultNameFromRequest = function() {
      var req = this.req;
      var path = getPathFromRequest(
        req,
        false,
        this._agent._conf.usePathAsTransactionName
      );
      if (!path) {
        this._agent.logger.debug("could not extract route name from request %o", {
          url: req.url,
          type: typeof path,
          null: path === null,
          // because typeof null === 'object'
          route: !!req.route,
          regex: req.route ? !!req.route.regexp : false,
          mountstack: req[symbols.expressMountStack] ? req[symbols.expressMountStack].length : false,
          trans: this.id,
          parent: this.parentId,
          trace: this.traceId
        });
        path = "unknown route";
      }
      this.setDefaultName(req.method + " " + path);
    };
    Transaction.prototype.ensureParentId = function() {
      return this._context.ensureParentId();
    };
    Transaction.prototype.end = function(result, endTime) {
      if (this.ended) {
        this._agent.logger.debug(
          "tried to call transaction.end() on already ended transaction %o",
          { trans: this.id, parent: this.parentId, trace: this.traceId }
        );
        return;
      }
      if (result !== void 0 && result !== null) {
        this.result = result;
      }
      if (!this._defaultName && this.req) this.setDefaultNameFromRequest();
      this._timer.end(endTime);
      this._duration = this._timer.duration;
      this._captureBreakdown(this);
      this.ended = true;
      this._agent._instrumentation.addEndedTransaction(this);
      this._agent.logger.debug(
        {
          trans: this.id,
          name: this.name,
          parent: this.parentId,
          trace: this.traceId,
          type: this.type,
          result: this.result,
          duration: this._duration
        },
        "ended transaction"
      );
      this._customName = this.name;
      this._defaultName = "";
      this.req = null;
      this.res = null;
      this._user = null;
      this._custom = null;
      this._breakdownTimings = null;
      this._faas = void 0;
      this._service = void 0;
      this._message = void 0;
      this._cloud = void 0;
      this._timer = null;
      this._labels = null;
    };
    Transaction.prototype.setOutcome = function(outcome) {
      if (!this._isValidOutcome(outcome)) {
        this._agent.logger.trace(
          "Unknown outcome [%s] seen in Transaction.setOutcome, ignoring",
          outcome
        );
        return;
      }
      if (this.ended) {
        this._agent.logger.debug(
          "tried to call Transaction.setOutcome() on already ended transaction %o",
          { trans: this.id, parent: this.parentId, trace: this.traceId }
        );
        return;
      }
      this._freezeOutcome();
      this.outcome = outcome;
    };
    Transaction.prototype._setOutcomeFromHttpStatusCode = function(statusCode) {
      if (this._isOutcomeFrozen) {
        return;
      }
      if (statusCode >= 500) {
        this.outcome = constants.OUTCOME_FAILURE;
      } else {
        this.outcome = constants.OUTCOME_SUCCESS;
      }
    };
    Transaction.prototype._captureBreakdown = function(span) {
      if (this.ended) {
        return;
      }
      const agent = this._agent;
      const metrics2 = agent._metrics;
      const conf = agent._conf;
      if (conf.contextPropagationOnly) {
        return;
      }
      if (this.sampled && conf.breakdownMetrics) {
        captureBreakdown(
          this,
          {
            transaction: transactionBreakdownDetails(this),
            span: spanBreakdownDetails(span)
          },
          span._timer.selfTime
        );
      }
      if (span instanceof Transaction) {
        for (const { labels, time, count } of this._breakdownTimings.values()) {
          const flattenedLabels = flattenBreakdown(labels);
          metrics2.incrementCounter("span.self_time.count", flattenedLabels, count);
          metrics2.incrementCounter("span.self_time.sum.us", flattenedLabels, time);
        }
      }
    };
    Transaction.prototype.captureDroppedSpan = function(span) {
      return this._droppedSpansStats.captureDroppedSpan(span);
    };
    function transactionBreakdownDetails({ name, type } = {}) {
      return {
        name,
        type
      };
    }
    function spanBreakdownDetails(span) {
      if (span instanceof Transaction) {
        return {
          type: "app"
        };
      }
      const { type, subtype } = span;
      return {
        type,
        subtype
      };
    }
    function captureBreakdown(transaction, labels, time) {
      const build = () => ({ labels, count: 0, time: 0 });
      const counter = transaction._breakdownTimings.ensure(labels, build);
      counter.time += time;
      counter.count++;
    }
    function flattenBreakdown(source, target = {}, prefix = "") {
      for (const [key, value] of Object.entries(source)) {
        if (typeof value === "undefined" || value === null) continue;
        if (typeof value === "object") {
          flattenBreakdown(value, target, `${prefix}${key}::`);
        } else {
          target[`${prefix}${key}`] = value;
        }
      }
      return target;
    }
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/noop-transaction.js
var require_noop_transaction = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/noop-transaction.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var NOOP_TRANSACTION_ID = "0000000000000000";
    var NOOP_TRACEID = "00000000000000000000000000000000";
    var NOOP_TRACEPARENT = "00-00000000000000000000000000000-0000000000000000-00";
    var NoopTransaction = class {
      constructor() {
        this.name = "unnamed";
        this.type = "noop";
        this.traceparent = NOOP_TRACEPARENT;
        this.result = constants.RESULT_SUCCESS;
        this.outcome = constants.OUTCOME_UNKNOWN;
        this.ids = {
          "trace.id": NOOP_TRACEID,
          "transaction.id": NOOP_TRANSACTION_ID
        };
        this.timestamp = Date.now();
        this.id = NOOP_TRANSACTION_ID;
        this.traceId = NOOP_TRACEID;
        this.sampled = false;
        this.ended = false;
      }
      // Public methods.
      setType() {
      }
      setLabel() {
        return true;
      }
      addLabels() {
        return true;
      }
      setOutcome() {
      }
      startSpan() {
        return null;
      }
      end() {
      }
      ensureParentId() {
        return NOOP_TRANSACTION_ID;
      }
      toString() {
        return `Transaction(${this.id}, '${this.name}'${this.ended ? ", ended" : ""})`;
      }
      // Non-public methods mentioned in a comment in index.d.ts.
      setUserContext() {
      }
      setCustomContext() {
      }
      setDefaultName() {
      }
      setDefaultNameFromRequest() {
      }
      toJSON() {
        return {};
      }
      duration() {
        return 0;
      }
      setFaas() {
      }
      setMessageContext() {
      }
      setServiceContext() {
      }
      setCloudContext() {
      }
      _setOutcomeFromHttpStatusCode() {
      }
    };
    module2.exports = {
      NoopTransaction
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/run-context/RunContext.js
var require_RunContext = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/run-context/RunContext.js"(exports2, module2) {
    "use strict";
    var RunContext = class {
      constructor(trans, spans, parentValues) {
        this._trans = trans || null;
        this._spans = spans || [];
        this._values = parentValues ? new Map(parentValues) : /* @__PURE__ */ new Map();
      }
      currTransaction() {
        return this._trans;
      }
      // Returns the currently active span, if any, otherwise null.
      currSpan() {
        if (this._spans.length > 0) {
          return this._spans[this._spans.length - 1];
        } else {
          return null;
        }
      }
      // Return a new RunContext for a newly active/current Transaction.
      enterTrans(trans) {
        return new this.constructor(trans, null, this._values);
      }
      // Return a new RunContext with the given span added to the top of the spans
      // stack.
      enterSpan(span) {
        const newSpans = this._spans.slice();
        newSpans.push(span);
        return new this.constructor(this._trans, newSpans, this._values);
      }
      // Return a new RunContext with the given transaction (and hence all of its
      // spans) removed.
      leaveTrans() {
        return new this.constructor(null, null, this._values);
      }
      // Return a new RunContext with the given span removed, or null if there is
      // no change (the given span isn't part of the run context).
      //
      // Typically this span is the top of stack (i.e. it is the current span).
      // However, it is possible to have out-of-order span.end() or even end a span
      // that isn't part of the current run context stack at all. (See
      // test/instrumentation/run-context/fixtures/end-non-current-spans.js for
      // examples.)
      leaveSpan(span) {
        let newRc = null;
        let newSpans;
        const lastSpan = this._spans[this._spans.length - 1];
        if (lastSpan && lastSpan.id === span.id) {
          newSpans = this._spans.slice(0, this._spans.length - 1);
          newRc = new this.constructor(this._trans, newSpans, this._values);
        } else {
          const stackIdx = this._spans.findIndex((s) => s.id === span.id);
          if (stackIdx !== -1) {
            newSpans = this._spans.slice(0, stackIdx).concat(this._spans.slice(stackIdx + 1));
            newRc = new this.constructor(this._trans, newSpans, this._values);
          }
        }
        return newRc;
      }
      // A string representation useful for debug logging.
      // For example:
      //    RunContext(Transaction(abc123, 'trans name'), [Span(def456, 'span name', ended)])
      //                                                                           ^^^^^^^-- if the span has ended
      //                           ^^^^^^                       ^^^^^^-- id
      //    ^^^^^^^^^^-- the class name, typically "RunContext", but can be overriden
      toString() {
        const bits = [];
        if (this._trans) {
          bits.push(this._trans.toString());
        }
        if (this._spans.length > 0) {
          const spanStrs = this._spans.map((s) => s.toString());
          bits.push("[" + spanStrs + "]");
        }
        return `${this.constructor.name}(${bits.join(", ")})`;
      }
      // ---- The following implements the OTel Context interface.
      // https://github.com/open-telemetry/opentelemetry-js-api/blob/v1.0.4/src/context/types.ts#L17
      getValue(key) {
        return this._values.get(key);
      }
      setValue(key, value) {
        const rc = new this.constructor(this._trans, this._spans, this._values);
        rc._values.set(key, value);
        return rc;
      }
      deleteValue(key) {
        const rc = new this.constructor(this._trans, this._spans, this._values);
        rc._values.delete(key);
        return rc;
      }
    };
    module2.exports = {
      RunContext
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/run-context/AbstractRunContextManager.js
var require_AbstractRunContextManager = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/run-context/AbstractRunContextManager.js"(exports2, module2) {
    "use strict";
    var { RunContext } = require_RunContext();
    var ADD_LISTENER_METHODS = [
      "addListener",
      "on",
      "once",
      "prependListener",
      "prependOnceListener"
    ];
    var AbstractRunContextManager = class {
      constructor(log, runContextClass = RunContext) {
        this._log = log;
        this._kListeners = Symbol("ElasticListeners");
        this._root = new runContextClass();
      }
      // Get the root run context. This is always empty (no current trans or span).
      //
      // This is the equivalent of OTel JS API's `ROOT_CONTEXT` constant. Ours
      // is not a top-level constant, because the RunContext class can be
      // overriden.
      root() {
        return this._root;
      }
      enable() {
        throw new Error("abstract method not implemented");
      }
      disable() {
        throw new Error("abstract method not implemented");
      }
      // Reset state for re-use of this context manager by tests in the same process.
      testReset() {
        this.disable();
        this.enable();
      }
      active() {
        throw new Error("abstract method not implemented");
      }
      with(runContext, fn, thisArg, ...args) {
        throw new Error("abstract method not implemented");
      }
      supersedeRunContext(runContext) {
        throw new Error("abstract method not implemented");
      }
      // The OTel ContextManager API has a single .bind() like this:
      //
      // bind (runContext, target) {
      //   if (target instanceof EventEmitter) {
      //     return this._bindEventEmitter(runContext, target)
      //   }
      //   if (typeof target === 'function') {
      //     return this._bindFunction(runContext, target)
      //   }
      //   return target
      // }
      //
      // Is there any value in this over our two separate `.bind*` methods?
      bindFn(runContext, target) {
        if (typeof target !== "function") {
          return target;
        }
        const self2 = this;
        const wrapper = function() {
          return self2.with(runContext, () => target.apply(this, arguments));
        };
        Object.defineProperty(wrapper, "length", {
          enumerable: false,
          configurable: true,
          writable: false,
          value: target.length
        });
        return wrapper;
      }
      // (This implementation is adapted from OTel's `_bindEventEmitter`.)
      bindEE(runContext, ee) {
        const map = this._getPatchMap(ee);
        if (map !== void 0) {
          return ee;
        }
        this._createPatchMap(ee);
        ADD_LISTENER_METHODS.forEach((methodName) => {
          if (ee[methodName] === void 0) return;
          ee[methodName] = this._patchAddListener(ee, ee[methodName], runContext);
        });
        if (typeof ee.removeListener === "function") {
          ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);
        }
        if (typeof ee.off === "function") {
          ee.off = this._patchRemoveListener(ee, ee.off);
        }
        if (typeof ee.removeAllListeners === "function") {
          ee.removeAllListeners = this._patchRemoveAllListeners(
            ee,
            ee.removeAllListeners
          );
        }
        return ee;
      }
      // Return true iff the given EventEmitter is already bound to a run context.
      isEEBound(ee) {
        return this._getPatchMap(ee) !== void 0;
      }
      // Patch methods that remove a given listener so that we match the "patched"
      // version of that listener (the one that propagate context).
      _patchRemoveListener(ee, original) {
        const contextManager = this;
        return function(event, listener) {
          const map = contextManager._getPatchMap(ee);
          const listeners = map && map[event];
          if (listeners === void 0) {
            return original.call(this, event, listener);
          }
          const patchedListener = listeners.get(listener);
          return original.call(this, event, patchedListener || listener);
        };
      }
      // Patch methods that remove all listeners so we remove our internal
      // references for a given event.
      _patchRemoveAllListeners(ee, original) {
        const contextManager = this;
        return function(event) {
          const map = contextManager._getPatchMap(ee);
          if (map !== void 0) {
            if (arguments.length === 0) {
              contextManager._createPatchMap(ee);
            } else if (map[event] !== void 0) {
              delete map[event];
            }
          }
          return original.apply(this, arguments);
        };
      }
      // Patch methods on an event emitter instance that can add listeners so we
      // can force them to propagate a given context.
      _patchAddListener(ee, original, runContext) {
        const contextManager = this;
        return function(event, listener) {
          let map = contextManager._getPatchMap(ee);
          if (map === void 0) {
            map = contextManager._createPatchMap(ee);
          }
          let listeners = map[event];
          if (listeners === void 0) {
            listeners = /* @__PURE__ */ new WeakMap();
            map[event] = listeners;
          }
          const patchedListener = contextManager.bindFn(runContext, listener);
          listeners.set(listener, patchedListener);
          return original.call(this, event, patchedListener);
        };
      }
      _createPatchMap(ee) {
        const map = /* @__PURE__ */ Object.create(null);
        ee[this._kListeners] = map;
        return map;
      }
      _getPatchMap(ee) {
        return ee[this._kListeners];
      }
    };
    module2.exports = {
      AbstractRunContextManager
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/run-context/BasicRunContextManager.js
var require_BasicRunContextManager = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/run-context/BasicRunContextManager.js"(exports2, module2) {
    "use strict";
    var { AbstractRunContextManager } = require_AbstractRunContextManager();
    var BasicRunContextManager = class extends AbstractRunContextManager {
      constructor(log, runContextClass) {
        super(log, runContextClass);
        this._stack = [];
      }
      // A string representation useful for debug logging. For example,
      //    BasicRunContextManager(
      //      RC(Trans(685ead, manual), [Span(9dd31c, GET httpstat.us, ended)]),
      //      RC(Trans(685ead, manual)) )
      toString() {
        return `${this.constructor.name}( ${this._stack.map((rc) => rc.toString()).join(", ")} )`;
      }
      enable() {
        return this;
      }
      disable() {
        this._stack = [];
        return this;
      }
      // Reset state for re-use of this context manager by tests in the same process.
      testReset() {
        this.disable();
        this.enable();
      }
      active() {
        return this._stack[this._stack.length - 1] || this.root();
      }
      with(runContext, fn, thisArg, ...args) {
        this._enterRunContext(runContext);
        try {
          return fn.call(thisArg, ...args);
        } finally {
          this._exitRunContext();
        }
      }
      // This public method is needed to support the semantics of
      // apm.startTransaction() and apm.startSpan() that impact the current run
      // context.
      //
      // Otherwise, all run context changes are via `.with()` -- scoped to a
      // function call -- or via the "before" async hook -- scoped to an async task.
      supersedeRunContext(runContext) {
        this._exitRunContext();
        this._enterRunContext(runContext);
      }
      _enterRunContext(runContext) {
        this._stack.push(runContext);
      }
      _exitRunContext() {
        this._stack.pop();
      }
    };
    module2.exports = {
      BasicRunContextManager
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/run-context/AsyncHooksRunContextManager.js
var require_AsyncHooksRunContextManager = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/run-context/AsyncHooksRunContextManager.js"(exports2, module2) {
    "use strict";
    var asyncHooks = require("async_hooks");
    var { BasicRunContextManager } = require_BasicRunContextManager();
    var AsyncHooksRunContextManager = class extends BasicRunContextManager {
      constructor(log, runContextClass) {
        super(log, runContextClass);
        this._runContextFromAsyncId = /* @__PURE__ */ new Map();
        this._asyncHook = asyncHooks.createHook({
          init: this._init.bind(this),
          before: this._before.bind(this),
          after: this._after.bind(this),
          destroy: this._destroy.bind(this),
          promiseResolve: this._destroy.bind(this)
        });
      }
      enable() {
        super.enable();
        this._asyncHook.enable();
        return this;
      }
      disable() {
        super.disable();
        this._asyncHook.disable();
        this._runContextFromAsyncId.clear();
        return this;
      }
      // Reset state for re-use of this context manager by tests in the same process.
      testReset() {
        this._runContextFromAsyncId.clear();
        this._stack = [];
      }
      /**
       * Init hook will be called when userland create a async context, setting the
       * context as the current one if it exist.
       * @param asyncId id of the async context
       * @param type the resource type
       */
      _init(asyncId, type, triggerAsyncId) {
        if (type === "TIMERWRAP") {
          return;
        }
        const context2 = this._stack[this._stack.length - 1];
        if (context2 !== void 0) {
          this._runContextFromAsyncId.set(asyncId, context2);
        }
      }
      /**
       * Destroy hook will be called when a given context is no longer used so we can
       * remove its attached context.
       * @param asyncId id of the async context
       */
      _destroy(asyncId) {
        this._runContextFromAsyncId.delete(asyncId);
      }
      /**
       * Before hook is called just before executing a async context.
       * @param asyncId id of the async context
       */
      _before(asyncId) {
        const context2 = this._runContextFromAsyncId.get(asyncId);
        if (context2 !== void 0) {
          this._enterRunContext(context2);
        }
      }
      /**
       * After hook is called just after completing the execution of a async context.
       */
      _after() {
        this._exitRunContext();
      }
    };
    module2.exports = {
      AsyncHooksRunContextManager
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/run-context/AsyncLocalStorageRunContextManager.js
var require_AsyncLocalStorageRunContextManager = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/run-context/AsyncLocalStorageRunContextManager.js"(exports2, module2) {
    "use strict";
    var { AsyncLocalStorage } = require("async_hooks");
    var { AbstractRunContextManager } = require_AbstractRunContextManager();
    var AsyncLocalStorageRunContextManager = class extends AbstractRunContextManager {
      constructor(log, runContextClass) {
        super(log, runContextClass);
        this._asyncLocalStorage = new AsyncLocalStorage();
      }
      // A string representation useful for debug logging. For example,
      //    AsyncLocalStorageRunContextManager( RC(Trans(685ead, manual), [Span(9dd31c, GET httpstat.us, ended)]) )
      toString() {
        return `${this.constructor.name}( ${this.active().toString()} )`;
      }
      enable() {
        return this;
      }
      disable() {
        this._asyncLocalStorage.disable();
        return this;
      }
      // Reset state for re-use of this context manager by tests in the same process.
      testReset() {
        this.disable();
        this.enable();
      }
      active() {
        const store = this._asyncLocalStorage.getStore();
        if (store == null) {
          return this.root();
        } else {
          return store;
        }
      }
      with(runContext, fn, thisArg, ...args) {
        const cb = thisArg == null ? fn : fn.bind(thisArg);
        return this._asyncLocalStorage.run(runContext, cb, ...args);
      }
      // This public method is needed to support the semantics of
      // apm.startTransaction() and apm.startSpan() that impact the current run
      // context.
      //
      // Otherwise, all run context changes are via `.with()` -- scoped to a
      // function call -- or via the "before" async hook -- scoped to an async task.
      supersedeRunContext(runContext) {
        this._asyncLocalStorage.enterWith(runContext);
      }
    };
    module2.exports = {
      AsyncLocalStorageRunContextManager
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/run-context/index.js
var require_run_context = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/run-context/index.js"(exports2, module2) {
    "use strict";
    var {
      AsyncHooksRunContextManager
    } = require_AsyncHooksRunContextManager();
    var {
      AsyncLocalStorageRunContextManager
    } = require_AsyncLocalStorageRunContextManager();
    var { BasicRunContextManager } = require_BasicRunContextManager();
    var { RunContext } = require_RunContext();
    module2.exports = {
      AsyncHooksRunContextManager,
      AsyncLocalStorageRunContextManager,
      BasicRunContextManager,
      RunContext
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/modules/undici.js
var require_undici = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/modules/undici.js"(exports2, module2) {
    "use strict";
    var diagch = null;
    try {
      diagch = require("diagnostics_channel");
    } catch (_importErr) {
    }
    var semver = require_semver2();
    var headersStrHasTraceparentRe = /^traceparent:/im;
    var isInstrumented = false;
    var spanFromReq = null;
    var chans = null;
    function contentLengthFromResponseHeaders(headers) {
      const name = "content-length";
      for (let i = 0; i < headers.length; i += 2) {
        const k = headers[i];
        if (k.length === name.length && k.toString().toLowerCase() === name) {
          const v = Number(headers[i + 1]);
          if (!isNaN(v)) {
            return v;
          } else {
            return null;
          }
        }
      }
      return null;
    }
    function uninstrumentUndici() {
      if (!isInstrumented) {
        return;
      }
      isInstrumented = false;
      spanFromReq = null;
      chans.forEach(({ chan, onMessage }) => {
        chan.unsubscribe(onMessage);
      });
      chans = null;
    }
    function instrumentUndici(agent) {
      if (isInstrumented) {
        return;
      }
      isInstrumented = true;
      const ins = agent._instrumentation;
      spanFromReq = /* @__PURE__ */ new WeakMap();
      chans = [];
      function diagchSub(name, onMessage) {
        const chan = diagch.channel(name);
        chan.subscribe(onMessage);
        chans.push({
          name,
          chan,
          onMessage
        });
      }
      diagchSub("undici:request:create", ({ request }) => {
        if (request.method === "CONNECT") {
          return;
        }
        const url = new URL(request.origin);
        const span = ins.createSpan(
          `${request.method} ${url.host}`,
          "external",
          "http",
          request.method,
          { exitSpan: true }
        );
        const parentRunContext = ins.currRunContext();
        const propSpan = span || parentRunContext.currSpan() || parentRunContext.currTransaction();
        if (propSpan) {
          let alreadyHasTp = false;
          if (Array.isArray(request.headers)) {
            for (let i = 0; i < request.headers.length; i += 2) {
              if (request.headers[i].toLowerCase() === "traceparent") {
                alreadyHasTp = true;
                break;
              }
            }
          } else if (typeof request.headers === "string") {
            alreadyHasTp = headersStrHasTraceparentRe.test(request.headers);
          }
          if (!alreadyHasTp) {
            propSpan.propagateTraceContextHeaders(
              request,
              function(req, name, value) {
                if (typeof request.addHeader === "function") {
                  req.addHeader(name, value);
                } else if (Array.isArray(request.headers)) {
                  req.headers.push(name, value);
                }
              }
            );
          }
        }
        if (span) {
          spanFromReq.set(request, span);
          span.setHttpContext({
            method: request.method,
            url: request.origin + request.path
          });
          const destContext = {
            address: url.hostname
          };
          const port = Number(url.port) || url.protocol === "https:" && 443 || url.protocol === "http:" && 80;
          if (port) {
            destContext.port = port;
          }
          span._setDestinationContext(destContext);
        }
      });
      diagchSub("undici:request:headers", ({ request, response }) => {
        const span = spanFromReq.get(request);
        if (span !== void 0) {
          const httpContext = {
            method: request.method,
            status_code: response.statusCode,
            url: request.origin + request.path
          };
          const cLen = contentLengthFromResponseHeaders(response.headers);
          if (cLen !== null) {
            httpContext.response = { encoded_body_size: cLen };
          }
          span.setHttpContext(httpContext);
          span._setOutcomeFromHttpStatusCode(response.statusCode);
        }
      });
      diagchSub("undici:request:trailers", ({ request }) => {
        const span = spanFromReq.get(request);
        if (span !== void 0) {
          span.end();
          spanFromReq.delete(request);
        }
      });
      diagchSub("undici:request:error", ({ request, error }) => {
        const span = spanFromReq.get(request);
        const errOpts = {};
        if (span !== void 0) {
          errOpts.parent = span;
        }
        agent.captureError(error, errOpts);
        if (span !== void 0) {
          span.end();
          spanFromReq.delete(request);
        }
      });
    }
    function shimUndici(undici, agent, { version, enabled }) {
      if (!enabled) {
        return undici;
      }
      if (semver.lt(version, "4.7.1")) {
        agent.logger.debug(
          "cannot instrument undici: undici version %s is not supported",
          version
        );
        return undici;
      }
      if (!diagch) {
        agent.logger.debug(
          'cannot instrument undici: there is no "diagnostics_channel" module',
          process.version
        );
        return undici;
      }
      instrumentUndici(agent);
      return undici;
    }
    module2.exports = shimUndici;
    module2.exports.instrumentUndici = instrumentUndici;
    module2.exports.uninstrumentUndici = uninstrumentUndici;
  }
});

// node_modules/elastic-apm-node/lib/propwrap.js
var require_propwrap = __commonJS({
  "node_modules/elastic-apm-node/lib/propwrap.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (const key of __getOwnPropNames2(from)) {
          if (!__hasOwnProp2.call(to, key) && key !== except) {
            __defProp2(to, key, {
              get: () => from[key],
              enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
            });
          }
        }
      }
      return to;
    };
    function wrap(obj, subpath, wrapper) {
      const parts = subpath.split(".");
      const namespaces = [obj];
      let namespace = obj;
      let key;
      let val;
      for (let i = 0; i < parts.length; i++) {
        key = parts[i];
        val = namespace[key];
        if (!val) {
          throw new TypeError(
            `cannot wrap "${subpath}": "<obj>.${parts.slice(0, i).join(".")}" is ${typeof val}`
          );
        } else if (i < parts.length - 1) {
          if (typeof val !== "object") {
            throw new TypeError(
              `cannot wrap "${subpath}": "<obj>.${parts.slice(0, i).join(".")}" is not an Object`
            );
          }
          namespace = val;
          namespaces.push(namespace);
        }
      }
      for (let i = parts.length - 1; i >= 0; i--) {
        key = parts[i];
        namespace = namespaces[i];
        if (i === parts.length - 1) {
          const orig = namespace[key];
          val = wrapper(orig);
        } else {
          val = namespaces[i + 1];
        }
        const desc = __getOwnPropDesc2(namespace, key);
        const wrappedNamespace = __defProp2({}, key, {
          value: val,
          enumerable: !desc || desc.enumerable
        });
        __copyProps2(wrappedNamespace, namespace, key);
        namespaces[i] = wrappedNamespace;
      }
      return namespaces[0];
    }
    module2.exports = {
      wrap
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/modules/_lambda-handler.js
var require_lambda_handler = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/modules/_lambda-handler.js"(exports2, module2) {
    "use strict";
    var propwrap = require_propwrap();
    function createLambdaPatcher(propPath) {
      return function lambdaHandlerPatcher(module3, agent, { enabled }) {
        if (!enabled) {
          return module3;
        }
        try {
          const newMod = propwrap.wrap(module3, propPath, (orig) => {
            return agent.lambda(orig);
          });
          return newMod;
        } catch (wrapErr) {
          agent.logger.warn("could not wrap lambda handler: %s", wrapErr);
          return module3;
        }
      };
    }
    module2.exports = {
      createLambdaPatcher
    };
  }
});

// node_modules/elastic-apm-node/lib/instrumentation/index.js
var require_instrumentation = __commonJS({
  "node_modules/elastic-apm-node/lib/instrumentation/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { Hook: RitmHook } = require_require_in_the_middle();
    var IitmHook = require_import_in_the_middle();
    var semver = require_semver2();
    var {
      CONTEXT_MANAGER_ASYNCHOOKS,
      CONTEXT_MANAGER_ASYNCLOCALSTORAGE
    } = require_constants2();
    var { Ids } = require_ids();
    var Transaction = require_transaction();
    var { NoopTransaction } = require_noop_transaction();
    var {
      AsyncHooksRunContextManager,
      AsyncLocalStorageRunContextManager
    } = require_run_context();
    var { getLambdaHandlerInfo } = require_lambda();
    var undiciInstr = require_undici();
    var azureFunctionsInstr = require_azure_functions();
    var nodeSupportsAsyncLocalStorage = semver.satisfies(
      process.versions.node,
      ">=14.5 || ^12.19.0"
    );
    var nodeHasInstrumentableFetch = typeof global.fetch === "function";
    var MODULE_PATCHERS = [
      { modPath: "@apollo/server" },
      { modPath: "@smithy/smithy-client" },
      // Instrument the base client which all AWS-SDK v3 clients extend.
      {
        modPath: "@aws-sdk/smithy-client",
        patcher: "./modules/@smithy/smithy-client.js"
      },
      { modPath: "@elastic/elasticsearch" },
      {
        modPath: "@elastic/elasticsearch-canary",
        patcher: "./modules/@elastic/elasticsearch.js"
      },
      { modPath: "@opentelemetry/api" },
      { modPath: "@opentelemetry/sdk-metrics" },
      { modPath: "@redis/client/dist/lib/client/index.js", diKey: "redis" },
      {
        modPath: "@redis/client/dist/lib/client/commands-queue.js",
        diKey: "redis"
      },
      {
        modPath: "@node-redis/client/dist/lib/client/index.js",
        patcher: "./modules/@redis/client/dist/lib/client/index.js",
        diKey: "redis"
      },
      {
        modPath: "@node-redis/client/dist/lib/client/commands-queue.js",
        patcher: "./modules/@redis/client/dist/lib/client/commands-queue.js",
        diKey: "redis"
      },
      { modPath: "apollo-server-core" },
      { modPath: "aws-sdk" },
      { modPath: "bluebird" },
      { modPath: "cassandra-driver" },
      { modPath: "elasticsearch" },
      { modPath: "express" },
      { modPath: "express-graphql" },
      { modPath: "express-queue" },
      { modPath: "fastify" },
      { modPath: "finalhandler" },
      { modPath: "generic-pool" },
      { modPath: "graphql" },
      { modPath: "handlebars" },
      { modPath: "@hapi/hapi" },
      { modPath: "http" },
      { modPath: "https" },
      { modPath: "http2" },
      { modPath: "ioredis" },
      { modPath: "jade" },
      { modPath: "kafkajs" },
      { modPath: "knex" },
      { modPath: "koa" },
      { modPath: "koa-router" },
      { modPath: "@koa/router", patcher: "./modules/koa-router.js" },
      { modPath: "memcached" },
      { modPath: "mimic-response" },
      { modPath: "mongodb-core" },
      { modPath: "mongodb" },
      {
        modPath: "mongodb/lib/cmap/connection_pool.js",
        patcher: "./modules/mongodb/lib/cmap/connection_pool.js"
      },
      { modPath: "mysql" },
      { modPath: "mysql2" },
      { modPath: "next" },
      { modPath: "next/dist/server/api-utils/node.js" },
      { modPath: "next/dist/server/dev/next-dev-server.js" },
      { modPath: "next/dist/server/next-server.js" },
      { modPath: "pg" },
      { modPath: "pug" },
      { modPath: "redis" },
      { modPath: "restify" },
      { modPath: "tedious" },
      { modPath: "undici" },
      { modPath: "ws" }
    ];
    var IITM_MODULES = {
      // This smithy-client entry isn't used for `@aws-sdk/client-*` ESM support
      // because the smithy-client is transitively `require`d by CommonJS aws-sdk
      // code. If a future aws-sdk v3 version switches to ESM imports internally,
      // then this will be relevant.
      //  '@aws-sdk/smithy-client': { instrumentImportMod: false },
      "cassandra-driver": { instrumentImportMod: false },
      express: { instrumentImportMod: false },
      fastify: { instrumentImportMod: true },
      http: { instrumentImportMod: true },
      https: { instrumentImportMod: true },
      ioredis: { instrumentImportMod: false },
      knex: { instrumentImportMod: false },
      pg: { instrumentImportMod: false }
    };
    function modNameFromModPath(modPath) {
      if (modPath.startsWith("/")) {
        return modPath;
      } else if (modPath.startsWith("@")) {
        return modPath.split("/", 2).join("/");
      } else {
        return modPath.split("/", 1)[0];
      }
    }
    function normPathSeps(s) {
      return path.sep !== "/" ? s.split(path.sep).join("/") : s;
    }
    var PatcherRegistry = class {
      constructor() {
        this.reset();
      }
      reset() {
        this._infoFromModPath = {};
      }
      /**
       * Add a patcher for the given module path.
       *
       * @param {string} modPath - Identifies a module that RITM can hook: a
       *    module name (http, @smithy/client), a module-relative path
       *    (mongodb/lib/cmap/connection_pool.js), an absolute path
       *    (/var/task/index.js; Windows paths are not supported), a sub-module
       *    (react-dom/server).
       * @param {import('../..').PatchHandler | string} patcher - A patcher function
       *    or a path to a CommonJS module that exports one as the default export.
       * @param {string} [diKey] - An optional key in the `disableInstrumentations`
       *    config var that is used to determine if this patcher is
       *    disabled. All patchers for the same modPath must share the same `diKey`.
       *    This throws if a conflicting `diKey` is given.
       *    It defaults to the `modName` (derived from the `modPath`).
       */
      add(modPath, patcher, diKey = null) {
        if (!(modPath in this._infoFromModPath)) {
          this._infoFromModPath[modPath] = {
            patchers: [patcher],
            diKey: diKey || modNameFromModPath(modPath)
          };
        } else {
          const entry = this._infoFromModPath[modPath];
          if (diKey && diKey !== entry.diKey) {
            throw new Error(
              `invalid "diKey", ${diKey}, for module "${modPath}" patcher: it conflicts with existing diKey=${entry.diKey}`
            );
          }
          entry.patchers.push(patcher);
        }
      }
      /**
       * Remove the given patcher for the given module path.
       */
      remove(modPath, patcher) {
        const entry = this._infoFromModPath[modPath];
        if (!entry) {
          return;
        }
        const idx = entry.patchers.indexOf(patcher);
        if (idx !== -1) {
          entry.patchers.splice(idx, 1);
        }
        if (entry.patchers.length === 0) {
          delete this._infoFromModPath[modPath];
        }
      }
      /**
       * Remove all patchers for the given module path.
       */
      clear(modPath) {
        delete this._infoFromModPath[modPath];
      }
      has(modPath) {
        return modPath in this._infoFromModPath;
      }
      getPatchers(modPath) {
        return this._infoFromModPath[modPath]?.patchers;
      }
      /**
       * Returns the appropriate RITM `modules` argument so that all registered
       * `modPath`s will be hooked. This assumes `{internals: true}` RITM options
       * are used.
       *
       * @returns {Array<string>}
       */
      ritmModulesArg() {
        const modules = /* @__PURE__ */ new Set();
        const hasModExt = /\.(js|cjs|mjs|json)$/;
        Object.keys(this._infoFromModPath).forEach((modPath) => {
          const modName = modNameFromModPath(modPath);
          if (modPath === modName) {
            modules.add(modPath);
          } else {
            if (hasModExt.test(modPath)) {
              modules.add(modName);
            } else {
              modules.add(modPath);
            }
          }
        });
        return Array.from(modules);
      }
      /**
       * Get the string on the `disableInstrumentations` config var that indicates
       * if this module path should be disabled.
       *
       * Typically this is the module name -- e.g. "@redis/client" -- but might be
       * a custom value -- e.g. "lambda" for a Lambda handler path.
       *
       * @returns {string | undefined}
       */
      diKey(modPath) {
        return this._infoFromModPath[modPath]?.diKey;
      }
    };
    function Instrumentation(agent) {
      this._agent = agent;
      this._disableInstrumentationsSet = null;
      this._ritmHook = null;
      this._iitmHook = null;
      this._started = false;
      this._runCtxMgr = null;
      this._log = agent.logger;
      this._patcherReg = new PatcherRegistry();
      this._cachedVerFromModBaseDir = /* @__PURE__ */ new Map();
    }
    Instrumentation.prototype.currTransaction = function() {
      if (!this._started) {
        return null;
      }
      return this._runCtxMgr.active().currTransaction();
    };
    Instrumentation.prototype.currSpan = function() {
      if (!this._started) {
        return null;
      }
      return this._runCtxMgr.active().currSpan();
    };
    Instrumentation.prototype.ids = function() {
      if (!this._started) {
        return new Ids();
      }
      const runContext = this._runCtxMgr.active();
      const currSpanOrTrans = runContext.currSpan() || runContext.currTransaction();
      if (currSpanOrTrans) {
        return currSpanOrTrans.ids;
      }
      return new Ids();
    };
    Instrumentation.prototype.addPatch = function(modules, handler) {
      if (!Array.isArray(modules)) {
        modules = [modules];
      }
      for (const modPath of modules) {
        const type = typeof handler;
        if (type !== "function" && type !== "string") {
          this._agent.logger.error("Invalid patch handler type: %s", type);
          return;
        }
        this._patcherReg.add(modPath, handler);
      }
      this._restartHooks();
    };
    Instrumentation.prototype.removePatch = function(modules, handler) {
      if (!Array.isArray(modules)) modules = [modules];
      for (const modPath of modules) {
        this._patcherReg.remove(modPath, handler);
      }
      this._restartHooks();
    };
    Instrumentation.prototype.clearPatches = function(modules) {
      if (!Array.isArray(modules)) modules = [modules];
      for (const modPath of modules) {
        this._patcherReg.clear(modPath);
      }
      this._restartHooks();
    };
    Instrumentation.prototype._maybeLoadLambdaPatcher = function() {
      let lambdaHandlerInfo = getLambdaHandlerInfo(process.env);
      if (lambdaHandlerInfo && this._patcherReg.has(lambdaHandlerInfo.modName)) {
        this._log.warn(
          'Unable to instrument Lambda handler "%s" due to name conflict with "%s", please choose a different Lambda handler name',
          process.env._HANDLER,
          lambdaHandlerInfo.modName
        );
        lambdaHandlerInfo = null;
      }
      if (lambdaHandlerInfo) {
        const { createLambdaPatcher } = require_lambda_handler();
        this._lambdaHandlerInfo = lambdaHandlerInfo;
        this._patcherReg.add(
          this._lambdaHandlerInfo.filePath,
          createLambdaPatcher(lambdaHandlerInfo.propPath),
          "lambda"
          // diKey
        );
      }
    };
    Instrumentation.prototype.start = function(runContextClass) {
      if (this._started) return;
      this._started = true;
      this._log = this._agent.logger;
      const confContextManager = this._agent._conf.contextManager;
      if (confContextManager === CONTEXT_MANAGER_ASYNCHOOKS) {
        this._runCtxMgr = new AsyncHooksRunContextManager(
          this._log,
          runContextClass
        );
      } else if (nodeSupportsAsyncLocalStorage) {
        this._runCtxMgr = new AsyncLocalStorageRunContextManager(
          this._log,
          runContextClass
        );
      } else {
        if (confContextManager === CONTEXT_MANAGER_ASYNCLOCALSTORAGE) {
          this._log.warn(
            `config includes 'contextManager="${confContextManager}"', but node ${process.version} does not support AsyncLocalStorage for run-context management: falling back to using async_hooks`
          );
        }
        this._runCtxMgr = new AsyncHooksRunContextManager(
          this._log,
          runContextClass
        );
      }
      for (let info of MODULE_PATCHERS) {
        let patcher;
        if (info.patcher) {
          patcher = path.resolve(__dirname, info.patcher);
        } else {
          patcher = path.resolve(
            __dirname,
            "modules",
            info.modPath + (info.modPath.endsWith(".js") ? "" : ".js")
          );
        }
        this._patcherReg.add(info.modPath, patcher, info.diKey);
      }
      this._maybeLoadLambdaPatcher();
      const patches = this._agent._conf.addPatch;
      if (Array.isArray(patches)) {
        for (const [modPath, patcher] of patches) {
          this._patcherReg.add(modPath, patcher);
        }
      }
      this._runCtxMgr.enable();
      this._restartHooks();
      if (nodeHasInstrumentableFetch && this._isModuleEnabled("undici")) {
        this._log.debug("instrumenting fetch");
        undiciInstr.instrumentUndici(this._agent);
      }
      if (azureFunctionsInstr.isAzureFunctionsEnvironment) {
        this._log.debug("instrumenting azure-functions");
        azureFunctionsInstr.instrument(this._agent);
      }
    };
    Instrumentation.prototype.stop = function() {
      this._started = false;
      if (this._runCtxMgr) {
        this._runCtxMgr.disable();
        this._runCtxMgr = null;
      }
      if (this._ritmHook) {
        this._ritmHook.unhook();
        this._ritmHook = null;
      }
      if (this._iitmHook) {
        this._iitmHook.unhook();
        this._iitmHook = null;
      }
      this._patcherReg.reset();
      this._lambdaHandlerInfo = null;
      if (nodeHasInstrumentableFetch) {
        undiciInstr.uninstrumentUndici();
      }
      if (azureFunctionsInstr.isAzureFunctionsEnvironment) {
        azureFunctionsInstr.uninstrument();
      }
    };
    Instrumentation.prototype.testReset = function() {
      if (this._runCtxMgr) {
        this._runCtxMgr.testReset();
      }
    };
    Instrumentation.prototype._isModuleEnabled = function(modName) {
      if (!this._disableInstrumentationsSet) {
        this._disableInstrumentationsSet = new Set(
          this._agent._conf.disableInstrumentations
        );
      }
      return this._agent._conf.instrument && !this._disableInstrumentationsSet.has(modName);
    };
    Instrumentation.prototype._restartHooks = function() {
      if (!this._started) {
        return;
      }
      if (this._ritmHook || this._iitmHook) {
        this._agent.logger.debug("removing hooks to Node.js module loader");
        if (this._ritmHook) {
          this._ritmHook.unhook();
        }
        if (this._iitmHook) {
          this._iitmHook.unhook();
        }
      }
      var self2 = this;
      this._log.debug("adding Node.js module loader hooks");
      this._ritmHook = new RitmHook(
        this._patcherReg.ritmModulesArg(),
        { internals: true },
        function(exports3, modPath, basedir) {
          let version = void 0;
          if (self2._lambdaHandlerInfo?.modName === modPath) {
            modPath = self2._lambdaHandlerInfo.filePath;
            version = process.env.AWS_LAMBDA_FUNCTION_VERSION || "";
          } else {
            modPath = normPathSeps(modPath);
          }
          if (!self2._patcherReg.has(modPath)) {
            return exports3;
          }
          if (version !== void 0) {
          } else if (!basedir) {
            version = process.versions.node;
          } else {
            version = self2._getPackageVersion(modPath, basedir);
            if (version === void 0) {
              self2._log.debug("could not patch %s module", modPath);
              return exports3;
            }
          }
          const diKey = self2._patcherReg.diKey(modPath);
          const enabled = self2._isModuleEnabled(diKey);
          return self2._patchModule(exports3, modPath, version, enabled, false);
        }
      );
      this._iitmHook = IitmHook(
        // TODO: Eventually derive this from `_patcherRegistry`.
        Object.keys(IITM_MODULES),
        function(modExports, modName, modBaseDir) {
          const enabled = self2._isModuleEnabled(modName);
          const version = modBaseDir ? self2._getPackageVersion(modName, modBaseDir) : process.versions.node;
          if (IITM_MODULES[modName].instrumentImportMod) {
            return self2._patchModule(modExports, modName, version, enabled, true);
          } else {
            modExports.default = self2._patchModule(
              modExports.default,
              modName,
              version,
              enabled,
              false
            );
            return modExports;
          }
        }
      );
    };
    Instrumentation.prototype._getPackageVersion = function(modName, modBaseDir) {
      if (this._cachedVerFromModBaseDir.has(modBaseDir)) {
        return this._cachedVerFromModBaseDir.get(modBaseDir);
      }
      let ver = void 0;
      try {
        const version = JSON.parse(
          fs.readFileSync(path.join(modBaseDir, "package.json"))
        ).version;
        if (typeof version === "string") {
          ver = version;
        }
      } catch (err) {
        this._agent.logger.debug(
          { modName, modBaseDir, err },
          "could not load package version"
        );
      }
      this._cachedVerFromModBaseDir.set(modBaseDir, ver);
      return ver;
    };
    Instrumentation.prototype._patchModule = function(modExports, modPath, version, enabled, isImportMod) {
      this._log.debug(
        "instrumenting %s@%s module (enabled=%s, isImportMod=%s)",
        modPath,
        version,
        enabled,
        isImportMod
      );
      const patchers = this._patcherReg.getPatchers(modPath);
      if (patchers) {
        for (let patcher of patchers) {
          if (typeof patcher === "string") {
            if (patcher[0] === ".") {
              patcher = path.resolve(process.cwd(), patcher);
            }
            patcher = require(patcher);
          }
          const type = typeof patcher;
          if (type !== "function") {
            this._agent.logger.error(
              'Invalid patch handler type "%s" for module "%s"',
              type,
              modPath
            );
            continue;
          }
          modExports = patcher(modExports, this._agent, {
            name: modPath,
            version,
            enabled,
            isImportMod
          });
        }
      }
      return modExports;
    };
    Instrumentation.prototype.addEndedTransaction = function(transaction) {
      var agent = this._agent;
      if (!this._started) {
        agent.logger.debug("ignoring transaction %o", {
          trans: transaction.id,
          trace: transaction.traceId
        });
        return;
      }
      const rc = this._runCtxMgr.active();
      if (rc.currTransaction() === transaction) {
        this._runCtxMgr.supersedeRunContext(this._runCtxMgr.root());
        this._log.debug(
          { ctxmgr: this._runCtxMgr.toString() },
          "addEndedTransaction(%s)",
          transaction.name
        );
      }
      if (agent._conf.contextPropagationOnly) {
        agent.logger.trace("contextPropagationOnly: skip sendTransaction");
        return;
      }
      if (!transaction.sampled && !agent._apmClient.supportsKeepingUnsampledTransaction()) {
        return;
      }
      if (transaction.getBufferedSpan()) {
        this._encodeAndSendSpan(transaction.getBufferedSpan());
      }
      var payload = agent._transactionFilters.process(transaction._encode());
      if (!payload) {
        agent.logger.debug("transaction ignored by filter %o", {
          trans: transaction.id,
          trace: transaction.traceId
        });
        return;
      }
      agent.logger.debug("sending transaction %o", {
        trans: transaction.id,
        trace: transaction.traceId
      });
      agent._apmClient.sendTransaction(payload);
    };
    Instrumentation.prototype.addEndedSpan = function(span) {
      var agent = this._agent;
      if (!this._started) {
        agent.logger.debug("ignoring span %o", {
          span: span.id,
          parent: span.parentId,
          trace: span.traceId,
          name: span.name,
          type: span.type
        });
        return;
      }
      const newRc = this._runCtxMgr.active().leaveSpan(span);
      if (newRc) {
        this._runCtxMgr.supersedeRunContext(newRc);
      }
      this._log.debug(
        { ctxmgr: this._runCtxMgr.toString() },
        "addEndedSpan(%s)",
        span.name
      );
      if (agent._conf.contextPropagationOnly) {
        return;
      }
      if (!span.isRecorded()) {
        span.transaction.captureDroppedSpan(span);
        return;
      }
      if (!this._agent._conf.spanCompressionEnabled) {
        this._encodeAndSendSpan(span);
      } else {
        if (span.getBufferedSpan()) {
          this._encodeAndSendSpan(span.getBufferedSpan());
          span.setBufferedSpan(null);
        }
        const parentSpan = span.getParentSpan();
        if (parentSpan && parentSpan.ended || !span.isCompressionEligible()) {
          const buffered = parentSpan && parentSpan.getBufferedSpan();
          if (buffered) {
            this._encodeAndSendSpan(buffered);
            parentSpan.setBufferedSpan(null);
          }
          this._encodeAndSendSpan(span);
        } else if (!parentSpan.getBufferedSpan()) {
          parentSpan.setBufferedSpan(span);
        } else if (!parentSpan.getBufferedSpan().tryToCompress(span)) {
          this._encodeAndSendSpan(parentSpan.getBufferedSpan());
          parentSpan.setBufferedSpan(span);
        }
      }
    };
    Instrumentation.prototype._encodeAndSendSpan = function(span) {
      const duration = span.isComposite() ? span.getCompositeSum() : span.duration();
      if (span.discardable && duration / 1e3 < this._agent._conf.exitSpanMinDuration) {
        span.transaction.captureDroppedSpan(span);
        return;
      }
      const agent = this._agent;
      const inflightEvents = agent._inflightEvents;
      inflightEvents.add(span.id);
      agent.logger.debug("encoding span %o", {
        span: span.id,
        parent: span.parentId,
        trace: span.traceId,
        name: span.name,
        type: span.type
      });
      span._encode(function(err, payload) {
        if (err) {
          agent.logger.error("error encoding span %o", {
            span: span.id,
            parent: span.parentId,
            trace: span.traceId,
            name: span.name,
            type: span.type,
            error: err.message
          });
        } else {
          payload = agent._spanFilters.process(payload);
          if (!payload) {
            agent.logger.debug("span ignored by filter %o", {
              span: span.id,
              parent: span.parentId,
              trace: span.traceId,
              name: span.name,
              type: span.type
            });
          } else {
            agent.logger.debug("sending span %o", {
              span: span.id,
              parent: span.parentId,
              trace: span.traceId,
              name: span.name,
              type: span.type
            });
            if (agent._apmClient) {
              agent._apmClient.sendSpan(payload);
            }
          }
        }
        inflightEvents.delete(span.id);
      });
    };
    Instrumentation.prototype.supersedeWithTransRunContext = function(trans) {
      if (this._started) {
        const rc = this._runCtxMgr.root().enterTrans(trans);
        this._runCtxMgr.supersedeRunContext(rc);
        this._log.debug(
          { ctxmgr: this._runCtxMgr.toString() },
          "supersedeWithTransRunContext(<Trans %s>)",
          trans.id
        );
      }
    };
    Instrumentation.prototype.supersedeWithSpanRunContext = function(span) {
      if (this._started) {
        const rc = this._runCtxMgr.active().enterSpan(span);
        this._runCtxMgr.supersedeRunContext(rc);
        this._log.debug(
          { ctxmgr: this._runCtxMgr.toString() },
          "supersedeWithSpanRunContext(<Span %s>)",
          span.id
        );
      }
    };
    Instrumentation.prototype.supersedeWithEmptyRunContext = function() {
      if (this._started) {
        this._runCtxMgr.supersedeRunContext(this._runCtxMgr.root());
        this._log.debug(
          { ctxmgr: this._runCtxMgr.toString() },
          "supersedeWithEmptyRunContext()"
        );
      }
    };
    Instrumentation.prototype.createTransaction = function(name, ...args) {
      return new Transaction(this._agent, name, ...args);
    };
    Instrumentation.prototype.startTransaction = function(name, ...args) {
      if (!this._agent.isStarted()) {
        return new NoopTransaction();
      }
      const trans = new Transaction(this._agent, name, ...args);
      this.supersedeWithTransRunContext(trans);
      return trans;
    };
    Instrumentation.prototype.endTransaction = function(result, endTime) {
      const trans = this.currTransaction();
      if (!trans) {
        this._agent.logger.debug(
          "cannot end transaction - no active transaction found"
        );
        return;
      }
      trans.end(result, endTime);
    };
    Instrumentation.prototype.setDefaultTransactionName = function(name) {
      const trans = this.currTransaction();
      if (!trans) {
        this._agent.logger.debug(
          "no active transaction found - cannot set default transaction name"
        );
        return;
      }
      trans.setDefaultName(name);
    };
    Instrumentation.prototype.setTransactionName = function(name) {
      const trans = this.currTransaction();
      if (!trans) {
        this._agent.logger.debug(
          "no active transaction found - cannot set transaction name"
        );
        return;
      }
      trans.name = name;
    };
    Instrumentation.prototype.setTransactionOutcome = function(outcome) {
      const trans = this.currTransaction();
      if (!trans) {
        this._agent.logger.debug(
          "no active transaction found - cannot set transaction outcome"
        );
        return;
      }
      trans.setOutcome(outcome);
    };
    Instrumentation.prototype.startSpan = function(name, type, subtype, action, opts) {
      const trans = this.currTransaction();
      if (!trans) {
        this._agent.logger.debug(
          "no active transaction found - cannot build new span"
        );
        return null;
      }
      return trans.startSpan.apply(trans, arguments);
    };
    Instrumentation.prototype.createSpan = function(name, type, subtype, action, opts) {
      const trans = this.currTransaction();
      if (!trans) {
        this._agent.logger.debug(
          "no active transaction found - cannot build new span"
        );
        return null;
      }
      return trans.createSpan.apply(trans, arguments);
    };
    Instrumentation.prototype.setSpanOutcome = function(outcome) {
      const span = this.currSpan();
      if (!span) {
        this._agent.logger.debug("no active span found - cannot set span outcome");
        return null;
      }
      span.setOutcome(outcome);
    };
    Instrumentation.prototype.currRunContext = function() {
      if (!this._started) {
        return null;
      }
      return this._runCtxMgr.active();
    };
    Instrumentation.prototype.bindFunction = function(fn) {
      if (!this._started) {
        return fn;
      }
      return this._runCtxMgr.bindFn(this._runCtxMgr.active(), fn);
    };
    Instrumentation.prototype.bindFunctionToRunContext = function(runContext, fn) {
      if (!this._started) {
        return fn;
      }
      return this._runCtxMgr.bindFn(runContext, fn);
    };
    Instrumentation.prototype.bindFunctionToEmptyRunContext = function(fn) {
      if (!this._started) {
        return fn;
      }
      return this._runCtxMgr.bindFn(this._runCtxMgr.root(), fn);
    };
    Instrumentation.prototype.bindEmitter = function(ee) {
      if (!this._started) {
        return ee;
      }
      return this._runCtxMgr.bindEE(this._runCtxMgr.active(), ee);
    };
    Instrumentation.prototype.bindEmitterToRunContext = function(runContext, ee) {
      if (!this._started) {
        return ee;
      }
      return this._runCtxMgr.bindEE(runContext, ee);
    };
    Instrumentation.prototype.isEventEmitterBound = function(ee) {
      if (!this._started) {
        return false;
      }
      return this._runCtxMgr.isEEBound(ee);
    };
    Instrumentation.prototype.withRunContext = function(runContext, fn, thisArg, ...args) {
      if (!this._started) {
        return fn.call(thisArg, ...args);
      }
      return this._runCtxMgr.with(runContext, fn, thisArg, ...args);
    };
    module2.exports = {
      Instrumentation
    };
  }
});

// node_modules/console-log-level/index.js
var require_console_log_level = __commonJS({
  "node_modules/console-log-level/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var levels = ["trace", "debug", "info", "warn", "error", "fatal"];
    var noop = function() {
    };
    module2.exports = function(opts) {
      opts = opts || {};
      opts.level = opts.level || "info";
      var logger = {};
      var shouldLog = function(level) {
        return levels.indexOf(level) >= levels.indexOf(opts.level);
      };
      levels.forEach(function(level) {
        logger[level] = shouldLog(level) ? log : noop;
        function log() {
          var prefix = opts.prefix;
          var normalizedLevel;
          if (opts.stderr) {
            normalizedLevel = "error";
          } else {
            switch (level) {
              case "trace":
                normalizedLevel = "info";
                break;
              case "debug":
                normalizedLevel = "info";
                break;
              case "fatal":
                normalizedLevel = "error";
                break;
              default:
                normalizedLevel = level;
            }
          }
          if (prefix) {
            if (typeof prefix === "function") prefix = prefix(level);
            arguments[0] = util.format(prefix, arguments[0]);
          }
          console[normalizedLevel](util.format.apply(util, arguments));
        }
      });
      return logger;
    };
  }
});

// node_modules/optional-js/lib/optional.js
var require_optional = __commonJS({
  "node_modules/optional-js/lib/optional.js"(exports2, module2) {
    function Optional(value) {
      this._value = value;
    }
    Optional.prototype = {
      get: function get() {
        if (isNull(this._value)) {
          throw new Error("optional is empty");
        }
        return this._value;
      },
      isPresent: function isPresent() {
        return !isNull(this._value);
      },
      ifPresent: function ifPresent(consumer) {
        if (!isNull(this._value)) {
          if (!isFunction(consumer)) {
            throw new Error("consumer is not a function");
          }
          consumer(this._value);
        }
      },
      filter: function filter(predicate) {
        if (!isFunction(predicate)) {
          throw new Error("predicate is not a function");
        }
        if (!isNull(this._value) && predicate(this._value)) {
          return new Optional(this._value);
        }
        return new Optional();
      },
      map: function map(mapper) {
        var mappedValue;
        if (!isFunction(mapper)) {
          throw new Error("mapper is not a function");
        }
        if (isNull(this._value)) {
          return new Optional();
        }
        mappedValue = mapper(this._value);
        return isNull(mappedValue) ? new Optional() : new Optional(mappedValue);
      },
      flatMap: function flatMap(mapper) {
        var flatMappedValue;
        if (!isFunction(mapper)) {
          throw new Error("mapper is not a function");
        }
        if (isNull(this._value)) {
          return new Optional();
        }
        flatMappedValue = mapper(this._value);
        if (isNull(flatMappedValue) || isNull(flatMappedValue.get)) {
          throw new Error("mapper does not return an Optional");
        }
        return flatMappedValue;
      },
      peek: function peek(peeker) {
        if (!isFunction(peeker)) {
          throw new Error("peeker is not a function");
        }
        if (isNull(this._value)) {
          return new Optional();
        }
        peeker(this._value);
        return new Optional(this._value);
      },
      orElse: function orElse(other) {
        return isNull(this._value) ? other : this._value;
      },
      orElseGet: function orElseGet(supplier) {
        if (!isFunction(supplier)) {
          throw new Error("supplier is not a function");
        }
        if (isNull(this._value)) {
          return supplier();
        } else {
          return this._value;
        }
      },
      orElseThrow: function orElseThrow(exceptionSupplier) {
        if (isNull(this._value)) {
          if (!isFunction(exceptionSupplier)) {
            throw new Error("exception provider is not a function");
          }
          throw exceptionSupplier();
        }
        return this._value;
      },
      ifPresentOrElse: function ifPresentOrElse(action, emptyAction) {
        if (!isNull(this._value)) {
          if (!isFunction(action)) {
            throw new Error("action is not a function");
          }
          action(this._value);
        } else {
          if (!isFunction(emptyAction)) {
            throw new Error("emptyAction is not a function");
          }
          emptyAction();
        }
      },
      or: function or(optionalSupplier) {
        if (isNull(this._value)) {
          if (!isFunction(optionalSupplier)) {
            throw new Error("optionalSupplier is not a function");
          }
          return optionalSupplier();
        }
        return this;
      },
      hashCode: function hashMap() {
        return -1;
      }
    };
    function isNull(value) {
      return value === void 0 || value === null;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    module2.exports = Optional;
  }
});

// node_modules/optional-js/index.js
var require_optional_js = __commonJS({
  "node_modules/optional-js/index.js"(exports2, module2) {
    var Optional = require_optional();
    module2.exports = {
      empty: function empty() {
        return new Optional();
      },
      of: function of(value) {
        if (value === void 0 || value === null) {
          throw new Error("value is not defined");
        }
        return new Optional(value);
      },
      ofNullable: function ofNullable(value) {
        return new Optional(value);
      }
    };
  }
});

// node_modules/measured-core/lib/metrics/Metric.js
var require_Metric = __commonJS({
  "node_modules/measured-core/lib/metrics/Metric.js"(exports2, module2) {
    var MetricTypes = {
      COUNTER: "Counter",
      GAUGE: "Gauge",
      HISTOGRAM: "Histogram",
      METER: "Meter",
      TIMER: "Timer"
    };
    module2.exports = {
      MetricTypes
    };
  }
});

// node_modules/measured-core/lib/metrics/Counter.js
var require_Counter = __commonJS({
  "node_modules/measured-core/lib/metrics/Counter.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var Counter = class {
      /**
       * @param {CounterProperties} [properties] see {@link CounterProperties}
       */
      constructor(properties) {
        properties = properties || {};
        this._count = properties.count || 0;
      }
      /**
       * Counters directly return their currently value.
       * @return {number}
       */
      toJSON() {
        return this._count;
      }
      /**
       * Increments the counter.
       * @param {number} n Increment the counter by n. Defaults to 1.
       */
      inc(n) {
        this._count += arguments.length ? n : 1;
      }
      /**
       * Decrements the counter
       * @param {number} n Decrement the counter by n. Defaults to 1.
       */
      dec(n) {
        this._count -= arguments.length ? n : 1;
      }
      /**
       * Resets the counter back to count Defaults to 0.
       * @param {number} count Resets the counter back to count Defaults to 0.
       */
      reset(count) {
        this._count = count || 0;
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.COUNTER;
      }
    };
    module2.exports = Counter;
  }
});

// node_modules/measured-core/lib/metrics/Gauge.js
var require_Gauge = __commonJS({
  "node_modules/measured-core/lib/metrics/Gauge.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var Gauge = class {
      /**
       * @param {function} readFn A function that returns the numeric value for this gauge.
       */
      constructor(readFn) {
        this._readFn = readFn;
      }
      /**
       * @return {number} Gauges directly return the value from the callback which should be a number.
       */
      toJSON() {
        return this._readFn();
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.GAUGE;
      }
    };
    module2.exports = Gauge;
  }
});

// node_modules/measured-core/lib/metrics/SettableGauge.js
var require_SettableGauge = __commonJS({
  "node_modules/measured-core/lib/metrics/SettableGauge.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var SettableGauge = class {
      /**
       * @param {SettableGaugeProperties} [options] See {@link SettableGaugeProperties}.
       */
      constructor(options) {
        options = options || {};
        this._value = options.initialValue || 0;
      }
      setValue(value) {
        this._value = value;
      }
      /**
       * @return {number} Settable Gauges directly return there current value.
       */
      toJSON() {
        return this._value;
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.GAUGE;
      }
    };
    module2.exports = SettableGauge;
  }
});

// node_modules/measured-core/lib/util/units.js
var require_units = __commonJS({
  "node_modules/measured-core/lib/util/units.js"(exports2, module2) {
    var NANOSECONDS = 1 / (1e3 * 1e3);
    var MICROSECONDS = 1 / 1e3;
    var MILLISECONDS = 1;
    var SECONDS = 1e3 * MILLISECONDS;
    var MINUTES = 60 * SECONDS;
    var HOURS = 60 * MINUTES;
    var DAYS = 24 * HOURS;
    module2.exports = {
      /**
       * nanoseconds in milliseconds
       * @type {number}
       */
      NANOSECONDS,
      /**
       * microseconds in milliseconds
       * @type {number}
       */
      MICROSECONDS,
      /**
       * milliseconds in milliseconds
       * @type {number}
       */
      MILLISECONDS,
      /**
       * seconds in milliseconds
       * @type {number}
       */
      SECONDS,
      /**
       * minutes in milliseconds
       * @type {number}
       */
      MINUTES,
      /**
       * hours in milliseconds
       * @type {number}
       */
      HOURS,
      /**
       * days in milliseconds
       * @type {number}
       */
      DAYS
    };
  }
});

// node_modules/measured-core/lib/metrics/CachedGauge.js
var require_CachedGauge = __commonJS({
  "node_modules/measured-core/lib/metrics/CachedGauge.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var TimeUnits = require_units();
    var CachedGauge = class {
      /**
       * @param {function} valueProducingPromiseCallback A function that returns a promise than when
       * resolved supplies the value that should be cached in this gauge.
       * @param {number} updateIntervalInSeconds How often the cached gauge should update it's value.
       * @param {number} [timeUnitOverride] by default this function takes updateIntervalInSeconds and multiplies it by TimeUnits.SECONDS (1000),
       * You can override it here.
       */
      constructor(valueProducingPromiseCallback, updateIntervalInSeconds, timeUnitOverride) {
        const timeUnit = timeUnitOverride || TimeUnits.SECONDS;
        this._valueProducingPromiseCallback = valueProducingPromiseCallback;
        this._value = 0;
        this._updateValue();
        this._interval = setInterval(() => {
          this._updateValue();
        }, updateIntervalInSeconds * timeUnit);
      }
      /**
       * Calls the promise producing callback and sets the value when it gets resolved.
       * @private
       */
      _updateValue() {
        this._valueProducingPromiseCallback().then((value) => {
          this._value = value;
        });
      }
      /**
       * @return {number} Gauges directly return the value which should be a number.
       */
      toJSON() {
        return this._value;
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.GAUGE;
      }
      /**
       * Clears the interval, so that it doesn't keep any processes alive.
       */
      end() {
        clearInterval(this._interval);
        this._interval = null;
      }
    };
    module2.exports = CachedGauge;
  }
});

// node_modules/binary-search/index.js
var require_binary_search2 = __commonJS({
  "node_modules/binary-search/index.js"(exports2, module2) {
    module2.exports = function(haystack, needle, comparator, low, high) {
      var mid, cmp;
      if (low === void 0)
        low = 0;
      else {
        low = low | 0;
        if (low < 0 || low >= haystack.length)
          throw new RangeError("invalid lower bound");
      }
      if (high === void 0)
        high = haystack.length - 1;
      else {
        high = high | 0;
        if (high < low || high >= haystack.length)
          throw new RangeError("invalid upper bound");
      }
      while (low <= high) {
        mid = low + (high - low >>> 1);
        cmp = +comparator(haystack[mid], needle, mid, haystack);
        if (cmp < 0)
          low = mid + 1;
        else if (cmp > 0)
          high = mid - 1;
        else
          return mid;
      }
      return ~low;
    };
  }
});

// node_modules/measured-core/lib/util/BinaryHeap.js
var require_BinaryHeap = __commonJS({
  "node_modules/measured-core/lib/util/BinaryHeap.js"(exports2, module2) {
    var BinaryHeap = class _BinaryHeap {
      constructor(options) {
        options = options || {};
        this._elements = options.elements || [];
        this._score = options.score || this._score;
      }
      /**
       * Add elements to the binary heap.
       * @param {any[]} elements
       */
      add(...elements) {
        elements.forEach((element) => {
          this._elements.push(element);
          this._bubble(this._elements.length - 1);
        });
      }
      first() {
        return this._elements[0];
      }
      removeFirst() {
        const root = this._elements[0];
        const last = this._elements.pop();
        if (this._elements.length > 0) {
          this._elements[0] = last;
          this._sink(0);
        }
        return root;
      }
      clone() {
        return new _BinaryHeap({
          elements: this.toArray(),
          score: this._score
        });
      }
      toSortedArray() {
        const array = [];
        const clone = this.clone();
        let element;
        while (true) {
          element = clone.removeFirst();
          if (element === void 0) {
            break;
          }
          array.push(element);
        }
        return array;
      }
      toArray() {
        return [].concat(this._elements);
      }
      size() {
        return this._elements.length;
      }
      _bubble(bubbleIndex) {
        const bubbleElement = this._elements[bubbleIndex];
        const bubbleScore = this._score(bubbleElement);
        let parentIndex;
        let parentElement;
        let parentScore;
        while (bubbleIndex > 0) {
          parentIndex = this._parentIndex(bubbleIndex);
          parentElement = this._elements[parentIndex];
          parentScore = this._score(parentElement);
          if (bubbleScore <= parentScore) {
            break;
          }
          this._elements[parentIndex] = bubbleElement;
          this._elements[bubbleIndex] = parentElement;
          bubbleIndex = parentIndex;
        }
      }
      _sink(sinkIndex) {
        const sinkElement = this._elements[sinkIndex];
        const sinkScore = this._score(sinkElement);
        const { length } = this._elements;
        let swapIndex;
        let swapScore;
        let swapElement;
        let childIndexes;
        let i;
        let childIndex;
        let childElement;
        let childScore;
        while (true) {
          swapIndex = null;
          swapScore = null;
          swapElement = null;
          childIndexes = this._childIndexes(sinkIndex);
          for (i = 0; i < childIndexes.length; i++) {
            childIndex = childIndexes[i];
            if (childIndex >= length) {
              break;
            }
            childElement = this._elements[childIndex];
            childScore = this._score(childElement);
            if (childScore > sinkScore) {
              if (swapScore === null || swapScore < childScore) {
                swapIndex = childIndex;
                swapScore = childScore;
                swapElement = childElement;
              }
            }
          }
          if (swapIndex === null) {
            break;
          }
          this._elements[swapIndex] = sinkElement;
          this._elements[sinkIndex] = swapElement;
          sinkIndex = swapIndex;
        }
      }
      _parentIndex(index) {
        return Math.floor((index - 1) / 2);
      }
      _childIndexes(index) {
        return [2 * index + 1, 2 * index + 2];
      }
      _score(element) {
        return element.valueOf();
      }
    };
    module2.exports = BinaryHeap;
  }
});

// node_modules/measured-core/lib/util/ExponentiallyDecayingSample.js
var require_ExponentiallyDecayingSample = __commonJS({
  "node_modules/measured-core/lib/util/ExponentiallyDecayingSample.js"(exports2, module2) {
    var BinaryHeap = require_BinaryHeap();
    var units = require_units();
    var RESCALE_INTERVAL = units.HOURS;
    var ALPHA = 0.015;
    var SIZE = 1028;
    var ExponentiallyDecayingSample = class {
      constructor(options) {
        options = options || {};
        this._elements = new BinaryHeap({
          score: (element) => -element.priority
        });
        this._rescaleInterval = options.rescaleInterval || RESCALE_INTERVAL;
        this._alpha = options.alpha || ALPHA;
        this._size = options.size || SIZE;
        this._random = options.random || this._random;
        this._landmark = null;
        this._nextRescale = null;
      }
      update(value, timestamp) {
        const now = Date.now();
        if (!this._landmark) {
          this._landmark = now;
          this._nextRescale = this._landmark + this._rescaleInterval;
        }
        timestamp = timestamp || now;
        const newSize = this._elements.size() + 1;
        const element = {
          priority: this._priority(timestamp - this._landmark),
          value
        };
        if (newSize <= this._size) {
          this._elements.add(element);
        } else if (element.priority > this._elements.first().priority) {
          this._elements.removeFirst();
          this._elements.add(element);
        }
        if (now >= this._nextRescale) {
          this._rescale(now);
        }
      }
      toSortedArray() {
        return this._elements.toSortedArray().map((element) => element.value);
      }
      toArray() {
        return this._elements.toArray().map((element) => element.value);
      }
      toArrayWithWeights() {
        return this._elements.toArray();
      }
      _weight(age) {
        return Math.exp(this._alpha * (age / 1e3));
      }
      _priority(age) {
        return this._weight(age) / this._random();
      }
      _random() {
        return Math.random();
      }
      _rescale(now) {
        now = now || Date.now();
        const self2 = this;
        const oldLandmark = this._landmark;
        this._landmark = now || Date.now();
        this._nextRescale = now + this._rescaleInterval;
        const factor = self2._priority(-(self2._landmark - oldLandmark));
        this._elements.toArray().forEach((element) => {
          element.priority *= factor;
        });
      }
    };
    module2.exports = ExponentiallyDecayingSample;
  }
});

// node_modules/measured-core/lib/metrics/Histogram.js
var require_Histogram = __commonJS({
  "node_modules/measured-core/lib/metrics/Histogram.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var binarySearch = require_binary_search2();
    var EDS = require_ExponentiallyDecayingSample();
    var Histogram = class {
      /**
       @param {HistogramProperties} [properties] see {@link HistogramProperties}.
       */
      constructor(properties) {
        this._properties = properties || {};
        this._initializeState();
      }
      _initializeState() {
        this._sample = this._properties.sample || new EDS();
        this._percentilesMethod = this._properties.percentilesMethod || this._percentiles;
        this._min = null;
        this._max = null;
        this._count = 0;
        this._sum = 0;
        this._constianceM = 0;
        this._constianceS = 0;
      }
      /**
       * Pushes value into the sample. timestamp defaults to Date.now().
       * @param {number} value
       */
      update(value) {
        this._count++;
        this._sum += value;
        this._sample.update(value);
        this._updateMin(value);
        this._updateMax(value);
        this._updateVariance(value);
      }
      _percentiles(percentiles) {
        const values = this._sample.toArray().sort((a, b) => {
          return a === b ? 0 : a - b;
        });
        const results = {};
        let i, percentile, pos, lower, upper;
        for (i = 0; i < percentiles.length; i++) {
          percentile = percentiles[i];
          if (values.length) {
            pos = percentile * (values.length + 1);
            if (pos < 1) {
              results[percentile] = values[0];
            } else if (pos >= values.length) {
              results[percentile] = values[values.length - 1];
            } else {
              lower = values[Math.floor(pos) - 1];
              upper = values[Math.ceil(pos) - 1];
              results[percentile] = lower + (pos - Math.floor(pos)) * (upper - lower);
            }
          } else {
            results[percentile] = null;
          }
        }
        return results;
      }
      weightedPercentiles(percentiles) {
        const values = this._sample.toArrayWithWeights().sort((a, b) => {
          return a.value === b.value ? 0 : a.value - b.value;
        });
        const sumWeight = values.reduce((sum, sample) => {
          return sum + sample.priority;
        }, 0);
        const normWeights = values.map((value) => {
          return value.priority / sumWeight;
        });
        const quantiles = [0];
        let i;
        for (i = 1; i < values.length; i++) {
          quantiles[i] = quantiles[i - 1] + normWeights[i - 1];
        }
        function gt(a, b) {
          return a - b;
        }
        const results = {};
        let percentile, pos;
        for (i = 0; i < percentiles.length; i++) {
          percentile = percentiles[i];
          if (values.length) {
            pos = binarySearch(quantiles, percentile, gt);
            if (pos < 0) {
              results[percentile] = values[-pos - 1 - 1].value;
            } else if (pos < 1) {
              results[percentile] = values[0].value;
            } else if (pos >= values.length) {
              results[percentile] = values[values.length - 1].value;
            }
          } else {
            results[percentile] = null;
          }
        }
        return results;
      }
      /**
       * Resets all values. Histograms initialized with custom options will be reset to the default settings (patch welcome).
       */
      reset() {
        this._properties.sample = new EDS();
        this._initializeState();
      }
      /**
       * Checks whether the histogram contains values.
       * @return {boolean} Whether the histogram contains values.
       */
      hasValues() {
        return this._count > 0;
      }
      /**
       * @return {HistogramData}
       */
      toJSON() {
        const percentiles = this._percentilesMethod([0.5, 0.75, 0.95, 0.99, 0.999]);
        return {
          min: this._min,
          max: this._max,
          sum: this._sum,
          variance: this._calculateVariance(),
          mean: this._calculateMean(),
          stddev: this._calculateStddev(),
          count: this._count,
          median: percentiles[0.5],
          p75: percentiles[0.75],
          p95: percentiles[0.95],
          p99: percentiles[0.99],
          p999: percentiles[0.999]
        };
      }
      _updateMin(value) {
        if (this._min === null || value < this._min) {
          this._min = value;
        }
      }
      _updateMax(value) {
        if (this._max === null || value > this._max) {
          this._max = value;
        }
      }
      _updateVariance(value) {
        if (this._count === 1) {
          this._constianceM = value;
          return value;
        }
        const oldM = this._constianceM;
        this._constianceM += (value - oldM) / this._count;
        this._constianceS += (value - oldM) * (value - this._constianceM);
        return void 0;
      }
      /**
       *
       * @return {number|null}
       * @private
       */
      _calculateMean() {
        return this._count === 0 ? 0 : this._sum / this._count;
      }
      /**
       * @return {number|null}
       * @private
       */
      _calculateVariance() {
        return this._count <= 1 ? null : this._constianceS / (this._count - 1);
      }
      /**
       * @return {number|null}
       * @private
       */
      _calculateStddev() {
        return this._count < 1 ? null : Math.sqrt(this._calculateVariance());
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.HISTOGRAM;
      }
    };
    module2.exports = Histogram;
  }
});

// node_modules/measured-core/lib/util/ExponentiallyMovingWeightedAverage.js
var require_ExponentiallyMovingWeightedAverage = __commonJS({
  "node_modules/measured-core/lib/util/ExponentiallyMovingWeightedAverage.js"(exports2, module2) {
    var units = require_units();
    var TICK_INTERVAL = 5 * units.SECONDS;
    var ExponentiallyMovingWeightedAverage = class {
      constructor(timePeriod, tickInterval) {
        this._timePeriod = timePeriod || units.MINUTE;
        this._tickInterval = tickInterval || TICK_INTERVAL;
        this._alpha = 1 - Math.exp(-this._tickInterval / this._timePeriod);
        this._count = 0;
        this._rate = 0;
      }
      update(n) {
        this._count += n;
      }
      tick() {
        const instantRate = this._count / this._tickInterval;
        this._count = 0;
        this._rate += this._alpha * (instantRate - this._rate);
      }
      rate(timeUnit) {
        return (this._rate || 0) * timeUnit;
      }
    };
    module2.exports = ExponentiallyMovingWeightedAverage;
  }
});

// node_modules/measured-core/lib/metrics/Meter.js
var require_Meter = __commonJS({
  "node_modules/measured-core/lib/metrics/Meter.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var units = require_units();
    var EWMA = require_ExponentiallyMovingWeightedAverage();
    var RATE_UNIT = units.SECONDS;
    var TICK_INTERVAL = 5 * units.SECONDS;
    var Meter = class {
      /**
       * @param {MeterProperties} [properties] see {@link MeterProperties}.
       */
      constructor(properties) {
        this._properties = properties || {};
        this._initializeState();
        if (!this._properties.keepAlive) {
          this.unref();
        }
      }
      /**
       * Initializes the state of this Metric
       * @private
       */
      _initializeState() {
        this._rateUnit = this._properties.rateUnit || RATE_UNIT;
        this._tickInterval = this._properties.tickInterval || TICK_INTERVAL;
        if (this._properties.getTime) {
          this._getTime = this._properties.getTime;
        }
        this._m1Rate = this._properties.m1Rate || new EWMA(units.MINUTES, this._tickInterval);
        this._m5Rate = this._properties.m5Rate || new EWMA(5 * units.MINUTES, this._tickInterval);
        this._m15Rate = this._properties.m15Rate || new EWMA(15 * units.MINUTES, this._tickInterval);
        this._count = 0;
        this._currentSum = 0;
        this._startTime = this._getTime();
        this._lastToJSON = this._getTime();
        this._interval = setInterval(this._tick.bind(this), TICK_INTERVAL);
      }
      /**
       * Register n events as having just occured. Defaults to 1.
       * @param {number} [n]
       */
      mark(n) {
        if (!this._interval) {
          this.start();
        }
        n = n || 1;
        this._count += n;
        this._currentSum += n;
        this._m1Rate.update(n);
        this._m5Rate.update(n);
        this._m15Rate.update(n);
      }
      start() {
      }
      end() {
        clearInterval(this._interval);
        this._interval = null;
      }
      /**
       * Refs the backing timer again. Idempotent.
       */
      ref() {
        if (this._interval && this._interval.ref) {
          this._interval.ref();
        }
      }
      /**
       * Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent.
       */
      unref() {
        if (this._interval && this._interval.unref) {
          this._interval.unref();
        }
      }
      _tick() {
        this._m1Rate.tick();
        this._m5Rate.tick();
        this._m15Rate.tick();
      }
      /**
       * Resets all values. Meters initialized with custom options will be reset to the default settings (patch welcome).
       */
      reset() {
        this.end();
        this._initializeState();
      }
      meanRate() {
        if (this._count === 0) {
          return 0;
        }
        const elapsed = this._getTime() - this._startTime;
        return this._count / elapsed * this._rateUnit;
      }
      currentRate() {
        const currentSum = this._currentSum;
        const duration = this._getTime() - this._lastToJSON;
        const currentRate = currentSum / duration * this._rateUnit;
        this._currentSum = 0;
        this._lastToJSON = this._getTime();
        return currentRate || 0;
      }
      /**
       * @return {MeterData}
       */
      toJSON() {
        return {
          mean: this.meanRate(),
          count: this._count,
          currentRate: this.currentRate(),
          "1MinuteRate": this._m1Rate.rate(this._rateUnit),
          "5MinuteRate": this._m5Rate.rate(this._rateUnit),
          "15MinuteRate": this._m15Rate.rate(this._rateUnit)
        };
      }
      _getTime() {
        if (!process.hrtime) {
          return (/* @__PURE__ */ new Date()).getTime();
        }
        const hrtime = process.hrtime();
        return hrtime[0] * 1e3 + hrtime[1] / (1e3 * 1e3);
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.METER;
      }
    };
    module2.exports = Meter;
  }
});

// node_modules/measured-core/lib/util/Stopwatch.js
var require_Stopwatch = __commonJS({
  "node_modules/measured-core/lib/util/Stopwatch.js"(exports2, module2) {
    var { EventEmitter } = require("events");
    var Stopwatch = class extends EventEmitter {
      /**
       * Creates a started Stopwatch
       * @param {StopwatchProperties} [options] See {@link StopwatchProperties}
       */
      constructor(options) {
        super();
        options = options || {};
        EventEmitter.call(this);
        if (options.getTime) {
          this._getTime = options.getTime;
        }
        this._start = this._getTime();
        this._ended = false;
      }
      /**
       * Called to mark the end of the timer task
       * @return {number} the total execution time
       */
      end() {
        if (this._ended) {
          return null;
        }
        this._ended = true;
        const elapsed = this._getTime() - this._start;
        this.emit("end", elapsed);
        return elapsed;
      }
      _getTime() {
        if (!process.hrtime) {
          return Date.now();
        }
        const hrtime = process.hrtime();
        return hrtime[0] * 1e3 + hrtime[1] / (1e3 * 1e3);
      }
    };
    module2.exports = Stopwatch;
  }
});

// node_modules/measured-core/lib/metrics/Timer.js
var require_Timer = __commonJS({
  "node_modules/measured-core/lib/metrics/Timer.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var Histogram = require_Histogram();
    var Meter = require_Meter();
    var Stopwatch = require_Stopwatch();
    var Timer = class {
      /**
       * @param {TimerProperties} [properties] See {@link TimerProperties}.
       */
      constructor(properties) {
        properties = properties || {};
        this._meter = properties.meter || new Meter({});
        this._histogram = properties.histogram || new Histogram({});
        this._getTime = properties.getTime;
        this._keepAlive = !!properties.keepAlive;
        if (!properties.keepAlive) {
          this.unref();
        }
      }
      /**
       * @return {Stopwatch} Returns a Stopwatch that has been started.
       */
      start() {
        const self2 = this;
        const watch = new Stopwatch({ getTime: this._getTime });
        watch.once("end", (elapsed) => {
          self2.update(elapsed);
        });
        return watch;
      }
      /**
       * Updates the internal histogram with value and marks one event on the internal meter.
       * @param {number} value
       */
      update(value) {
        this._meter.mark();
        this._histogram.update(value);
      }
      /**
       * Resets all values. Timers initialized with custom options will be reset to the default settings.
       */
      reset() {
        this._meter.reset();
        this._histogram.reset();
      }
      end() {
        this._meter.end();
      }
      /**
       * Refs the backing timer again. Idempotent.
       */
      ref() {
        this._meter.ref();
      }
      /**
       * Unrefs the backing timer. The meter will not keep the event loop alive. Idempotent.
       */
      unref() {
        this._meter.unref();
      }
      /**
       * toJSON output:
       *
       * <li> meter: See <a href="#meter">Meter</a>#toJSON output docs above.</li>
       * <li> histogram: See <a href="#histogram">Histogram</a>#toJSON output docs above.</a></li>
       *
       * @return {any}
       */
      toJSON() {
        return {
          meter: this._meter.toJSON(),
          histogram: this._histogram.toJSON()
        };
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.TIMER;
      }
    };
    module2.exports = Timer;
  }
});

// node_modules/measured-core/lib/Collection.js
var require_Collection = __commonJS({
  "node_modules/measured-core/lib/Collection.js"(exports2, module2) {
    var Optional = require_optional_js();
    var Counter = require_Counter();
    var Gauge = require_Gauge();
    var SettableGauge = require_SettableGauge();
    var CachedGauge = require_CachedGauge();
    var Histogram = require_Histogram();
    var Meter = require_Meter();
    var Timer = require_Timer();
    var { MetricTypes } = require_Metric();
    var Collection = class {
      /**
       * Creates a named collection of metrics
       * @param {string} [name] The name to use for this collection.
       */
      constructor(name) {
        this.name = name;
        this._metrics = {};
      }
      /**
       * register a metric that was created outside the provided convenience methods of this collection
       * @param name The metric name
       * @param metric The {@link Metric} implementation
       * @example
       * var { Collection, Gauge } = require('measured');
       * const collection = new Collection('node-process-metrics');
       * const gauge = new Gauge(() => {
       *    return process.memoryUsage().heapUsed;
       * });
       * collection.register('node.process.heap_used', gauge);
       */
      register(name, metric) {
        this._metrics[name] = metric;
      }
      /**
       * Fetches the data/values from all registered metrics
       * @return {Object} The combined JSON object
       */
      toJSON() {
        const json = {};
        Object.keys(this._metrics).forEach((metric) => {
          if (Object.prototype.hasOwnProperty.call(this._metrics, metric)) {
            json[metric] = this._metrics[metric].toJSON();
          }
        });
        if (!this.name) {
          return json;
        }
        const wrapper = {};
        wrapper[this.name] = json;
        return wrapper;
      }
      /**
       * Gets or creates and registers a {@link Gauge}
       * @param {string} name The metric name
       * @param {function} readFn See {@link Gauge}
       * @return {Gauge}
       */
      gauge(name, readFn) {
        this._validateName(name);
        let gauge;
        this._getMetricForNameAndType(name, MetricTypes.GAUGE).ifPresentOrElse(
          (registeredMetric) => {
            gauge = registeredMetric;
          },
          () => {
            gauge = new Gauge(readFn);
            this.register(name, gauge);
          }
        );
        return gauge;
      }
      /**
       * Gets or creates and registers a {@link Counter}
       * @param {string} name The metric name
       * @param {CounterProperties} [properties] See {@link CounterProperties}
       * @return {Counter}
       */
      counter(name, properties) {
        this._validateName(name);
        let counter;
        this._getMetricForNameAndType(name, MetricTypes.COUNTER).ifPresentOrElse(
          (registeredMetric) => {
            counter = registeredMetric;
          },
          () => {
            counter = new Counter(properties);
            this.register(name, counter);
          }
        );
        return counter;
      }
      /**
       * Gets or creates and registers a {@link Histogram}
       * @param {string} name The metric name
       * @param {HistogramProperties} [properties] See {@link HistogramProperties}
       * @return {Histogram}
       */
      histogram(name, properties) {
        this._validateName(name);
        let histogram;
        this._getMetricForNameAndType(name, MetricTypes.HISTOGRAM).ifPresentOrElse(
          (registeredMetric) => {
            histogram = registeredMetric;
          },
          () => {
            histogram = new Histogram(properties);
            this.register(name, histogram);
          }
        );
        return histogram;
      }
      /**
       * Gets or creates and registers a {@link Timer}
       * @param {string} name The metric name
       * @param {TimerProperties} [properties] See {@link TimerProperties}
       * @return {Timer}
       */
      timer(name, properties) {
        this._validateName(name);
        let timer;
        this._getMetricForNameAndType(name, MetricTypes.TIMER).ifPresentOrElse(
          (registeredMetric) => {
            timer = registeredMetric;
          },
          () => {
            timer = new Timer(properties);
            this.register(name, timer);
          }
        );
        return timer;
      }
      /**
       * Gets or creates and registers a {@link Meter}
       * @param {string} name The metric name
       * @param {MeterProperties} [properties] See {@link MeterProperties}
       * @return {Meter}
       */
      meter(name, properties) {
        this._validateName(name);
        let meter;
        this._getMetricForNameAndType(name, MetricTypes.METER).ifPresentOrElse(
          (registeredMetric) => {
            meter = registeredMetric;
          },
          () => {
            meter = new Meter(properties);
            this.register(name, meter);
          }
        );
        return meter;
      }
      /**
       * Gets or creates and registers a {@link SettableGauge}
       * @param {string} name The metric name
       * @param {SettableGaugeProperties} [properties] See {@link SettableGaugeProperties}
       * @return {SettableGauge}
       */
      settableGauge(name, properties) {
        this._validateName(name);
        let settableGauge;
        this._getMetricForNameAndType(name, MetricTypes.GAUGE).ifPresentOrElse(
          (registeredMetric) => {
            settableGauge = registeredMetric;
          },
          () => {
            settableGauge = new SettableGauge(properties);
            this.register(name, settableGauge);
          }
        );
        return settableGauge;
      }
      /**
       * Gets or creates and registers a {@link SettableGauge}
       * @param {string} name The metric name
       * @param {function} valueProducingPromiseCallback A function that returns a promise than when
       * resolved supplies the value that should be cached in this gauge.
       * @param {number} updateIntervalInSeconds How often the cached gauge should update it's value.
       * @return {CachedGauge}
       */
      cachedGauge(name, valueProducingPromiseCallback, updateIntervalInSeconds) {
        this._validateName(name);
        let cachedGauge;
        this._getMetricForNameAndType(name, MetricTypes.GAUGE).ifPresentOrElse(
          (registeredMetric) => {
            cachedGauge = registeredMetric;
          },
          () => {
            cachedGauge = new CachedGauge(valueProducingPromiseCallback, updateIntervalInSeconds);
            this.register(name, cachedGauge);
          }
        );
        return cachedGauge;
      }
      /**
       * Checks the registry for a metric with a given name and type, if it exists in the registry as a
       * different type an error is thrown.
       * @param {string} name The metric name
       * @param {string} requestedType The metric type
       * @return {Optional<Metric>}
       * @private
       */
      _getMetricForNameAndType(name, requestedType) {
        if (this._metrics[name]) {
          const metric = this._metrics[name];
          const actualType = metric.getType();
          if (requestedType !== actualType) {
            throw new Error(
              `You requested a metric of type: ${requestedType} with name: ${name}, but it exists in the registry as type: ${actualType}`
            );
          }
          return Optional.of(metric);
        }
        return Optional.empty();
      }
      /**
       * Validates that the provided name is valid.
       *
       * @param name The provided metric name param.
       * @private
       */
      _validateName(name) {
        if (!name || typeof name !== "string") {
          throw new Error("You must supply a metric name");
        }
      }
      /**
       * Calls end on all metrics in the registry that support end()
       */
      end() {
        const metrics2 = this._metrics;
        Object.keys(metrics2).forEach((name) => {
          const metric = metrics2[name];
          if (metric.end) {
            metric.end();
          }
        });
      }
    };
    module2.exports = Collection;
  }
});

// node_modules/measured-core/lib/metrics/NoOpMeter.js
var require_NoOpMeter = __commonJS({
  "node_modules/measured-core/lib/metrics/NoOpMeter.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var NoOpMeter = class {
      /**
       * No-Op impl
       * @param {number} n Number of events to mark.
       */
      // eslint-disable-next-line no-unused-vars
      mark(n) {
      }
      /**
       * No-Op impl
       */
      start() {
      }
      /**
       * No-Op impl
       */
      end() {
      }
      /**
       * No-Op impl
       */
      ref() {
      }
      /**
       * No-Op impl
       */
      unref() {
      }
      /**
       * No-Op impl
       */
      reset() {
      }
      /**
       * No-Op impl
       */
      meanRate() {
      }
      /**
       * No-Op impl
       */
      currentRate() {
      }
      /**
       * Returns an empty object
       * @return {{}}
       */
      toJSON() {
        return {};
      }
      /**
       * The type of the Metric Impl. {@link MetricTypes}.
       * @return {string} The type of the Metric Impl.
       */
      getType() {
        return MetricTypes.METER;
      }
    };
    module2.exports = NoOpMeter;
  }
});

// node_modules/measured-core/lib/validators/metricValidators.js
var require_metricValidators = __commonJS({
  "node_modules/measured-core/lib/validators/metricValidators.js"(exports2, module2) {
    var { MetricTypes } = require_Metric();
    var metricTypeValues = Object.keys(MetricTypes).map((key) => MetricTypes[key]);
    module2.exports = {
      /**
       * Validates that a metric implements the metric interface.
       *
       * @param {Metric} metric The object that is supposed to be a metric.
       */
      validateMetric: (metric) => {
        if (!metric) {
          throw new TypeError("The metric was undefined, when it was required");
        }
        if (typeof metric.toJSON !== "function") {
          throw new TypeError("Metrics must implement toJSON(), see the Metric interface in the docs.");
        }
        if (typeof metric.getType !== "function") {
          throw new TypeError("Metrics must implement getType(), see the Metric interface in the docs.");
        }
        const type = metric.getType();
        if (!metricTypeValues.includes(type)) {
          throw new TypeError(
            `Metric#getType(), must return a type defined in MetricsTypes. Found: ${type}, Valid values: ${metricTypeValues.join(
              ", "
            )}`
          );
        }
      }
    };
  }
});

// node_modules/measured-core/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/measured-core/lib/index.js"(exports2, module2) {
    var Collection = require_Collection();
    var Counter = require_Counter();
    var Gauge = require_Gauge();
    var SettableGauge = require_SettableGauge();
    var CachedGauge = require_CachedGauge();
    var Histogram = require_Histogram();
    var Meter = require_Meter();
    var NoOpMeter = require_NoOpMeter();
    var Timer = require_Timer();
    var BinaryHeap = require_BinaryHeap();
    var ExponentiallyDecayingSample = require_ExponentiallyDecayingSample();
    var ExponentiallyMovingWeightedAverage = require_ExponentiallyMovingWeightedAverage();
    var Stopwatch = require_Stopwatch();
    var units = require_units();
    var { MetricTypes } = require_Metric();
    var metricValidators = require_metricValidators();
    module2.exports = {
      /**
       * See {@link Collection}
       * @type {Collection}
       */
      Collection,
      /**
       * See {@link Counter}
       * @type {Counter}
       */
      Counter,
      /**
       * See {@link Gauge}
       * @type {Gauge}
       */
      Gauge,
      /**
       * See {@link SettableGauge}
       * @type {SettableGauge}
       */
      SettableGauge,
      /**
       * See {@link CachedGauge}
       * @type {CachedGauge}
       */
      CachedGauge,
      /**
       * See {@link Histogram}
       * @type {Histogram}
       */
      Histogram,
      /**
       * See {@link Meter}
       * @type {Meter}
       */
      Meter,
      /**
       * See {@link NoOpMeter}
       * @type {NoOpMeter}
       */
      NoOpMeter,
      /**
       * See {@link Timer}
       * @type {Timer}
       */
      Timer,
      /**
       * See {@link BinaryHeap}
       * @type {BinaryHeap}
       */
      BinaryHeap,
      /**
       * See {@link ExponentiallyDecayingSample}
       * @type {ExponentiallyDecayingSample}
       */
      ExponentiallyDecayingSample,
      /**
       * See {@link ExponentiallyMovingWeightedAverage}
       * @type {ExponentiallyMovingWeightedAverage}
       */
      ExponentiallyMovingWeightedAverage,
      /**
       * See {@link Stopwatch}
       * @type {Stopwatch}
       */
      Stopwatch,
      /**
       * See {@link MetricTypes}
       * @type {MetricTypes}
       */
      MetricTypes,
      /**
       * See {@link units}
       * @type {units}
       */
      units,
      /**
       * See {@link units}
       * @type {units}
       */
      TimeUnits: units,
      /**
       * See {@link module:metricValidators}
       * @type {Object.<string, function>}
       */
      metricValidators,
      /**
       * Creates a named collection. See {@link Collection} for more details
       *
       * @param name The name for the collection
       * @return {Collection}
       */
      createCollection: (name) => {
        return new Collection(name);
      }
    };
  }
});

// node_modules/mapcap/index.js
var require_mapcap = __commonJS({
  "node_modules/mapcap/index.js"(exports2, module2) {
    var assert = require("assert");
    module2.exports = function mapcap(object, cap, lru = false) {
      assert.strictEqual(typeof cap, "number", "cap should be a number");
      assert.strictEqual(typeof lru, "boolean", "lru should be a boolean");
      let target = object;
      if (!(object instanceof Map)) {
        object = class Sub extends object {
        };
        target = object.prototype;
      }
      wrapSet(target, cap);
      if (lru) wrapGet(target);
      return object;
    };
    function wrapSet(target, cap) {
      shimmer(target, "set", (original) => {
        return function set(key, value) {
          const res = original.apply(this, arguments);
          if (this.size > cap) {
            this.delete(this.keys().next().value);
          }
          return res;
        };
      });
    }
    function wrapGet(target) {
      shimmer(target, "get", (original) => {
        return function get(key) {
          const value = original.apply(this, arguments);
          this.delete(key);
          this.set(key, value);
          return value;
        };
      });
    }
    function shimmer(obj, method, replacer) {
      obj[method] = replacer(obj[method]);
    }
  }
});

// node_modules/measured-reporting/lib/registries/DimensionAwareMetricsRegistry.js
var require_DimensionAwareMetricsRegistry = __commonJS({
  "node_modules/measured-reporting/lib/registries/DimensionAwareMetricsRegistry.js"(exports2, module2) {
    var mapcap = require_mapcap();
    var DimensionAwareMetricsRegistry = class {
      /**
       * @param {DimensionAwareMetricsRegistryOptions} [options] Configurable options for the Dimension Aware Metrics Registry
       */
      constructor(options) {
        options = options || {};
        let metrics2 = /* @__PURE__ */ new Map();
        if (options.metricLimit) {
          metrics2 = mapcap(metrics2, options.metricLimit, options.lru);
        }
        this._metrics = metrics2;
      }
      /**
       * Checks to see if a metric with the given name and dimensions is present.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The dimensions for the metric
       * @returns {boolean} true if the metric with given dimensions is present
       */
      hasMetric(name, dimensions) {
        const key = this._generateStorageKey(name, dimensions);
        return this._metrics.has(key);
      }
      /**
       * Retrieves a metric with a given name and dimensions is present.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The dimensions for the metric
       * @returns {Metric} a wrapper object around name, dimension and {@link Metric}
       */
      getMetric(name, dimensions) {
        const key = this._generateStorageKey(name, dimensions);
        return this._metrics.get(key).metricImpl;
      }
      /**
       * Retrieves a metric by the calculated key (name / dimension combo).
       *
       * @param {string} key The registered key for the given registered {@link MetricWrapper}
       * @returns {MetricWrapper} a wrapper object around name, dimension and {@link Metric}
       */
      getMetricWrapperByKey(key) {
        return this._metrics.get(key);
      }
      /**
       * Upserts a {@link Metric} in the internal storage map for a given name, dimension combo
       *
       * @param {string} name The metric name
       * @param {Metric} metric The {@link Metric} impl
       * @param {Dimensions} dimensions The dimensions for the metric
       * @return {string} The registry key for the metric, dimension combo
       */
      putMetric(name, metric, dimensions) {
        const key = this._generateStorageKey(name, dimensions);
        this._metrics.set(key, {
          name,
          metricImpl: metric,
          dimensions: dimensions || {}
        });
        return key;
      }
      /**
       * Returns an array of all keys of metrics stored in this registry.
       * @return {string[]} all keys of metrics stored in this registry.
       */
      allKeys() {
        return Array.from(this._metrics.keys());
      }
      /**
       * Generates a unique key off of the metric name and custom dimensions for internal use in the registry maps.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The dimensions for the metric
       * @return {string} a unique key based off of the metric nae and dimensions
       * @private
       */
      _generateStorageKey(name, dimensions) {
        let key = name;
        if (dimensions) {
          Object.keys(dimensions).sort().forEach((dimensionKey) => {
            key = `${key}-${dimensions[dimensionKey]}`;
          });
        }
        return key;
      }
    };
    module2.exports = DimensionAwareMetricsRegistry;
  }
});

// node_modules/measured-reporting/lib/validators/inputValidators.js
var require_inputValidators = __commonJS({
  "node_modules/measured-reporting/lib/validators/inputValidators.js"(exports2, module2) {
    var Optional = require_optional_js();
    var { validateMetric } = require_lib2().metricValidators;
    module2.exports = {
      /**
       * Validates @{link Gauge} options.
       *
       * @param {string} name The metric name
       * @param {function} callback The callback for the Gauge
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateGaugeOptions: (name, callback, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
        module2.exports.validateNumberReturningCallback(callback);
      },
      /**
       * Validates @{link Gauge} options.
       *
       * @param {string} name The metric name
       * @param {function} callback The callback for the CachedGauge
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateCachedGaugeOptions: (name, callback, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
      },
      /**
       * Validates the create histogram Options.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateHistogramOptions: (name, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
      },
      /**
       * Validates the create counter Options.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateCounterOptions: (name, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
      },
      /**
       * Validates the create timer Options.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateTimerOptions: (name, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
      },
      /**
       * Validates the create timer Options.
       *
       * @param {string} name The metric name
       * @param {Metric} metric The metric instance
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateRegisterOptions: (name, metric, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateMetric(metric);
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
      },
      /**
       * Validates the create settable gauge Options.
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateSettableGaugeOptions: (name, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateCommonMetricParameters(name, dimensions, publishingIntervalInSeconds);
      },
      /**
       * Validates the options that are common amoung all create metric methods
       *
       * @param {string} name The metric name
       * @param {Dimensions} dimensions The optional custom dimensions
       * @param {number} publishingIntervalInSeconds the optional publishing interval
       */
      validateCommonMetricParameters: (name, dimensions, publishingIntervalInSeconds) => {
        module2.exports.validateMetricName(name);
        module2.exports.validateOptionalDimensions(dimensions);
        module2.exports.validateOptionalPublishingInterval(publishingIntervalInSeconds);
      },
      /**
       * Validates the metric name.
       *
       * @param name The metric name.
       */
      validateMetricName: (name) => {
        const type = typeof name;
        if (type !== "string") {
          throw new TypeError(`options.name is a required option and must be of type string, actual type: ${type}`);
        }
      },
      /**
       * Validates that a metric implements the metric interface.
       *
       * @function
       * @name validateMetric
       * @param {Metric} metric The object that is supposed to be a metric.
       */
      validateMetric,
      /**
       * Validates the provided callback.
       *
       * @param callback The provided callback for a gauge.
       */
      validateNumberReturningCallback: (callback) => {
        const type = typeof callback;
        if (type !== "function") {
          throw new TypeError(`options.callback is a required option and must be function, actual type: ${type}`);
        }
        const callbackType = typeof callback();
        if (callbackType !== "number") {
          throw new TypeError(`options.callback must return a number, actual return type: ${callbackType}`);
        }
      },
      /**
       * Validates a set of optional dimensions
       * @param dimensionsOptional
       */
      validateOptionalDimensions: (dimensionsOptional) => {
        Optional.ofNullable(dimensionsOptional).ifPresent((dimensions) => {
          const type = typeof dimensions;
          if (type !== "object") {
            throw new TypeError(`options.dimensions should be an object, actual type: ${type}`);
          }
          if (Array.isArray(dimensions)) {
            throw new TypeError("dimensions where detected to be an array, expected Object<string, string>");
          }
          Object.keys(dimensions).forEach((key) => {
            const valueType = typeof dimensions[key];
            if (valueType !== "string") {
              throw new TypeError(`options.dimensions.${key} should be of type string, actual type: ${type}`);
            }
          });
        });
      },
      /**
       * Validates that an optional logger instance at least has the methods we expect.
       * @param loggerOptional
       */
      validateOptionalLogger: (loggerOptional) => {
        Optional.ofNullable(loggerOptional).ifPresent((logger) => {
          if (typeof logger.debug !== "function" || typeof logger.info !== "function" || typeof logger.warn !== "function" || typeof logger.error !== "function") {
            throw new TypeError(
              "The logger that was passed in does not support all required logging methods, expected object to have functions debug, info, warn, and error with method signatures (...msgs) => {}"
            );
          }
        });
      },
      /**
       * Validates the optional publishing interval.
       *
       * @param publishingIntervalInSecondsOptional The optional publishing interval.
       */
      validateOptionalPublishingInterval: (publishingIntervalInSecondsOptional) => {
        Optional.ofNullable(publishingIntervalInSecondsOptional).ifPresent((publishingIntervalInSeconds) => {
          const type = typeof publishingIntervalInSeconds;
          if (type !== "number") {
            throw new TypeError(`options.publishingIntervalInSeconds must be of type number, actual type: ${type}`);
          }
        });
      },
      /**
       * Validates optional params for a Reporter
       * @param {ReporterOptions} options The optional params
       */
      validateReporterParameters: (options) => {
        if (options) {
          module2.exports.validateOptionalDimensions(options.defaultDimensions);
          module2.exports.validateOptionalLogger(options.logger);
          const type = typeof options.unrefTimers;
          if (type !== "boolean" && type !== "undefined") {
            throw new TypeError(`options.unrefTimers should be a boolean or undefined, actual type: ${type}`);
          }
        }
      },
      /**
       * Validates that a valid Reporter object has been supplied
       *
       * @param {Reporter} reporter
       */
      validateReporterInstance: (reporter) => {
        if (!reporter) {
          throw new TypeError("The reporter was undefined, when it was required");
        }
        if (typeof reporter.setRegistry !== "function") {
          throw new TypeError(
            "A reporter must implement setRegistry(registry), see the abstract Reporter class in the docs."
          );
        }
        if (typeof reporter.reportMetricOnInterval !== "function") {
          throw new TypeError(
            "A reporter must implement reportMetricOnInterval(metricKey, intervalInSeconds), see the abstract Reporter class in the docs."
          );
        }
      },
      /**
       * Validates the input parameters for a {@link SelfReportingMetricsRegistry}
       * @param {Reporter[]} reporters
       * @param {SelfReportingMetricsRegistryOptions} [options]
       */
      validateSelfReportingMetricsRegistryParameters: (reporters, options) => {
        reporters.forEach((reporter) => module2.exports.validateReporterInstance(reporter));
        if (options) {
          module2.exports.validateOptionalLogger(options.logger);
        }
      }
    };
  }
});

// node_modules/measured-reporting/lib/registries/SelfReportingMetricsRegistry.js
var require_SelfReportingMetricsRegistry = __commonJS({
  "node_modules/measured-reporting/lib/registries/SelfReportingMetricsRegistry.js"(exports2, module2) {
    var consoleLogLevel = require_console_log_level();
    var { CachedGauge, SettableGauge, Gauge, Timer, Counter, Meter, Histogram } = require_lib2();
    var DimensionAwareMetricsRegistry = require_DimensionAwareMetricsRegistry();
    var {
      validateSelfReportingMetricsRegistryParameters,
      validateRegisterOptions,
      validateGaugeOptions,
      validateCounterOptions,
      validateHistogramOptions,
      validateTimerOptions,
      validateSettableGaugeOptions,
      validateCachedGaugeOptions
    } = require_inputValidators();
    function prefix() {
      return `${(/* @__PURE__ */ new Date()).toISOString()}: `;
    }
    var SelfReportingMetricsRegistry = class {
      /**
       * @param {Reporter|Reporter[]} reporters A single {@link Reporter} or an array of reporters that will be used to report metrics on an interval.
       * @param {SelfReportingMetricsRegistryOptions} [options] Configurable options for the Self Reporting Metrics Registry
       */
      constructor(reporters, options) {
        options = options || {};
        if (!Array.isArray(reporters)) {
          reporters = [reporters];
        }
        validateSelfReportingMetricsRegistryParameters(reporters, options);
        this._reporters = reporters;
        this._registry = options.registry || new DimensionAwareMetricsRegistry();
        this._reporters.forEach((reporter) => reporter.setRegistry(this._registry));
        this._log = options.logger || consoleLogLevel({ name: "SelfReportingMetricsRegistry", level: options.logLevel || "info", prefix });
      }
      /**
       * Registers a manually created Metric.
       *
       * @param {string} name The Metric name
       * @param {Metric} metric The {@link Metric} to register
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @example
       * const settableGauge = new SettableGauge(5);
       * // register the gauge and have it report to every 10 seconds
       * registry.register('my-gauge', settableGauge, {}, 10);
       * interval(() => {
       *    // such as cpu % used
       *    determineAValueThatCannotBeSync((value) => {
       *      settableGauge.update(value);
       *    })
       * }, 10000)
       */
      register(name, metric, dimensions, publishingIntervalInSeconds) {
        validateRegisterOptions(name, metric, dimensions, publishingIntervalInSeconds);
        if (this._registry.hasMetric(name, dimensions)) {
          throw new Error(
            `Metric with name: ${name} and dimensions: ${JSON.stringify(dimensions)} has already been registered`
          );
        } else {
          const key = this._registry.putMetric(name, metric, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return metric;
      }
      /**
       * Creates a {@link Gauge} or gets the existing Gauge for a given name and dimension combo
       *
       * @param {string} name The Metric name
       * @param {function} callback The callback that will return a value to report to signal fx
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @return {Gauge}
       * @example
       * // https://nodejs.org/api/process.html#process_process_memoryusage
       * // Report heap total and heap used at the default interval
       * registry.getOrCreateGauge(
       *   'process-memory-heap-total',
       *   () => {
       *     return process.memoryUsage().heapTotal
       *   }
       * );
       * registry.getOrCreateGauge(
       *   'process-memory-heap-used',
       *   () => {
       *     return process.memoryUsage().heapUsed
       *   }
       * )
       */
      getOrCreateGauge(name, callback, dimensions, publishingIntervalInSeconds) {
        validateGaugeOptions(name, callback, dimensions, publishingIntervalInSeconds);
        let gauge;
        if (this._registry.hasMetric(name, dimensions)) {
          gauge = this._registry.getMetric(name, dimensions);
        } else {
          gauge = new Gauge(callback);
          const key = this._registry.putMetric(name, gauge, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return gauge;
      }
      /**
       * Creates a {@link Histogram} or gets the existing Histogram for a given name and dimension combo
       *
       * @param {string} name The Metric name
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @return {Histogram}
       */
      getOrCreateHistogram(name, dimensions, publishingIntervalInSeconds) {
        validateHistogramOptions(name, dimensions, publishingIntervalInSeconds);
        let histogram;
        if (this._registry.hasMetric(name, dimensions)) {
          histogram = this._registry.getMetric(name, dimensions);
        } else {
          histogram = new Histogram();
          const key = this._registry.putMetric(name, histogram, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return histogram;
      }
      /**
       * Creates a {@link Meter} or gets the existing Meter for a given name and dimension combo
       *
       * @param {string} name The Metric name
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @return {Meter}
       */
      getOrCreateMeter(name, dimensions, publishingIntervalInSeconds) {
        let meter;
        if (this._registry.hasMetric(name, dimensions)) {
          meter = this._registry.getMetric(name, dimensions);
        } else {
          meter = new Meter();
          const key = this._registry.putMetric(name, meter, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return meter;
      }
      /**
       * Creates a {@link Counter} or gets the existing Counter for a given name and dimension combo
       *
       * @param {string} name The Metric name
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @return {Counter}
       */
      getOrCreateCounter(name, dimensions, publishingIntervalInSeconds) {
        validateCounterOptions(name, dimensions, publishingIntervalInSeconds);
        let counter;
        if (this._registry.hasMetric(name, dimensions)) {
          counter = this._registry.getMetric(name, dimensions);
        } else {
          counter = new Counter();
          const key = this._registry.putMetric(name, counter, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return counter;
      }
      /**
       * Creates a {@link Timer} or gets the existing Timer for a given name and dimension combo.
       *
       * @param {string} name The Metric name
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @return {Timer}
       */
      getOrCreateTimer(name, dimensions, publishingIntervalInSeconds) {
        validateTimerOptions(name, dimensions, publishingIntervalInSeconds);
        let timer;
        if (this._registry.hasMetric(name, dimensions)) {
          timer = this._registry.getMetric(name, dimensions);
        } else {
          timer = new Timer();
          const key = this._registry.putMetric(name, timer, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return timer;
      }
      /**
       * Creates a {@link SettableGauge} or gets the existing SettableGauge for a given name and dimension combo.
       *
       * @param {string} name The Metric name
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval
       * @return {SettableGauge}
       */
      getOrCreateSettableGauge(name, dimensions, publishingIntervalInSeconds) {
        validateSettableGaugeOptions(name, dimensions, publishingIntervalInSeconds);
        let settableGauge;
        if (this._registry.hasMetric(name, dimensions)) {
          settableGauge = this._registry.getMetric(name, dimensions);
        } else {
          settableGauge = new SettableGauge();
          const key = this._registry.putMetric(name, settableGauge, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return settableGauge;
      }
      /**
       * Creates a {@link CachedGauge} or gets the existing CachedGauge for a given name and dimension combo.
       *
       * @param {string} name The Metric name.
       * @param {function} valueProducingPromiseCallback.
       * @param {number} cachedGaugeUpdateIntervalInSeconds.
       * @param {Dimensions} [dimensions] any custom {@link Dimensions} for the Metric.
       * @param {number} [publishingIntervalInSeconds] a optional custom publishing interval.
       * @return {CachedGauge}
       */
      getOrCreateCachedGauge(name, valueProducingPromiseCallback, cachedGaugeUpdateIntervalInSeconds, dimensions, publishingIntervalInSeconds) {
        validateCachedGaugeOptions(name, valueProducingPromiseCallback, dimensions, publishingIntervalInSeconds);
        let cachedGauge;
        if (this._registry.hasMetric(name, dimensions)) {
          cachedGauge = this._registry.getMetric(name, dimensions);
        } else {
          cachedGauge = new CachedGauge(valueProducingPromiseCallback, cachedGaugeUpdateIntervalInSeconds);
          const key = this._registry.putMetric(name, cachedGauge, dimensions);
          this._reporters.forEach((reporter) => reporter.reportMetricOnInterval(key, publishingIntervalInSeconds));
        }
        return cachedGauge;
      }
      /**
       * Calls end on all metrics in the registry that support end() and calls end on the reporter
       */
      shutdown() {
        this._reporters.forEach((reporter) => reporter.shutdown());
        this._registry.allKeys().forEach((key) => {
          const metricWrapper = this._registry.getMetricWrapperByKey(key);
          if (metricWrapper.metricImpl.end) {
            metricWrapper.metricImpl.end();
          }
        });
      }
    };
    module2.exports = SelfReportingMetricsRegistry;
  }
});

// node_modules/measured-reporting/lib/reporters/Reporter.js
var require_Reporter = __commonJS({
  "node_modules/measured-reporting/lib/reporters/Reporter.js"(exports2, module2) {
    var consoleLogLevel = require_console_log_level();
    var Optional = require_optional_js();
    var { validateReporterParameters } = require_inputValidators();
    var DEFAULT_REPORTING_INTERVAL_IN_SECONDS = 10;
    function prefix() {
      return `${(/* @__PURE__ */ new Date()).toISOString()}: `;
    }
    var Reporter = class _Reporter {
      /**
       * @param {ReporterOptions} [options] The optional params to supply when creating a reporter.
       */
      constructor(options) {
        if (this.constructor === _Reporter) {
          throw new TypeError("Can't instantiate abstract class!");
        }
        options = options || {};
        validateReporterParameters(options);
        this._intervalToMetric = {};
        this._intervals = [];
        this._defaultDimensions = options.defaultDimensions || {};
        this._log = options.logger || consoleLogLevel({ name: "Reporter", level: options.logLevel || "info", prefix });
        this._defaultReportingIntervalInSeconds = options.defaultReportingIntervalInSeconds || DEFAULT_REPORTING_INTERVAL_IN_SECONDS;
        this._unrefTimers = !!options.unrefTimers;
        this._resetMetricsOnInterval = !!options.resetMetricsOnInterval;
      }
      /**
       * Sets the registry, this must be called before reportMetricOnInterval.
       *
       * @param {DimensionAwareMetricsRegistry} registry
       */
      setRegistry(registry) {
        this._registry = registry;
      }
      /**
       * Informs the reporter to report a metric on a given interval in seconds.
       *
       * @param {string} metricKey The metric key for the metric in the metric registry.
       * @param {number} intervalInSeconds The interval in seconds to report the metric on.
       */
      reportMetricOnInterval(metricKey, intervalInSeconds) {
        intervalInSeconds = intervalInSeconds || this._defaultReportingIntervalInSeconds;
        if (!this._registry) {
          throw new Error(
            "You must call setRegistry(registry) before telling a Reporter to report a metric on an interval."
          );
        }
        if (Object.prototype.hasOwnProperty.call(this._intervalToMetric, intervalInSeconds)) {
          this._intervalToMetric[intervalInSeconds].add(metricKey);
        } else {
          this._intervalToMetric[intervalInSeconds] = /* @__PURE__ */ new Set([metricKey]);
          this._createIntervalCallback(intervalInSeconds);
          setImmediate(() => {
            this._reportMetricsWithInterval(intervalInSeconds);
          });
        }
      }
      /**
       * Creates the timed callback loop for the given interval.
       *
       * @param {number} intervalInSeconds the interval in seconds for the timeout callback
       * @private
       */
      _createIntervalCallback(intervalInSeconds) {
        this._log.debug(`_createIntervalCallback() called with intervalInSeconds: ${intervalInSeconds}`);
        const timer = setInterval(() => {
          this._reportMetricsWithInterval(intervalInSeconds);
        }, intervalInSeconds * 1e3);
        if (this._unrefTimers) {
          timer.unref();
        }
        this._intervals.push(timer);
      }
      /**
       * Gathers all the metrics that have been registered to report on the given interval.
       *
       * @param {number} interval The interval to look up what metrics to report
       * @private
       */
      _reportMetricsWithInterval(interval) {
        this._log.debug(`_reportMetricsWithInterval() called with intervalInSeconds: ${interval}`);
        try {
          Optional.of(this._intervalToMetric[interval]).ifPresent((metrics2) => {
            const metricsToSend = [];
            metrics2.forEach((metricKey) => {
              metricsToSend.push(this._registry.getMetricWrapperByKey(metricKey));
            });
            this._reportMetrics(metricsToSend);
            if (this._resetMetricsOnInterval) {
              metricsToSend.forEach(({ name, metricImpl }) => {
                if (metricImpl && metricImpl.reset) {
                  this._log.debug("Resetting metric", name);
                  metricImpl.reset();
                }
              });
            }
          });
        } catch (error) {
          this._log.error("Failed to send metrics to signal fx", error);
        }
      }
      /**
       * This method gets called with an array of {@link MetricWrapper} on an interval, when metrics should be reported.
       *
       * This is the main method that needs to get implemented when created an aggregator specific reporter.
       *
       * @param {MetricWrapper[]} metrics The array of metrics to report.
       * @protected
       * @abstract
       */
      _reportMetrics(metrics2) {
        throw new TypeError("Abstract method _reportMetrics(metrics) must be implemented in implementation class");
      }
      /**
       *
       * @param {MetricWrapper} metric The Wrapped Metric Object.
       * @return {Dimensions} The left merged default dimensions with the metric specific dimensions
       * @protected
       */
      _getDimensions(metric) {
        return Object.assign({}, this._defaultDimensions, metric.dimensions);
      }
      /**
       * Clears the intervals that are running to report metrics at an interval, and resets the state.
       */
      shutdown() {
        this._intervals.forEach((interval) => clearInterval(interval));
        this._intervals = [];
        this._intervalToMetric = {};
      }
    };
    module2.exports = Reporter;
  }
});

// node_modules/measured-reporting/lib/reporters/LoggingReporter.js
var require_LoggingReporter = __commonJS({
  "node_modules/measured-reporting/lib/reporters/LoggingReporter.js"(exports2, module2) {
    var Reporter = require_Reporter();
    var LoggingReporter = class extends Reporter {
      /**
       * @param {LoggingReporterOptions} [options]
       */
      constructor(options) {
        super(options);
        const level = (options || {}).logLevelToLogAt;
        this._logLevel = (level || "info").toLowerCase();
      }
      /**
       * Logs the metrics via the inherited logger instance.
       * @param {MetricWrapper[]} metrics
       * @protected
       */
      _reportMetrics(metrics2) {
        metrics2.forEach((metric) => {
          this._log[this._logLevel](
            JSON.stringify({
              metricName: metric.name,
              dimensions: this._getDimensions(metric),
              data: metric.metricImpl.toJSON()
            })
          );
        });
      }
    };
    module2.exports = LoggingReporter;
  }
});

// node_modules/measured-reporting/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/measured-reporting/lib/index.js"(exports2, module2) {
    var SelfReportingMetricsRegistry = require_SelfReportingMetricsRegistry();
    var Reporter = require_Reporter();
    var LoggingReporter = require_LoggingReporter();
    var inputValidators = require_inputValidators();
    module2.exports = {
      /**
       * The Self Reporting Metrics Registry Class.
       *
       * @type {SelfReportingMetricsRegistry}
       */
      SelfReportingMetricsRegistry,
      /**
       * The abstract / base Reporter class.
       *
       * @type {Reporter}
       */
      Reporter,
      /**
       * The basic included reference reporter, simply logs the metrics.
       * See {ReporterOptions} for options.
       *
       * @type {LoggingReporter}
       */
      LoggingReporter,
      /**
       * Various Input Validation functions.
       *
       * @type {inputValidators}
       */
      inputValidators
    };
  }
});

// node_modules/after-all-results/index.js
var require_after_all_results = __commonJS({
  "node_modules/after-all-results/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(done) {
      var cbCount = 0;
      var results = [];
      var error, called;
      process.nextTick(function() {
        if (!called) done(null, results);
      });
      return function(callback) {
        called = true;
        var index = cbCount++;
        return function(err, result) {
          if (callback) callback.apply(null, arguments);
          if (err && !error) error = err;
          results[index] = result;
          process.nextTick(function() {
            if (!--cbCount) done(error, results);
          });
        };
      };
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/reporter.js
var require_reporter = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/reporter.js"(exports2, module2) {
    "use strict";
    var afterAll = require_after_all_results();
    var { Reporter } = require_lib3();
    var ObjectIdentityMap = require_object_identity_map();
    var MetricsReporter = class extends Reporter {
      constructor(agent, options = {}) {
        super(options);
        this.enabled = options.enabled;
        this._agent = agent;
        if (!this.enabled) {
          this.shutdown();
        }
      }
      _reportMetrics(metrics2) {
        if (!this.enabled) return;
        const baseDimensions = {
          timestamp: Date.now() * 1e3,
          tags: this._getDimensions(metrics2)
        };
        const next = afterAll(() => {
          const seen = new ObjectIdentityMap();
          for (const metric of metrics2) {
            if (!metric) continue;
            if (this._agent._isMetricNameDisabled(metric.name)) {
              continue;
            }
            if (this.isStaleMetric(metric)) {
              this.removeMetricFromRegistry(metric, this._registry);
              continue;
            }
            const data = seen.ensure(metric.dimensions, () => {
              const metricData = unflattenBreakdown(metric.dimensions);
              const merged = Object.assign(
                { samples: {} },
                baseDimensions,
                metricData
              );
              Object.assign(merged.tags, baseDimensions.tags, metricData.tags);
              return merged;
            });
            data.samples[metric.name] = {
              value: metric.metricImpl.toJSON()
            };
            if (metric.metricImpl.constructor.name === "Counter") {
              metric.metricImpl.reset();
            }
          }
          if (this._agent._apmClient) {
            for (const metric of seen.values()) {
              this._agent._apmClient.sendMetricSet(metric);
            }
          }
        });
        for (const collector of this._registry.collectors) {
          collector.collect(next());
        }
      }
      isStaleMetric(metric) {
        if (metric.metricImpl && metric.metricImpl._count === 0) {
          return true;
        }
        return false;
      }
      removeMetricFromRegistry(metric) {
        if (!this._registry || !this._registry._metrics) {
          return;
        }
        const key = this._registry._generateStorageKey(
          metric.name,
          metric.dimensions
        );
        return this._registry._metrics.delete(key);
      }
    };
    module2.exports = MetricsReporter;
    function unflattenBreakdown(source) {
      const target = {
        tags: {}
      };
      for (const [key, value] of Object.entries(source)) {
        if (key.includes("::")) {
          const [parent, child] = key.split("::");
          if (!target[parent]) target[parent] = {};
          target[parent][child] = value;
        } else {
          target.tags[key] = value;
        }
      }
      return target;
    }
  }
});

// node_modules/monitor-event-loop-delay/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/monitor-event-loop-delay/polyfill.js"(exports2, module2) {
    "use strict";
    function toNano(t) {
      return t[0] * 1e9 + t[1];
    }
    function sumReducer(last, next) {
      return last + next;
    }
    function sortNumber(a, b) {
      a = Number.isNaN(a) ? Number.NEGATIVE_INFINITY : a;
      b = Number.isNaN(b) ? Number.NEGATIVE_INFINITY : b;
      if (a > b) return 1;
      if (a < b) return -1;
      return 0;
    }
    function descriptor(target, property, data) {
      Object.defineProperty(target, property, data);
    }
    function define2(target, property, value) {
      descriptor(target, property, { value });
    }
    function mean(list) {
      return list.reduce(sumReducer, 0) / list.length;
    }
    var EventLoopDelayHistogram = class {
      constructor({ resolution = 10 } = {}) {
        define2(this, "resolution", resolution);
        descriptor(this, "timer", { writable: true });
        descriptor(this, "samples", { writable: true, value: [] });
      }
      get stddev() {
        const avg = mean(this.samples);
        const squareDiffs = this.samples.map((value) => {
          const diff = value - avg;
          const sqrDiff = diff * diff;
          return sqrDiff;
        });
        return Math.sqrt(mean(squareDiffs));
      }
      get mean() {
        return mean(this.samples);
      }
      get min() {
        return Math.min(9223372036854776e3, ...this.samples);
      }
      get max() {
        return Math.max(0, ...this.samples);
      }
      get percentiles() {
        const map = /* @__PURE__ */ new Map();
        let last = 0;
        if (this.samples.length) {
          map.set(0, this.percentile(0));
          for (let percent = 50; percent < 100; percent += (100 - percent) / 2) {
            const next = this.percentile(percent);
            if (last === next) break;
            map.set(percent, next);
            last = next;
          }
        }
        map.set(100, this.percentile(100));
        return map;
      }
      percentile(percent) {
        percent = Number(percent);
        if (isNaN(percent) || percent < 0 || percent > 100) {
          throw new TypeError("Percent must be a floating point number between 0 and 100");
        }
        const list = this.samples.sort(sortNumber);
        if (percent === 0) return list[0];
        return list[Math.ceil(list.length * (percent / 100)) - 1] || 0;
      }
      enable() {
        if (this.timer) return false;
        let last = process.hrtime();
        this.timer = setInterval(() => {
          const next = process.hrtime(last);
          this.samples.push(Math.max(0, toNano(next)));
          last = process.hrtime();
        }, this.resolution);
        this.timer.unref();
        return true;
      }
      disable() {
        if (!this.timer) return false;
        clearInterval(this.timer);
        this.timer = null;
        return true;
      }
      reset() {
        this.samples = [];
      }
    };
    var proto = EventLoopDelayHistogram.prototype;
    descriptor(proto, "stddev", { enumerable: true });
    descriptor(proto, "mean", { enumerable: true });
    descriptor(proto, "min", { enumerable: true });
    descriptor(proto, "max", { enumerable: true });
    module2.exports = EventLoopDelayHistogram;
  }
});

// node_modules/monitor-event-loop-delay/index.js
var require_monitor_event_loop_delay = __commonJS({
  "node_modules/monitor-event-loop-delay/index.js"(exports2, module2) {
    try {
      const perfHooks = require("perf_hooks");
      if (typeof perfHooks.monitorEventLoopDelay !== "function") {
        throw new Error("No builtin event loop monitor");
      }
      module2.exports = (opts) => perfHooks.monitorEventLoopDelay(opts);
    } catch (err) {
      const EventLoopDelayHistogram = require_polyfill2();
      module2.exports = (opts) => new EventLoopDelayHistogram(opts);
    }
  }
});

// node_modules/elastic-apm-node/lib/metrics/runtime.js
var require_runtime = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/runtime.js"(exports2, module2) {
    "use strict";
    var eventLoopMonitor = require_monitor_event_loop_delay();
    var activeHandles = typeof process._getActiveHandles === "function" ? process._getActiveHandles.bind(process) : () => [];
    var activeRequests = typeof process._getActiveRequests === "function" ? process._getActiveRequests.bind(process) : () => [];
    var eventLoopMonitorResolution = 10;
    var RuntimeCollector = class {
      constructor() {
        this.stats = {
          "nodejs.handles.active": 0,
          "nodejs.requests.active": 0,
          "nodejs.eventloop.delay.avg.ms": 0,
          "nodejs.memory.heap.allocated.bytes": 0,
          "nodejs.memory.heap.used.bytes": 0,
          "nodejs.memory.external.bytes": 0,
          "nodejs.memory.arrayBuffers.bytes": 0
        };
        const monitor = eventLoopMonitor({
          resolution: eventLoopMonitorResolution
        });
        monitor.enable();
        this.loopMonitor = monitor;
        this.collect();
      }
      collect(cb) {
        this.stats["nodejs.handles.active"] = activeHandles().length;
        this.stats["nodejs.requests.active"] = activeRequests().length;
        const loopDelay = Math.max(
          0,
          (this.loopMonitor.mean || 0) / 1e6 - eventLoopMonitorResolution
        );
        this.stats["nodejs.eventloop.delay.avg.ms"] = loopDelay;
        this.loopMonitor.reset();
        const memoryUsage = process.memoryUsage();
        this.stats["nodejs.memory.heap.allocated.bytes"] = memoryUsage.heapTotal;
        this.stats["nodejs.memory.heap.used.bytes"] = memoryUsage.heapUsed;
        this.stats["nodejs.memory.external.bytes"] = memoryUsage.external;
        this.stats["nodejs.memory.arrayBuffers.bytes"] = memoryUsage.arrayBuffers || 0;
        if (cb) process.nextTick(cb);
      }
    };
    module2.exports = function createRuntimeMetrics(registry) {
      const collector = new RuntimeCollector();
      registry.registerCollector(collector);
      for (const metric of Object.keys(collector.stats)) {
        registry.getOrCreateGauge(metric, () => collector.stats[metric]);
      }
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/linux/stats.js
var require_stats = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/linux/stats.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var afterAll = require_after_all_results();
    var whitespace = /\s+/;
    var Stats = class {
      constructor(opts) {
        opts = opts || {};
        this.files = {
          processFile: opts.processFile || "/proc/self/stat",
          memoryFile: opts.memoryFile || "/proc/meminfo",
          cpuFile: opts.cpuFile || "/proc/stat"
        };
        this.previous = {
          cpuTotal: 0,
          cpuUsage: 0,
          memTotal: 0,
          memAvailable: 0,
          utime: 0,
          stime: 0,
          vsize: 0,
          rss: 0
        };
        this.stats = {
          "system.cpu.total.norm.pct": 0,
          "system.memory.actual.free": 0,
          "system.memory.total": 0,
          "system.process.cpu.total.norm.pct": 0,
          "system.process.cpu.system.norm.pct": 0,
          "system.process.cpu.user.norm.pct": 0,
          "system.process.memory.size": 0,
          "system.process.memory.rss.bytes": 0
        };
        this.inProgress = false;
        this.timer = null;
        const files = [
          this.files.processFile,
          this.files.memoryFile,
          this.files.cpuFile
        ];
        try {
          const datas = files.map(readFileSync);
          this.previous = this.readStats(datas);
          this.update(datas);
        } catch (err) {
        }
      }
      toJSON() {
        return this.stats;
      }
      collect(cb) {
        if (this.inProgress) {
          if (cb) process.nextTick(cb);
          return;
        }
        this.inProgress = true;
        const files = [
          this.files.processFile,
          this.files.memoryFile,
          this.files.cpuFile
        ];
        const next = afterAll((err, files2) => {
          if (!err) this.update(files2);
          if (cb) cb();
        });
        for (const file of files) {
          fs.readFile(file, next());
        }
      }
      readStats([processFile, memoryFile, cpuFile]) {
        const cpuLine = firstLineOfBufferAsString(cpuFile);
        const cpuTimes = cpuLine.split(whitespace);
        let cpuTotal = 0;
        for (let i = 1; i < cpuTimes.length; i++) {
          cpuTotal += Number(cpuTimes[i]);
        }
        const idle = Number(cpuTimes[4]);
        const iowait = Number(cpuTimes[5]);
        const cpuUsage = cpuTotal - idle - iowait;
        let memAvailable = 0;
        let memTotal = 0;
        let matches = 0;
        for (const line of memoryFile.toString().split("\n")) {
          if (/^MemAvailable:/.test(line)) {
            memAvailable = parseInt(line.split(whitespace)[1], 10) * 1024;
            matches++;
          } else if (/^MemTotal:/.test(line)) {
            memTotal = parseInt(line.split(whitespace)[1], 10) * 1024;
            matches++;
          }
          if (matches === 2) break;
        }
        const processLine = firstLineOfBufferAsString(processFile);
        const processData = processLine.slice(processLine.lastIndexOf(")")).split(whitespace);
        const utime = parseInt(processData[12], 10);
        const stime = parseInt(processData[13], 10);
        const vsize = parseInt(processData[21], 10);
        return {
          cpuUsage,
          cpuTotal,
          memTotal,
          memAvailable,
          utime,
          stime,
          vsize,
          rss: process.memoryUsage().rss
          // TODO: Calculate using field 24 (rss) * PAGE_SIZE
        };
      }
      update(files) {
        const prev = this.previous;
        const next = this.readStats(files);
        const stats = this.stats;
        const cpuTotal = next.cpuTotal - prev.cpuTotal;
        const cpuUsage = next.cpuUsage - prev.cpuUsage;
        const utime = next.utime - prev.utime;
        const stime = next.stime - prev.stime;
        stats["system.cpu.total.norm.pct"] = cpuUsage / cpuTotal || 0;
        stats["system.memory.actual.free"] = next.memAvailable;
        stats["system.memory.total"] = next.memTotal;
        const cpuProcessPercent = Math.min((utime + stime) / cpuTotal || 0, 1);
        const cpuProcessUserPercent = Math.min(utime / cpuTotal || 0, 1);
        const cpuProcessSystemPercent = Math.min(stime / cpuTotal || 0, 1);
        stats["system.process.cpu.total.norm.pct"] = cpuProcessPercent;
        stats["system.process.cpu.user.norm.pct"] = cpuProcessUserPercent;
        stats["system.process.cpu.system.norm.pct"] = cpuProcessSystemPercent;
        stats["system.process.memory.size"] = next.vsize;
        stats["system.process.memory.rss.bytes"] = next.rss;
        this.previous = next;
        this.inProgress = false;
      }
    };
    function firstLineOfBufferAsString(buff) {
      const newline = buff.indexOf("\n");
      return buff.toString("utf8", 0, newline === -1 ? buff.length : newline);
    }
    function readFileSync(file) {
      return fs.readFileSync(file);
    }
    module2.exports = Stats;
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/linux/index.js
var require_linux = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/linux/index.js"(exports2, module2) {
    "use strict";
    var Stats = require_stats();
    module2.exports = function createSystemMetrics(registry) {
      const stats = new Stats();
      registry.registerCollector(stats);
      for (const metric of Object.keys(stats.toJSON())) {
        registry.getOrCreateGauge(metric, () => stats.toJSON()[metric]);
      }
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/generic/process-top.js
var require_process_top = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/generic/process-top.js"(exports2, module2) {
    "use strict";
    module2.exports = top;
    function top() {
      const win = [
        { time: process.hrtime(), cpu: process.cpuUsage() },
        null,
        null,
        null
      ];
      let sec = 1;
      return {
        // pid: process.pid,
        // command: process.argv.join(' '),
        // started,
        // time () {
        //   return Date.now() - started
        // },
        // delay () {
        //   const btm = oldest()
        //   const timeDelta = process.hrtime(win[btm].time)
        //   const ms = timeDelta[0] * 1e3 + Math.floor(timeDelta[1] / 1e6)
        //   return Math.floor((loopSampler.delay - win[btm].delay) / (ms / tick))
        // },
        cpu() {
          const btm = oldest();
          const cpuDelta = process.cpuUsage(win[btm].cpu);
          const timeDelta = process.hrtime(win[btm].time);
          const us = timeDelta[0] * 1e6 + timeDelta[1] / 1e3;
          perSecond();
          return {
            time: us,
            percent: (cpuDelta.system + cpuDelta.user) / us,
            system: cpuDelta.system,
            user: cpuDelta.user
          };
        }
        // memory () {
        //   const mem = process.memoryUsage()
        //   const total = os.totalmem()
        //   return {
        //     percent: mem.rss / total,
        //     rss: mem.rss,
        //     total,
        //     heapPercent: mem.heapUsed / mem.heapTotal,
        //     heapUsed: mem.heapUsed,
        //     heapTotal: mem.heapTotal,
        //     external: mem.external
        //   }
        // },
        // loadavg () {
        //   return os.loadavg()
        // },
        // destroy () {
        //   clearInterval(interval)
        // },
        // toString () {
        //   const mem = this.memory()
        //   return `cpu: ${pct(this.cpu().percent)} | rss: ${p(mem.rss)} (${pct(mem.percent)}) | heap: ${p(mem.heapUsed)} / ${p(mem.heapTotal)} (${pct(mem.heapPercent)}) | ext: ${p(mem.external)} | delay: ${this.delay()} ms | ${time(this.time())} | loadavg: ${os.loadavg().map(fixed2).join(', ')}`
        // }
      };
      function oldest() {
        let btm = sec - 4 & 3;
        while (!win[btm]) btm = btm + 1 & 3;
        return btm;
      }
      function perSecond() {
        const ptr = sec++ & 3;
        win[ptr] = { time: process.hrtime(), cpu: process.cpuUsage() };
      }
    }
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/generic/process-cpu.js
var require_process_cpu = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/generic/process-cpu.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var processTop = require_process_top()();
    var cpus = os.cpus();
    module2.exports = function processCPUUsage() {
      const cpu = processTop.cpu();
      return {
        total: cpu.percent / cpus.length,
        user: cpu.user / cpu.time / cpus.length,
        system: cpu.system / cpu.time / cpus.length
      };
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/generic/stats.js
var require_stats2 = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/generic/stats.js"(exports2, module2) {
    "use strict";
    var processCpu = require_process_cpu();
    var Stats = class {
      constructor() {
        this.stats = {
          "system.process.cpu.total.norm.pct": 0,
          "system.process.cpu.system.norm.pct": 0,
          "system.process.cpu.user.norm.pct": 0
        };
      }
      toJSON() {
        return this.stats;
      }
      collect(cb) {
        const cpu = processCpu();
        this.stats["system.process.cpu.total.norm.pct"] = cpu.total;
        this.stats["system.process.cpu.system.norm.pct"] = cpu.system;
        this.stats["system.process.cpu.user.norm.pct"] = cpu.user;
        if (cb) process.nextTick(cb);
      }
    };
    module2.exports = Stats;
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/generic/system-cpu.js
var require_system_cpu = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/generic/system-cpu.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    function cpuAverage() {
      const times = {
        user: 0,
        nice: 0,
        sys: 0,
        idle: 0,
        irq: 0,
        total: 0
      };
      const cpus = os.cpus();
      for (const cpu of cpus) {
        for (const type of Object.keys(cpu.times)) {
          times[type] += cpu.times[type];
          times.total += cpu.times[type];
        }
      }
      const averages = {};
      for (const type of Object.keys(times)) {
        averages[type] = times[type] / cpus.length;
      }
      return averages;
    }
    function cpuPercent(last2, next) {
      const idle = next.idle - last2.idle;
      const total = next.total - last2.total;
      return 1 - idle / total || 0;
    }
    var last = cpuAverage();
    module2.exports = function systemCPUUsage() {
      const next = cpuAverage();
      const result = cpuPercent(last, next);
      last = next;
      return result;
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/platforms/generic/index.js
var require_generic = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/platforms/generic/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var Stats = require_stats2();
    module2.exports = function createSystemMetrics(registry) {
      registry.getOrCreateGauge(
        "system.cpu.total.norm.pct",
        require_system_cpu()
      );
      registry.getOrCreateGauge("system.memory.total", () => os.totalmem());
      registry.getOrCreateGauge("system.memory.actual.free", () => os.freemem());
      const stats = new Stats();
      registry.registerCollector(stats);
      const metrics2 = [
        "system.process.cpu.total.norm.pct",
        "system.process.cpu.system.norm.pct",
        "system.process.cpu.user.norm.pct"
      ];
      for (const metric of metrics2) {
        registry.getOrCreateGauge(metric, () => stats.toJSON()[metric]);
      }
      registry.getOrCreateGauge(
        "system.process.memory.rss.bytes",
        () => process.memoryUsage().rss
      );
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/registry.js
var require_registry = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/registry.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { SelfReportingMetricsRegistry } = require_lib3();
    var DimensionAwareMetricsRegistry = require_DimensionAwareMetricsRegistry();
    var MetricsReporter = require_reporter();
    var createRuntimeMetrics = require_runtime();
    var createSystemMetrics = process.platform === "linux" ? require_linux() : require_generic();
    var MetricsRegistry = class extends SelfReportingMetricsRegistry {
      constructor(agent, { reporterOptions, registryOptions = {} } = {}) {
        const defaultReporterOptions = {
          defaultDimensions: {
            hostname: agent._conf.hostname || os.hostname(),
            env: agent._conf.environment || ""
          }
        };
        const options = Object.assign({}, defaultReporterOptions, reporterOptions);
        const reporter = new MetricsReporter(agent, options);
        registryOptions.registry = new DimensionAwareMetricsRegistry({
          metricLimit: agent._conf.metricsLimit
        });
        super(reporter, registryOptions);
        this._agent = agent;
        this._registry.collectors = [];
        if (reporter.enabled) {
          createSystemMetrics(this);
          createRuntimeMetrics(this);
        }
      }
      registerCollector(collector) {
        this._registry.collectors.push(collector);
      }
    };
    module2.exports = MetricsRegistry;
  }
});

// node_modules/elastic-apm-node/lib/metrics/queue.js
var require_queue = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/queue.js"(exports2, module2) {
    "use strict";
    var QueueMetricsCollector = class {
      constructor() {
        this.stats = {
          "queue.latency.min.ms": 0,
          "queue.latency.max.ms": 0,
          "queue.latency.avg.ms": 0
        };
        this.total = 0;
        this.count = 0;
        this.min = 0;
        this.max = 0;
      }
      // Updates the data used to generate our stats
      //
      // Unlike the Stats and RuntimeCollector, this function
      // also returns the instantiated collector.
      //
      // @param {number} time A javascript ms timestamp
      updateStats(time) {
        if (this.min === 0 || this.min > time) {
          this.min = time;
        }
        if (this.max < time) {
          this.max = time;
        }
        this.count++;
        this.total += time;
      }
      // standard `collect` method for stats collectors
      //
      // called by the MetricReporter object prior to its sending data
      //
      // @param {function} cb callback function
      collect(cb) {
        this.stats["queue.latency.avg.ms"] = 0;
        if (this.count > 0) {
          this.stats["queue.latency.avg.ms"] = this.total / this.count;
        }
        this.stats["queue.latency.max.ms"] = this.max;
        this.stats["queue.latency.min.ms"] = this.min;
        this.total = 0;
        this.count = 0;
        this.max = 0;
        this.min = 0;
        if (cb) process.nextTick(cb);
      }
    };
    function createQueueMetrics(queueOrTopicName, registry) {
      const collector = new QueueMetricsCollector();
      registry.registerCollector(collector);
      for (const metric of Object.keys(collector.stats)) {
        registry.getOrCreateGauge(
          metric,
          function returnCurrentValue() {
            return collector.stats[metric];
          },
          { queue_name: queueOrTopicName }
        );
      }
      return collector;
    }
    module2.exports = {
      createQueueMetrics,
      QueueMetricsCollector
    };
  }
});

// node_modules/elastic-apm-node/lib/metrics/index.js
var require_metrics = __commonJS({
  "node_modules/elastic-apm-node/lib/metrics/index.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var MetricsRegistry = require_registry();
    var { createQueueMetrics } = require_queue();
    var registrySymbol = Symbol("metrics-registry");
    var agentSymbol = Symbol("metrics-agent");
    var NoopLogger = class {
      debug() {
      }
      error() {
      }
      fatal() {
      }
      info() {
      }
      trace() {
      }
      warn() {
      }
    };
    var Metrics = class {
      constructor(agent) {
        this[agentSymbol] = agent;
        this[registrySymbol] = null;
      }
      start(refTimers) {
        const metricsInterval = this[agentSymbol]._conf.metricsInterval;
        assert(
          metricsInterval > 0,
          "Metrics.start() should not be called if metricsInterval <= 0"
        );
        this[registrySymbol] = new MetricsRegistry(this[agentSymbol], {
          reporterOptions: {
            defaultReportingIntervalInSeconds: metricsInterval,
            enabled: true,
            unrefTimers: !refTimers,
            logger: new NoopLogger()
          }
        });
      }
      stop() {
        if (this[registrySymbol]) {
          this[registrySymbol].shutdown();
          this[registrySymbol] = null;
        }
      }
      getOrCreateCounter(...args) {
        if (!this[registrySymbol]) {
          return;
        }
        return this[registrySymbol].getOrCreateCounter(...args);
      }
      incrementCounter(name, dimensions, amount = 1) {
        if (!this[registrySymbol]) {
          return;
        }
        this.getOrCreateCounter(name, dimensions).inc(amount);
      }
      getOrCreateGauge(...args) {
        if (!this[registrySymbol]) {
          return;
        }
        return this[registrySymbol].getOrCreateGauge(...args);
      }
      // factory function for creating a queue metrics collector
      //
      // called from instrumentation, only when the agent receives a queue message
      createQueueMetricsCollector(queueOrTopicName) {
        if (!this[registrySymbol]) {
          return;
        }
        const collector = createQueueMetrics(
          queueOrTopicName,
          this[registrySymbol]
        );
        return collector;
      }
    };
    module2.exports = Metrics;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js
var require_AggregationTemporality = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregationTemporality = void 0;
    var AggregationTemporality;
    (function(AggregationTemporality2) {
      AggregationTemporality2[AggregationTemporality2["DELTA"] = 0] = "DELTA";
      AggregationTemporality2[AggregationTemporality2["CUMULATIVE"] = 1] = "CUMULATIVE";
    })(AggregationTemporality = exports2.AggregationTemporality || (exports2.AggregationTemporality = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js
var require_MetricData = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataPointType = void 0;
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2["HISTOGRAM"] = 0] = "HISTOGRAM";
      DataPointType2[DataPointType2["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
      DataPointType2[DataPointType2["GAUGE"] = 2] = "GAUGE";
      DataPointType2[DataPointType2["SUM"] = 3] = "SUM";
    })(DataPointType = exports2.DataPointType || (exports2.DataPointType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.9.0";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read3(_a, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self2.deleteValue = function(key) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context2, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context2, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/utils.js
var require_utils = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.equalsCaseInsensitive = exports2.binarySearchLB = exports2.setEquals = exports2.FlatMap = exports2.isPromiseAllSettledRejectionResult = exports2.PromiseAllSettled = exports2.callWithTimeout = exports2.TimeoutError = exports2.instrumentationScopeId = exports2.hashAttributes = exports2.isNotNullish = void 0;
    function isNotNullish(item) {
      return item !== void 0 && item !== null;
    }
    exports2.isNotNullish = isNotNullish;
    function hashAttributes(attributes) {
      let keys = Object.keys(attributes);
      if (keys.length === 0)
        return "";
      keys = keys.sort();
      return JSON.stringify(keys.map((key) => [key, attributes[key]]));
    }
    exports2.hashAttributes = hashAttributes;
    function instrumentationScopeId(instrumentationScope) {
      var _a, _b;
      return `${instrumentationScope.name}:${(_a = instrumentationScope.version) !== null && _a !== void 0 ? _a : ""}:${(_b = instrumentationScope.schemaUrl) !== null && _b !== void 0 ? _b : ""}`;
    }
    exports2.instrumentationScopeId = instrumentationScopeId;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
    async function PromiseAllSettled(promises) {
      return Promise.all(promises.map(async (p) => {
        try {
          const ret = await p;
          return {
            status: "fulfilled",
            value: ret
          };
        } catch (e) {
          return {
            status: "rejected",
            reason: e
          };
        }
      }));
    }
    exports2.PromiseAllSettled = PromiseAllSettled;
    function isPromiseAllSettledRejectionResult(it) {
      return it.status === "rejected";
    }
    exports2.isPromiseAllSettledRejectionResult = isPromiseAllSettledRejectionResult;
    function FlatMap(arr, fn) {
      const result = [];
      arr.forEach((it) => {
        result.push(...fn(it));
      });
      return result;
    }
    exports2.FlatMap = FlatMap;
    function setEquals(lhs, rhs) {
      if (lhs.size !== rhs.size) {
        return false;
      }
      for (const item of lhs) {
        if (!rhs.has(item)) {
          return false;
        }
      }
      return true;
    }
    exports2.setEquals = setEquals;
    function binarySearchLB(arr, value) {
      let lo = 0;
      let hi = arr.length - 1;
      while (hi - lo > 1) {
        const mid = Math.trunc((hi + lo) / 2);
        if (arr[mid] <= value) {
          lo = mid;
        } else {
          hi = mid - 1;
        }
      }
      if (arr[hi] <= value) {
        return hi;
      } else if (arr[lo] <= value) {
        return lo;
      }
      return -1;
    }
    exports2.binarySearchLB = binarySearchLB;
    function equalsCaseInsensitive(lhs, rhs) {
      return lhs.toLowerCase() === rhs.toLowerCase();
    }
    exports2.equalsCaseInsensitive = equalsCaseInsensitive;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js
var require_types = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregatorKind = void 0;
    var AggregatorKind;
    (function(AggregatorKind2) {
      AggregatorKind2[AggregatorKind2["DROP"] = 0] = "DROP";
      AggregatorKind2[AggregatorKind2["SUM"] = 1] = "SUM";
      AggregatorKind2[AggregatorKind2["LAST_VALUE"] = 2] = "LAST_VALUE";
      AggregatorKind2[AggregatorKind2["HISTOGRAM"] = 3] = "HISTOGRAM";
      AggregatorKind2[AggregatorKind2["EXPONENTIAL_HISTOGRAM"] = 4] = "EXPONENTIAL_HISTOGRAM";
    })(AggregatorKind = exports2.AggregatorKind || (exports2.AggregatorKind = {}));
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js
var require_Drop = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DropAggregator = void 0;
    var types_1 = require_types();
    var DropAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.DROP;
      }
      createAccumulation() {
        return void 0;
      }
      merge(_previous, _delta) {
        return void 0;
      }
      diff(_previous, _current) {
        return void 0;
      }
      toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
        return void 0;
      }
    };
    exports2.DropAggregator = DropAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js
var require_InstrumentDescriptor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidName = exports2.isDescriptorCompatibleWith = exports2.createInstrumentDescriptorWithView = exports2.createInstrumentDescriptor = exports2.InstrumentType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils();
    var InstrumentType;
    (function(InstrumentType2) {
      InstrumentType2["COUNTER"] = "COUNTER";
      InstrumentType2["GAUGE"] = "GAUGE";
      InstrumentType2["HISTOGRAM"] = "HISTOGRAM";
      InstrumentType2["UP_DOWN_COUNTER"] = "UP_DOWN_COUNTER";
      InstrumentType2["OBSERVABLE_COUNTER"] = "OBSERVABLE_COUNTER";
      InstrumentType2["OBSERVABLE_GAUGE"] = "OBSERVABLE_GAUGE";
      InstrumentType2["OBSERVABLE_UP_DOWN_COUNTER"] = "OBSERVABLE_UP_DOWN_COUNTER";
    })(InstrumentType = exports2.InstrumentType || (exports2.InstrumentType = {}));
    function createInstrumentDescriptor(name, type, options) {
      var _a, _b, _c, _d;
      if (!isValidName(name)) {
        api_1.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`);
      }
      return {
        name,
        type,
        description: (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : "",
        unit: (_b = options === null || options === void 0 ? void 0 : options.unit) !== null && _b !== void 0 ? _b : "",
        valueType: (_c = options === null || options === void 0 ? void 0 : options.valueType) !== null && _c !== void 0 ? _c : api_1.ValueType.DOUBLE,
        advice: (_d = options === null || options === void 0 ? void 0 : options.advice) !== null && _d !== void 0 ? _d : {}
      };
    }
    exports2.createInstrumentDescriptor = createInstrumentDescriptor;
    function createInstrumentDescriptorWithView(view, instrument) {
      var _a, _b;
      return {
        name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,
        description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType,
        advice: instrument.advice
      };
    }
    exports2.createInstrumentDescriptorWithView = createInstrumentDescriptorWithView;
    function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
      return (0, utils_1.equalsCaseInsensitive)(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
    }
    exports2.isDescriptorCompatibleWith = isDescriptorCompatibleWith;
    var NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
    function isValidName(name) {
      return name.match(NAME_REGEXP) != null;
    }
    exports2.isValidName = isValidName;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js
var require_Histogram2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HistogramAggregator = exports2.HistogramAccumulation = void 0;
    var types_1 = require_types();
    var MetricData_1 = require_MetricData();
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var utils_1 = require_utils();
    function createNewEmptyCheckpoint(boundaries) {
      const counts = boundaries.map(() => 0);
      counts.push(0);
      return {
        buckets: {
          boundaries,
          counts
        },
        sum: 0,
        count: 0,
        hasMinMax: false,
        min: Infinity,
        max: -Infinity
      };
    }
    var HistogramAccumulation = class {
      constructor(startTime, _boundaries, _recordMinMax = true, _current = createNewEmptyCheckpoint(_boundaries)) {
        this.startTime = startTime;
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this._current = _current;
      }
      record(value) {
        if (Number.isNaN(value)) {
          return;
        }
        this._current.count += 1;
        this._current.sum += value;
        if (this._recordMinMax) {
          this._current.min = Math.min(value, this._current.min);
          this._current.max = Math.max(value, this._current.max);
          this._current.hasMinMax = true;
        }
        const idx = (0, utils_1.binarySearchLB)(this._boundaries, value);
        this._current.buckets.counts[idx + 1] += 1;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports2.HistogramAccumulation = HistogramAccumulation;
    var HistogramAggregator = class {
      /**
       * @param _boundaries sorted upper bounds of recorded values.
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries;
        this._recordMinMax = _recordMinMax;
        this.kind = types_1.AggregatorKind.HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two histogram accumulations. As long as one Aggregator
       * instance produces all Accumulations with constant boundaries we don't need to worry about
       * merging accumulations with different boundaries.
       */
      merge(previous, delta) {
        const previousValue = previous.toPointValue();
        const deltaValue = delta.toPointValue();
        const previousCounts = previousValue.buckets.counts;
        const deltaCounts = deltaValue.buckets.counts;
        const mergedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++) {
          mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        }
        let min = Infinity;
        let max = -Infinity;
        if (this._recordMinMax) {
          if (previousValue.hasMinMax && deltaValue.hasMinMax) {
            min = Math.min(previousValue.min, deltaValue.min);
            max = Math.max(previousValue.max, deltaValue.max);
          } else if (previousValue.hasMinMax) {
            min = previousValue.min;
            max = previousValue.max;
          } else if (deltaValue.hasMinMax) {
            min = deltaValue.min;
            max = deltaValue.max;
          }
        }
        return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: mergedCounts
          },
          count: previousValue.count + deltaValue.count,
          sum: previousValue.sum + deltaValue.sum,
          hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
          min,
          max
        });
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        const previousValue = previous.toPointValue();
        const currentValue = current.toPointValue();
        const previousCounts = previousValue.buckets.counts;
        const currentCounts = currentValue.buckets.counts;
        const diffedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++) {
          diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        }
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: diffedCounts
          },
          count: currentValue.count - previousValue.count,
          sum: currentValue.sum - previousValue.sum,
          hasMinMax: false,
          min: Infinity,
          max: -Infinity
        });
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            const pointValue = accumulation.toPointValue();
            const allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: !allowsNegativeValues ? pointValue.sum : void 0,
                buckets: pointValue.buckets,
                count: pointValue.count
              }
            };
          })
        };
      }
    };
    exports2.HistogramAggregator = HistogramAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js
var require_Buckets = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buckets = void 0;
    var Buckets = class _Buckets {
      /**
       * The term index refers to the number of the exponential histogram bucket
       * used to determine its boundaries. The lower boundary of a bucket is
       * determined by base ** index and the upper boundary of a bucket is
       * determined by base ** (index + 1). index values are signed to account
       * for values less than or equal to 1.
       *
       * indexBase is the index of the 0th position in the
       * backing array, i.e., backing[0] is the count
       * in the bucket with index `indexBase`.
       *
       * indexStart is the smallest index value represented
       * in the backing array.
       *
       * indexEnd is the largest index value represented in
       * the backing array.
       */
      constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {
        this.backing = backing;
        this.indexBase = indexBase;
        this.indexStart = indexStart;
        this.indexEnd = indexEnd;
      }
      /**
       * Offset is the bucket index of the smallest entry in the counts array
       * @returns {number}
       */
      get offset() {
        return this.indexStart;
      }
      /**
       * Buckets is a view into the backing array.
       * @returns {number}
       */
      get length() {
        if (this.backing.length === 0) {
          return 0;
        }
        if (this.indexEnd === this.indexStart && this.at(0) === 0) {
          return 0;
        }
        return this.indexEnd - this.indexStart + 1;
      }
      /**
       * An array of counts, where count[i] carries the count
       * of the bucket at index (offset+i).  count[i] is the count of
       * values greater than base^(offset+i) and less than or equal to
       * base^(offset+i+1).
       * @returns {number} The logical counts based on the backing array
       */
      counts() {
        return Array.from({ length: this.length }, (_, i) => this.at(i));
      }
      /**
       * At returns the count of the bucket at a position in the logical
       * array of counts.
       * @param position
       * @returns {number}
       */
      at(position) {
        const bias = this.indexBase - this.indexStart;
        if (position < bias) {
          position += this.backing.length;
        }
        position -= bias;
        return this.backing.countAt(position);
      }
      /**
       * incrementBucket increments the backing array index by `increment`
       * @param bucketIndex
       * @param increment
       */
      incrementBucket(bucketIndex, increment) {
        this.backing.increment(bucketIndex, increment);
      }
      /**
       * decrementBucket decrements the backing array index by `decrement`
       * if decrement is greater than the current value, it's set to 0.
       * @param bucketIndex
       * @param decrement
       */
      decrementBucket(bucketIndex, decrement) {
        this.backing.decrement(bucketIndex, decrement);
      }
      /**
       * trim removes leading and / or trailing zero buckets (which can occur
       * after diffing two histos) and rotates the backing array so that the
       * smallest non-zero index is in the 0th position of the backing array
       */
      trim() {
        for (let i = 0; i < this.length; i++) {
          if (this.at(i) !== 0) {
            this.indexStart += i;
            break;
          } else if (i === this.length - 1) {
            this.indexStart = this.indexEnd = this.indexBase = 0;
            return;
          }
        }
        for (let i = this.length - 1; i >= 0; i--) {
          if (this.at(i) !== 0) {
            this.indexEnd -= this.length - i - 1;
            break;
          }
        }
        this._rotate();
      }
      /**
       * downscale first rotates, then collapses 2**`by`-to-1 buckets.
       * @param by
       */
      downscale(by) {
        this._rotate();
        const size = 1 + this.indexEnd - this.indexStart;
        const each = 1 << by;
        let inpos = 0;
        let outpos = 0;
        for (let pos = this.indexStart; pos <= this.indexEnd; ) {
          let mod = pos % each;
          if (mod < 0) {
            mod += each;
          }
          for (let i = mod; i < each && inpos < size; i++) {
            this._relocateBucket(outpos, inpos);
            inpos++;
            pos++;
          }
          outpos++;
        }
        this.indexStart >>= by;
        this.indexEnd >>= by;
        this.indexBase = this.indexStart;
      }
      /**
       * Clone returns a deep copy of Buckets
       * @returns {Buckets}
       */
      clone() {
        return new _Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
      }
      /**
       * _rotate shifts the backing array contents so that indexStart ==
       * indexBase to simplify the downscale logic.
       */
      _rotate() {
        const bias = this.indexBase - this.indexStart;
        if (bias === 0) {
          return;
        } else if (bias > 0) {
          this.backing.reverse(0, this.backing.length);
          this.backing.reverse(0, bias);
          this.backing.reverse(bias, this.backing.length);
        } else {
          this.backing.reverse(0, this.backing.length);
          this.backing.reverse(0, this.backing.length + bias);
        }
        this.indexBase = this.indexStart;
      }
      /**
       * _relocateBucket adds the count in counts[src] to counts[dest] and
       * resets count[src] to zero.
       */
      _relocateBucket(dest, src) {
        if (dest === src) {
          return;
        }
        this.incrementBucket(dest, this.backing.emptyBucket(src));
      }
    };
    exports2.Buckets = Buckets;
    var BucketsBacking = class _BucketsBacking {
      constructor(_counts = [0]) {
        this._counts = _counts;
      }
      /**
       * length returns the physical size of the backing array, which
       * is >= buckets.length()
       */
      get length() {
        return this._counts.length;
      }
      /**
       * countAt returns the count in a specific bucket
       */
      countAt(pos) {
        return this._counts[pos];
      }
      /**
       * growTo grows a backing array and copies old entries
       * into their correct new positions.
       */
      growTo(newSize, oldPositiveLimit, newPositiveLimit) {
        const tmp = new Array(newSize).fill(0);
        tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit));
        tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));
        this._counts = tmp;
      }
      /**
       * reverse the items in the backing array in the range [from, limit).
       */
      reverse(from, limit) {
        const num = Math.floor((from + limit) / 2) - from;
        for (let i = 0; i < num; i++) {
          const tmp = this._counts[from + i];
          this._counts[from + i] = this._counts[limit - i - 1];
          this._counts[limit - i - 1] = tmp;
        }
      }
      /**
       * emptyBucket empties the count from a bucket, for
       * moving into another.
       */
      emptyBucket(src) {
        const tmp = this._counts[src];
        this._counts[src] = 0;
        return tmp;
      }
      /**
       * increments a bucket by `increment`
       */
      increment(bucketIndex, increment) {
        this._counts[bucketIndex] += increment;
      }
      /**
       * decrements a bucket by `decrement`
       */
      decrement(bucketIndex, decrement) {
        if (this._counts[bucketIndex] >= decrement) {
          this._counts[bucketIndex] -= decrement;
        } else {
          this._counts[bucketIndex] = 0;
        }
      }
      /**
       * clone returns a deep copy of BucketsBacking
       */
      clone() {
        return new _BucketsBacking([...this._counts]);
      }
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js
var require_ieee754 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSignificand = exports2.getNormalBase2 = exports2.MIN_VALUE = exports2.MAX_NORMAL_EXPONENT = exports2.MIN_NORMAL_EXPONENT = exports2.SIGNIFICAND_WIDTH = void 0;
    exports2.SIGNIFICAND_WIDTH = 52;
    var EXPONENT_MASK = 2146435072;
    var SIGNIFICAND_MASK = 1048575;
    var EXPONENT_BIAS = 1023;
    exports2.MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
    exports2.MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
    exports2.MIN_VALUE = Math.pow(2, -1022);
    function getNormalBase2(value) {
      const dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      const hiBits = dv.getUint32(0);
      const expBits = (hiBits & EXPONENT_MASK) >> 20;
      return expBits - EXPONENT_BIAS;
    }
    exports2.getNormalBase2 = getNormalBase2;
    function getSignificand(value) {
      const dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      const hiBits = dv.getUint32(0);
      const loBits = dv.getUint32(4);
      const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);
      return significandHiBits + loBits;
    }
    exports2.getSignificand = getSignificand;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js
var require_util3 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextGreaterSquare = exports2.ldexp = void 0;
    function ldexp(frac, exp) {
      if (frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac)) {
        return frac;
      }
      return frac * Math.pow(2, exp);
    }
    exports2.ldexp = ldexp;
    function nextGreaterSquare(v) {
      v--;
      v |= v >> 1;
      v |= v >> 2;
      v |= v >> 4;
      v |= v >> 8;
      v |= v >> 16;
      v++;
      return v;
    }
    exports2.nextGreaterSquare = nextGreaterSquare;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js
var require_types2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MappingError = void 0;
    var MappingError = class extends Error {
    };
    exports2.MappingError = MappingError;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js
var require_ExponentMapping = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExponentMapping = void 0;
    var ieee754 = require_ieee754();
    var util = require_util3();
    var types_1 = require_types2();
    var ExponentMapping = class {
      constructor(scale) {
        this._shift = -scale;
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value < ieee754.MIN_VALUE) {
          return this._minNormalLowerBoundaryIndex();
        }
        const exp = ieee754.getNormalBase2(value);
        const correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);
        return exp + correction >> this._shift;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        const minIndex = this._minNormalLowerBoundaryIndex();
        if (index < minIndex) {
          throw new types_1.MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        const maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index > maxIndex) {
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        return util.ldexp(1, index << this._shift);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        if (this._shift === 0) {
          return 0;
        }
        return -this._shift;
      }
      _minNormalLowerBoundaryIndex() {
        let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;
        if (this._shift < 2) {
          index--;
        }
        return index;
      }
      _maxNormalLowerBoundaryIndex() {
        return ieee754.MAX_NORMAL_EXPONENT >> this._shift;
      }
      _rightShift(value, shift) {
        return Math.floor(value * Math.pow(2, -shift));
      }
    };
    exports2.ExponentMapping = ExponentMapping;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js
var require_LogarithmMapping = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogarithmMapping = void 0;
    var ieee754 = require_ieee754();
    var util = require_util3();
    var types_1 = require_types2();
    var LogarithmMapping = class {
      constructor(scale) {
        this._scale = scale;
        this._scaleFactor = util.ldexp(Math.LOG2E, scale);
        this._inverseFactor = util.ldexp(Math.LN2, -scale);
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value <= ieee754.MIN_VALUE) {
          return this._minNormalLowerBoundaryIndex() - 1;
        }
        if (ieee754.getSignificand(value) === 0) {
          const exp = ieee754.getNormalBase2(value);
          return (exp << this._scale) - 1;
        }
        const index = Math.floor(Math.log(value) * this._scaleFactor);
        const maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          return maxIndex;
        }
        return index;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        const maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          if (index === maxIndex) {
            return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
          }
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        const minIndex = this._minNormalLowerBoundaryIndex();
        if (index <= minIndex) {
          if (index === minIndex) {
            return ieee754.MIN_VALUE;
          } else if (index === minIndex - 1) {
            return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
          }
          throw new types_1.MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        return Math.exp(index * this._inverseFactor);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._scale;
      }
      _minNormalLowerBoundaryIndex() {
        return ieee754.MIN_NORMAL_EXPONENT << this._scale;
      }
      _maxNormalLowerBoundaryIndex() {
        return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
      }
    };
    exports2.LogarithmMapping = LogarithmMapping;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js
var require_getMapping = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMapping = void 0;
    var ExponentMapping_1 = require_ExponentMapping();
    var LogarithmMapping_1 = require_LogarithmMapping();
    var types_1 = require_types2();
    var MIN_SCALE = -10;
    var MAX_SCALE = 20;
    var PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => {
      if (i > 10) {
        return new LogarithmMapping_1.LogarithmMapping(i - 10);
      }
      return new ExponentMapping_1.ExponentMapping(i - 10);
    });
    function getMapping(scale) {
      if (scale > MAX_SCALE || scale < MIN_SCALE) {
        throw new types_1.MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`);
      }
      return PREBUILT_MAPPINGS[scale + 10];
    }
    exports2.getMapping = getMapping;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js
var require_ExponentialHistogram = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExponentialHistogramAggregator = exports2.ExponentialHistogramAccumulation = void 0;
    var types_1 = require_types();
    var MetricData_1 = require_MetricData();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Buckets_1 = require_Buckets();
    var getMapping_1 = require_getMapping();
    var util_1 = require_util3();
    var HighLow = class _HighLow {
      constructor(low, high) {
        this.low = low;
        this.high = high;
      }
      static combine(h1, h2) {
        return new _HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
      }
    };
    var MAX_SCALE = 20;
    var DEFAULT_MAX_SIZE = 160;
    var MIN_MAX_SIZE = 2;
    var ExponentialHistogramAccumulation = class _ExponentialHistogramAccumulation {
      constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = true, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets_1.Buckets(), _negative = new Buckets_1.Buckets(), _mapping = (0, getMapping_1.getMapping)(MAX_SCALE)) {
        this.startTime = startTime;
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
        this._sum = _sum;
        this._count = _count;
        this._zeroCount = _zeroCount;
        this._min = _min;
        this._max = _max;
        this._positive = _positive;
        this._negative = _negative;
        this._mapping = _mapping;
        if (this._maxSize < MIN_MAX_SIZE) {
          api_1.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize},                 changing to the minimum size of: ${MIN_MAX_SIZE}`);
          this._maxSize = MIN_MAX_SIZE;
        }
      }
      /**
       * record updates a histogram with a single count
       * @param {Number} value
       */
      record(value) {
        this.updateByIncrement(value, 1);
      }
      /**
       * Sets the start time for this accumulation
       * @param {HrTime} startTime
       */
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      /**
       * Returns the datapoint representation of this accumulation
       * @param {HrTime} startTime
       */
      toPointValue() {
        return {
          hasMinMax: this._recordMinMax,
          min: this.min,
          max: this.max,
          sum: this.sum,
          positive: {
            offset: this.positive.offset,
            bucketCounts: this.positive.counts()
          },
          negative: {
            offset: this.negative.offset,
            bucketCounts: this.negative.counts()
          },
          count: this.count,
          scale: this.scale,
          zeroCount: this.zeroCount
        };
      }
      /**
       * @returns {Number} The sum of values recorded by this accumulation
       */
      get sum() {
        return this._sum;
      }
      /**
       * @returns {Number} The minimum value recorded by this accumulation
       */
      get min() {
        return this._min;
      }
      /**
       * @returns {Number} The maximum value recorded by this accumulation
       */
      get max() {
        return this._max;
      }
      /**
       * @returns {Number} The count of values recorded by this accumulation
       */
      get count() {
        return this._count;
      }
      /**
       * @returns {Number} The number of 0 values recorded by this accumulation
       */
      get zeroCount() {
        return this._zeroCount;
      }
      /**
       * @returns {Number} The scale used by this accumulation
       */
      get scale() {
        if (this._count === this._zeroCount) {
          return 0;
        }
        return this._mapping.scale;
      }
      /**
       * positive holds the positive values
       * @returns {Buckets}
       */
      get positive() {
        return this._positive;
      }
      /**
       * negative holds the negative values by their absolute value
       * @returns {Buckets}
       */
      get negative() {
        return this._negative;
      }
      /**
       * updateByIncr supports updating a histogram with a non-negative
       * increment.
       * @param value
       * @param increment
       */
      updateByIncrement(value, increment) {
        if (Number.isNaN(value)) {
          return;
        }
        if (value > this._max) {
          this._max = value;
        }
        if (value < this._min) {
          this._min = value;
        }
        this._count += increment;
        if (value === 0) {
          this._zeroCount += increment;
          return;
        }
        this._sum += value * increment;
        if (value > 0) {
          this._updateBuckets(this._positive, value, increment);
        } else {
          this._updateBuckets(this._negative, -value, increment);
        }
      }
      /**
       * merge combines data from previous value into self
       * @param {ExponentialHistogramAccumulation} previous
       */
      merge(previous) {
        if (this._count === 0) {
          this._min = previous.min;
          this._max = previous.max;
        } else if (previous.count !== 0) {
          if (previous.min < this.min) {
            this._min = previous.min;
          }
          if (previous.max > this.max) {
            this._max = previous.max;
          }
        }
        this.startTime = previous.startTime;
        this._sum += previous.sum;
        this._count += previous.count;
        this._zeroCount += previous.zeroCount;
        const minScale = this._minScale(previous);
        this._downscale(this.scale - minScale);
        this._mergeBuckets(this.positive, previous, previous.positive, minScale);
        this._mergeBuckets(this.negative, previous, previous.negative, minScale);
      }
      /**
       * diff subtracts other from self
       * @param {ExponentialHistogramAccumulation} other
       */
      diff(other) {
        this._min = Infinity;
        this._max = -Infinity;
        this._sum -= other.sum;
        this._count -= other.count;
        this._zeroCount -= other.zeroCount;
        const minScale = this._minScale(other);
        this._downscale(this.scale - minScale);
        this._diffBuckets(this.positive, other, other.positive, minScale);
        this._diffBuckets(this.negative, other, other.negative, minScale);
      }
      /**
       * clone returns a deep copy of self
       * @returns {ExponentialHistogramAccumulation}
       */
      clone() {
        return new _ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
      }
      /**
       * _updateBuckets maps the incoming value to a bucket index for the current
       * scale. If the bucket index is outside of the range of the backing array,
       * it will rescale the backing array and update the mapping for the new scale.
       */
      _updateBuckets(buckets, value, increment) {
        let index = this._mapping.mapToIndex(value);
        let rescalingNeeded = false;
        let high = 0;
        let low = 0;
        if (buckets.length === 0) {
          buckets.indexStart = index;
          buckets.indexEnd = buckets.indexStart;
          buckets.indexBase = buckets.indexStart;
        } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {
          rescalingNeeded = true;
          low = index;
          high = buckets.indexEnd;
        } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {
          rescalingNeeded = true;
          low = buckets.indexStart;
          high = index;
        }
        if (rescalingNeeded) {
          const change = this._changeScale(high, low);
          this._downscale(change);
          index = this._mapping.mapToIndex(value);
        }
        this._incrementIndexBy(buckets, index, increment);
      }
      /**
       * _incrementIndexBy increments the count of the bucket specified by `index`.
       * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
       * the boundaries of the backing array will be adjusted and more buckets will
       * be added if needed.
       */
      _incrementIndexBy(buckets, index, increment) {
        if (increment === 0) {
          return;
        }
        if (buckets.length === 0) {
          buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;
        }
        if (index < buckets.indexStart) {
          const span = buckets.indexEnd - index;
          if (span >= buckets.backing.length) {
            this._grow(buckets, span + 1);
          }
          buckets.indexStart = index;
        } else if (index > buckets.indexEnd) {
          const span = index - buckets.indexStart;
          if (span >= buckets.backing.length) {
            this._grow(buckets, span + 1);
          }
          buckets.indexEnd = index;
        }
        let bucketIndex = index - buckets.indexBase;
        if (bucketIndex < 0) {
          bucketIndex += buckets.backing.length;
        }
        buckets.incrementBucket(bucketIndex, increment);
      }
      /**
       * grow resizes the backing array by doubling in size up to maxSize.
       * This extends the array with a bunch of zeros and copies the
       * existing counts to the same position.
       */
      _grow(buckets, needed) {
        const size = buckets.backing.length;
        const bias = buckets.indexBase - buckets.indexStart;
        const oldPositiveLimit = size - bias;
        let newSize = (0, util_1.nextGreaterSquare)(needed);
        if (newSize > this._maxSize) {
          newSize = this._maxSize;
        }
        const newPositiveLimit = newSize - bias;
        buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
      }
      /**
       * _changeScale computes how much downscaling is needed by shifting the
       * high and low values until they are separated by no more than size.
       */
      _changeScale(high, low) {
        let change = 0;
        while (high - low >= this._maxSize) {
          high >>= 1;
          low >>= 1;
          change++;
        }
        return change;
      }
      /**
       * _downscale subtracts `change` from the current mapping scale.
       */
      _downscale(change) {
        if (change === 0) {
          return;
        }
        if (change < 0) {
          throw new Error(`impossible change of scale: ${this.scale}`);
        }
        const newScale = this._mapping.scale - change;
        this._positive.downscale(change);
        this._negative.downscale(change);
        this._mapping = (0, getMapping_1.getMapping)(newScale);
      }
      /**
       * _minScale is used by diff and merge to compute an ideal combined scale
       */
      _minScale(other) {
        const minScale = Math.min(this.scale, other.scale);
        const highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));
        const highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
      }
      /**
       * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
       */
      _highLowAtScale(buckets, currentScale, newScale) {
        if (buckets.length === 0) {
          return new HighLow(0, -1);
        }
        const shift = currentScale - newScale;
        return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
      }
      /**
       * _mergeBuckets translates index values from another histogram and
       * adds the values into the corresponding buckets of this histogram.
       */
      _mergeBuckets(ours, other, theirs, scale) {
        const theirOffset = theirs.offset;
        const theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++) {
          this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
        }
      }
      /**
       * _diffBuckets translates index values from another histogram and
       * subtracts the values in the corresponding buckets of this histogram.
       */
      _diffBuckets(ours, other, theirs, scale) {
        const theirOffset = theirs.offset;
        const theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++) {
          const ourIndex = theirOffset + i >> theirChange;
          let bucketIndex = ourIndex - ours.indexBase;
          if (bucketIndex < 0) {
            bucketIndex += ours.backing.length;
          }
          ours.decrementBucket(bucketIndex, theirs.at(i));
        }
        ours.trim();
      }
    };
    exports2.ExponentialHistogramAccumulation = ExponentialHistogramAccumulation;
    var ExponentialHistogramAggregator = class {
      /**
       * @param _maxSize Maximum number of buckets for each of the positive
       *    and negative ranges, exclusive of the zero-bucket.
       * @param _recordMinMax If set to true, min and max will be recorded.
       *    Otherwise, min and max will not be recorded.
       */
      constructor(_maxSize, _recordMinMax) {
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
        this.kind = types_1.AggregatorKind.EXPONENTIAL_HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two exponential histogram accumulations.
       */
      merge(previous, delta) {
        const result = delta.clone();
        result.merge(previous);
        return result;
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        const result = current.clone();
        result.diff(previous);
        return result;
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.EXPONENTIAL_HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            const pointValue = accumulation.toPointValue();
            const allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: !allowsNegativeValues ? pointValue.sum : void 0,
                positive: {
                  offset: pointValue.positive.offset,
                  bucketCounts: pointValue.positive.bucketCounts
                },
                negative: {
                  offset: pointValue.negative.offset,
                  bucketCounts: pointValue.negative.bucketCounts
                },
                count: pointValue.count,
                scale: pointValue.scale,
                zeroCount: pointValue.zeroCount
              }
            };
          })
        };
      }
    };
    exports2.ExponentialHistogramAggregator = ExponentialHistogramAggregator;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracingSuppressed = exports2.unsuppressTracing = exports2.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context2) {
      return context2.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports2.suppressTracing = suppressTracing;
    function unsuppressTracing(context2) {
      return context2.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports2.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context2) {
      return context2.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports2.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants4 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports2.BAGGAGE_HEADER = exports2.BAGGAGE_ITEMS_SEPARATOR = exports2.BAGGAGE_PROPERTIES_SEPARATOR = exports2.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports2.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports2.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports2.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports2.BAGGAGE_HEADER = "baggage";
    exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseKeyPairsIntoRecord = exports2.parsePairKeyValue = exports2.getKeyPairs = exports2.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants4();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports2.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports2.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports2.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports2.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var constants_1 = require_constants4();
    var utils_1 = require_utils2();
    var W3CBaggagePropagator = class {
      inject(context2, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context2);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context2))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context2, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context2;
        const baggage = {};
        if (baggageString.length === 0) {
          return context2;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context2;
        }
        return api_1.propagation.setBaggage(context2, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports2.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports2.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAttributeValue = exports2.isAttributeKey = exports2.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports2.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports2.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports2.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports2.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalErrorHandler = exports2.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports2.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a) {
      }
    }
    exports2.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports2.TracesSamplerValues || (exports2.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseEnvironment = exports2.DEFAULT_ENVIRONMENT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports2.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] === "undefined") {
        return;
      }
      const value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment, values, min = -Infinity, max = Infinity) {
      if (typeof values[name] !== "undefined") {
        const value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min) {
            environment[name] = min;
          } else if (value > max) {
            environment[name] = max;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v) => v.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      const value = values[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values) {
      const environment = {};
      for (const env in exports2.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment, values);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              const value = values[key];
              if (typeof value !== "undefined" && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }
    exports2.parseEnvironment = parseEnvironment;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnvWithoutDefaults = exports2.getEnv = void 0;
    var environment_1 = require_environment();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports2.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports2.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        const hi = intValue(hexStr.charCodeAt(i));
        const lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports2.hexToBinary = hexToBinary;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports2.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        }
        for (let i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.otperformance = void 0;
    var perf_hooks_1 = require("perf_hooks");
    exports2.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/core/build/src/version.js
var require_version = __commonJS({
  "node_modules/@opentelemetry/core/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.25.1";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils3 = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap(values) {
      let res = {};
      const len = values.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    exports2.createConstMap = createConstMap;
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SEMATTRS_NET_HOST_CARRIER_ICC = exports2.SEMATTRS_NET_HOST_CARRIER_MNC = exports2.SEMATTRS_NET_HOST_CARRIER_MCC = exports2.SEMATTRS_NET_HOST_CARRIER_NAME = exports2.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports2.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports2.SEMATTRS_NET_HOST_NAME = exports2.SEMATTRS_NET_HOST_PORT = exports2.SEMATTRS_NET_HOST_IP = exports2.SEMATTRS_NET_PEER_NAME = exports2.SEMATTRS_NET_PEER_PORT = exports2.SEMATTRS_NET_PEER_IP = exports2.SEMATTRS_NET_TRANSPORT = exports2.SEMATTRS_FAAS_INVOKED_REGION = exports2.SEMATTRS_FAAS_INVOKED_PROVIDER = exports2.SEMATTRS_FAAS_INVOKED_NAME = exports2.SEMATTRS_FAAS_COLDSTART = exports2.SEMATTRS_FAAS_CRON = exports2.SEMATTRS_FAAS_TIME = exports2.SEMATTRS_FAAS_DOCUMENT_NAME = exports2.SEMATTRS_FAAS_DOCUMENT_TIME = exports2.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports2.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports2.SEMATTRS_FAAS_EXECUTION = exports2.SEMATTRS_FAAS_TRIGGER = exports2.SEMATTRS_EXCEPTION_ESCAPED = exports2.SEMATTRS_EXCEPTION_STACKTRACE = exports2.SEMATTRS_EXCEPTION_MESSAGE = exports2.SEMATTRS_EXCEPTION_TYPE = exports2.SEMATTRS_DB_SQL_TABLE = exports2.SEMATTRS_DB_MONGODB_COLLECTION = exports2.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports2.SEMATTRS_DB_HBASE_NAMESPACE = exports2.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports2.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports2.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports2.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports2.SEMATTRS_DB_CASSANDRA_TABLE = exports2.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports2.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports2.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports2.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports2.SEMATTRS_DB_OPERATION = exports2.SEMATTRS_DB_STATEMENT = exports2.SEMATTRS_DB_NAME = exports2.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports2.SEMATTRS_DB_USER = exports2.SEMATTRS_DB_CONNECTION_STRING = exports2.SEMATTRS_DB_SYSTEM = exports2.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports2.SEMATTRS_MESSAGING_DESTINATION_KIND = exports2.SEMATTRS_MESSAGING_DESTINATION = exports2.SEMATTRS_MESSAGING_SYSTEM = exports2.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports2.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports2.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports2.SEMATTRS_AWS_DYNAMODB_COUNT = exports2.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports2.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports2.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports2.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports2.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports2.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports2.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports2.SEMATTRS_AWS_DYNAMODB_SELECT = exports2.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports2.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports2.SEMATTRS_AWS_DYNAMODB_LIMIT = exports2.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports2.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports2.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports2.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports2.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports2.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports2.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports2.SEMATTRS_HTTP_CLIENT_IP = exports2.SEMATTRS_HTTP_ROUTE = exports2.SEMATTRS_HTTP_SERVER_NAME = exports2.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports2.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports2.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports2.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports2.SEMATTRS_HTTP_USER_AGENT = exports2.SEMATTRS_HTTP_FLAVOR = exports2.SEMATTRS_HTTP_STATUS_CODE = exports2.SEMATTRS_HTTP_SCHEME = exports2.SEMATTRS_HTTP_HOST = exports2.SEMATTRS_HTTP_TARGET = exports2.SEMATTRS_HTTP_URL = exports2.SEMATTRS_HTTP_METHOD = exports2.SEMATTRS_CODE_LINENO = exports2.SEMATTRS_CODE_FILEPATH = exports2.SEMATTRS_CODE_NAMESPACE = exports2.SEMATTRS_CODE_FUNCTION = exports2.SEMATTRS_THREAD_NAME = exports2.SEMATTRS_THREAD_ID = exports2.SEMATTRS_ENDUSER_SCOPE = exports2.SEMATTRS_ENDUSER_ROLE = exports2.SEMATTRS_ENDUSER_ID = exports2.SEMATTRS_PEER_SERVICE = void 0;
    exports2.DBSYSTEMVALUES_FILEMAKER = exports2.DBSYSTEMVALUES_DERBY = exports2.DBSYSTEMVALUES_FIREBIRD = exports2.DBSYSTEMVALUES_ADABAS = exports2.DBSYSTEMVALUES_CACHE = exports2.DBSYSTEMVALUES_EDB = exports2.DBSYSTEMVALUES_FIRSTSQL = exports2.DBSYSTEMVALUES_INGRES = exports2.DBSYSTEMVALUES_HANADB = exports2.DBSYSTEMVALUES_MAXDB = exports2.DBSYSTEMVALUES_PROGRESS = exports2.DBSYSTEMVALUES_HSQLDB = exports2.DBSYSTEMVALUES_CLOUDSCAPE = exports2.DBSYSTEMVALUES_HIVE = exports2.DBSYSTEMVALUES_REDSHIFT = exports2.DBSYSTEMVALUES_POSTGRESQL = exports2.DBSYSTEMVALUES_DB2 = exports2.DBSYSTEMVALUES_ORACLE = exports2.DBSYSTEMVALUES_MYSQL = exports2.DBSYSTEMVALUES_MSSQL = exports2.DBSYSTEMVALUES_OTHER_SQL = exports2.SemanticAttributes = exports2.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports2.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports2.SEMATTRS_MESSAGE_ID = exports2.SEMATTRS_MESSAGE_TYPE = exports2.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports2.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports2.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports2.SEMATTRS_RPC_JSONRPC_VERSION = exports2.SEMATTRS_RPC_GRPC_STATUS_CODE = exports2.SEMATTRS_RPC_METHOD = exports2.SEMATTRS_RPC_SERVICE = exports2.SEMATTRS_RPC_SYSTEM = exports2.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports2.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports2.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports2.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports2.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports2.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports2.SEMATTRS_MESSAGING_CONSUMER_ID = exports2.SEMATTRS_MESSAGING_OPERATION = exports2.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports2.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports2.SEMATTRS_MESSAGING_CONVERSATION_ID = exports2.SEMATTRS_MESSAGING_MESSAGE_ID = exports2.SEMATTRS_MESSAGING_URL = exports2.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports2.SEMATTRS_MESSAGING_PROTOCOL = exports2.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports2.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports2.FaasDocumentOperationValues = exports2.FAASDOCUMENTOPERATIONVALUES_DELETE = exports2.FAASDOCUMENTOPERATIONVALUES_EDIT = exports2.FAASDOCUMENTOPERATIONVALUES_INSERT = exports2.FaasTriggerValues = exports2.FAASTRIGGERVALUES_OTHER = exports2.FAASTRIGGERVALUES_TIMER = exports2.FAASTRIGGERVALUES_PUBSUB = exports2.FAASTRIGGERVALUES_HTTP = exports2.FAASTRIGGERVALUES_DATASOURCE = exports2.DbCassandraConsistencyLevelValues = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports2.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports2.DbSystemValues = exports2.DBSYSTEMVALUES_COCKROACHDB = exports2.DBSYSTEMVALUES_MEMCACHED = exports2.DBSYSTEMVALUES_ELASTICSEARCH = exports2.DBSYSTEMVALUES_GEODE = exports2.DBSYSTEMVALUES_NEO4J = exports2.DBSYSTEMVALUES_DYNAMODB = exports2.DBSYSTEMVALUES_COSMOSDB = exports2.DBSYSTEMVALUES_COUCHDB = exports2.DBSYSTEMVALUES_COUCHBASE = exports2.DBSYSTEMVALUES_REDIS = exports2.DBSYSTEMVALUES_MONGODB = exports2.DBSYSTEMVALUES_HBASE = exports2.DBSYSTEMVALUES_CASSANDRA = exports2.DBSYSTEMVALUES_COLDFUSION = exports2.DBSYSTEMVALUES_H2 = exports2.DBSYSTEMVALUES_VERTICA = exports2.DBSYSTEMVALUES_TERADATA = exports2.DBSYSTEMVALUES_SYBASE = exports2.DBSYSTEMVALUES_SQLITE = exports2.DBSYSTEMVALUES_POINTBASE = exports2.DBSYSTEMVALUES_PERVASIVE = exports2.DBSYSTEMVALUES_NETEZZA = exports2.DBSYSTEMVALUES_MARIADB = exports2.DBSYSTEMVALUES_INTERBASE = exports2.DBSYSTEMVALUES_INSTANTDB = exports2.DBSYSTEMVALUES_INFORMIX = void 0;
    exports2.MESSAGINGOPERATIONVALUES_RECEIVE = exports2.MessagingDestinationKindValues = exports2.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports2.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports2.HttpFlavorValues = exports2.HTTPFLAVORVALUES_QUIC = exports2.HTTPFLAVORVALUES_SPDY = exports2.HTTPFLAVORVALUES_HTTP_2_0 = exports2.HTTPFLAVORVALUES_HTTP_1_1 = exports2.HTTPFLAVORVALUES_HTTP_1_0 = exports2.NetHostConnectionSubtypeValues = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports2.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports2.NetHostConnectionTypeValues = exports2.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports2.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports2.NETHOSTCONNECTIONTYPEVALUES_CELL = exports2.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports2.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports2.NetTransportValues = exports2.NETTRANSPORTVALUES_OTHER = exports2.NETTRANSPORTVALUES_INPROC = exports2.NETTRANSPORTVALUES_PIPE = exports2.NETTRANSPORTVALUES_UNIX = exports2.NETTRANSPORTVALUES_IP = exports2.NETTRANSPORTVALUES_IP_UDP = exports2.NETTRANSPORTVALUES_IP_TCP = exports2.FaasInvokedProviderValues = exports2.FAASINVOKEDPROVIDERVALUES_GCP = exports2.FAASINVOKEDPROVIDERVALUES_AZURE = exports2.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports2.MessageTypeValues = exports2.MESSAGETYPEVALUES_RECEIVED = exports2.MESSAGETYPEVALUES_SENT = exports2.RpcGrpcStatusCodeValues = exports2.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports2.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports2.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports2.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports2.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports2.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports2.RPCGRPCSTATUSCODEVALUES_ABORTED = exports2.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports2.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports2.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports2.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports2.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports2.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports2.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports2.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports2.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports2.RPCGRPCSTATUSCODEVALUES_OK = exports2.MessagingOperationValues = exports2.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils3();
    var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM = "db.system";
    var TMP_DB_CONNECTION_STRING = "db.connection_string";
    var TMP_DB_USER = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
    var TMP_DB_NAME = "db.name";
    var TMP_DB_STATEMENT = "db.statement";
    var TMP_DB_OPERATION = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE = "db.sql.table";
    var TMP_EXCEPTION_TYPE = "exception.type";
    var TMP_EXCEPTION_MESSAGE = "exception.message";
    var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED = "exception.escaped";
    var TMP_FAAS_TRIGGER = "faas.trigger";
    var TMP_FAAS_EXECUTION = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
    var TMP_FAAS_TIME = "faas.time";
    var TMP_FAAS_CRON = "faas.cron";
    var TMP_FAAS_COLDSTART = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
    var TMP_NET_TRANSPORT = "net.transport";
    var TMP_NET_PEER_IP = "net.peer.ip";
    var TMP_NET_PEER_PORT = "net.peer.port";
    var TMP_NET_PEER_NAME = "net.peer.name";
    var TMP_NET_HOST_IP = "net.host.ip";
    var TMP_NET_HOST_PORT = "net.host.port";
    var TMP_NET_HOST_NAME = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
    var TMP_PEER_SERVICE = "peer.service";
    var TMP_ENDUSER_ID = "enduser.id";
    var TMP_ENDUSER_ROLE = "enduser.role";
    var TMP_ENDUSER_SCOPE = "enduser.scope";
    var TMP_THREAD_ID = "thread.id";
    var TMP_THREAD_NAME = "thread.name";
    var TMP_CODE_FUNCTION = "code.function";
    var TMP_CODE_NAMESPACE = "code.namespace";
    var TMP_CODE_FILEPATH = "code.filepath";
    var TMP_CODE_LINENO = "code.lineno";
    var TMP_HTTP_METHOD = "http.method";
    var TMP_HTTP_URL = "http.url";
    var TMP_HTTP_TARGET = "http.target";
    var TMP_HTTP_HOST = "http.host";
    var TMP_HTTP_SCHEME = "http.scheme";
    var TMP_HTTP_STATUS_CODE = "http.status_code";
    var TMP_HTTP_FLAVOR = "http.flavor";
    var TMP_HTTP_USER_AGENT = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME = "http.server_name";
    var TMP_HTTP_ROUTE = "http.route";
    var TMP_HTTP_CLIENT_IP = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM = "messaging.system";
    var TMP_MESSAGING_DESTINATION = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
    var TMP_MESSAGING_URL = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM = "rpc.system";
    var TMP_RPC_SERVICE = "rpc.service";
    var TMP_RPC_METHOD = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE = "message.type";
    var TMP_MESSAGE_ID = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
    exports2.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
    exports2.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
    exports2.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
    exports2.SEMATTRS_DB_USER = TMP_DB_USER;
    exports2.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
    exports2.SEMATTRS_DB_NAME = TMP_DB_NAME;
    exports2.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
    exports2.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
    exports2.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
    exports2.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
    exports2.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
    exports2.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
    exports2.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
    exports2.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
    exports2.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
    exports2.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
    exports2.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
    exports2.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
    exports2.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
    exports2.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
    exports2.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
    exports2.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    exports2.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    exports2.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
    exports2.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
    exports2.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
    exports2.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
    exports2.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
    exports2.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
    exports2.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
    exports2.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
    exports2.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
    exports2.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
    exports2.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
    exports2.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
    exports2.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
    exports2.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
    exports2.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
    exports2.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
    exports2.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
    exports2.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
    exports2.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
    exports2.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
    exports2.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
    exports2.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
    exports2.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
    exports2.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
    exports2.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
    exports2.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
    exports2.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
    exports2.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
    exports2.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
    exports2.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
    exports2.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
    exports2.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
    exports2.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
    exports2.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
    exports2.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
    exports2.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
    exports2.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
    exports2.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    exports2.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    exports2.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
    exports2.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    exports2.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    exports2.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    exports2.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
    exports2.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    exports2.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
    exports2.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
    exports2.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    exports2.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
    exports2.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
    exports2.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
    exports2.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
    exports2.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
    exports2.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
    exports2.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
    exports2.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
    exports2.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
    exports2.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
    exports2.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
    exports2.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
    exports2.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
    exports2.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
    exports2.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
    exports2.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
    exports2.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
    exports2.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
    exports2.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
    exports2.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
    exports2.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
    exports2.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
    exports2.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
    exports2.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
    exports2.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
    exports2.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
    exports2.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
    exports2.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
    exports2.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
    exports2.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
    exports2.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
    exports2.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
    exports2.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
    exports2.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
    exports2.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
    exports2.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
    exports2.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
    exports2.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
    exports2.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
    exports2.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
    exports2.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
    exports2.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
    exports2.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
    exports2.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
    exports2.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
    exports2.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
    exports2.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
    exports2.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
    exports2.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
    exports2.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
    exports2.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
    exports2.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
    exports2.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
    exports2.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
    exports2.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
    exports2.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
    exports2.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
    exports2.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
    var TMP_DBSYSTEMVALUES_DB2 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB = "edb";
    var TMP_DBSYSTEMVALUES_CACHE = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
    var TMP_DBSYSTEMVALUES_H2 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
    exports2.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
    exports2.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
    exports2.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
    exports2.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
    exports2.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
    exports2.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
    exports2.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
    exports2.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
    exports2.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
    exports2.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
    exports2.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
    exports2.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
    exports2.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
    exports2.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
    exports2.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
    exports2.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
    exports2.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
    exports2.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
    exports2.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
    exports2.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
    exports2.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
    exports2.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
    exports2.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
    exports2.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
    exports2.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
    exports2.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
    exports2.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
    exports2.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
    exports2.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
    exports2.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
    exports2.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
    exports2.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
    exports2.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
    exports2.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
    exports2.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
    exports2.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
    exports2.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
    exports2.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
    exports2.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
    exports2.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
    exports2.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
    exports2.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
    exports2.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
    exports2.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
    exports2.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
    exports2.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
    exports2.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
    exports2.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
    exports2.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
    exports2.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER = "other";
    exports2.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
    exports2.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
    exports2.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
    exports2.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
    exports2.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
    exports2.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
    exports2.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
    exports2.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
    exports2.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
    exports2.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
    exports2.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
    exports2.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
    exports2.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
    exports2.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
    exports2.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER = "other";
    exports2.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
    exports2.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
    exports2.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
    exports2.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
    exports2.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
    exports2.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
    exports2.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
    exports2.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
    exports2.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
    exports2.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
    exports2.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
    exports2.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
    exports2.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
    exports2.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
    exports2.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
    exports2.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
    exports2.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
    exports2.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
    exports2.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
    exports2.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
    exports2.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
    exports2.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
    exports2.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
    exports2.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
    exports2.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
    exports2.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
    exports2.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
    exports2.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
    exports2.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
    exports2.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
    exports2.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
    exports2.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
    exports2.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
    exports2.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
    exports2.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
    exports2.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
    exports2.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
    exports2.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
    exports2.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
    exports2.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
    exports2.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
    exports2.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
    exports2.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
    exports2.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
    exports2.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
    exports2.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    };
    var TMP_MESSAGETYPEVALUES_SENT = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
    exports2.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
    exports2.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
    exports2.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes(), exports2);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SEMRESATTRS_K8S_STATEFULSET_NAME = exports2.SEMRESATTRS_K8S_STATEFULSET_UID = exports2.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports2.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports2.SEMRESATTRS_K8S_REPLICASET_NAME = exports2.SEMRESATTRS_K8S_REPLICASET_UID = exports2.SEMRESATTRS_K8S_CONTAINER_NAME = exports2.SEMRESATTRS_K8S_POD_NAME = exports2.SEMRESATTRS_K8S_POD_UID = exports2.SEMRESATTRS_K8S_NAMESPACE_NAME = exports2.SEMRESATTRS_K8S_NODE_UID = exports2.SEMRESATTRS_K8S_NODE_NAME = exports2.SEMRESATTRS_K8S_CLUSTER_NAME = exports2.SEMRESATTRS_HOST_IMAGE_VERSION = exports2.SEMRESATTRS_HOST_IMAGE_ID = exports2.SEMRESATTRS_HOST_IMAGE_NAME = exports2.SEMRESATTRS_HOST_ARCH = exports2.SEMRESATTRS_HOST_TYPE = exports2.SEMRESATTRS_HOST_NAME = exports2.SEMRESATTRS_HOST_ID = exports2.SEMRESATTRS_FAAS_MAX_MEMORY = exports2.SEMRESATTRS_FAAS_INSTANCE = exports2.SEMRESATTRS_FAAS_VERSION = exports2.SEMRESATTRS_FAAS_ID = exports2.SEMRESATTRS_FAAS_NAME = exports2.SEMRESATTRS_DEVICE_MODEL_NAME = exports2.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports2.SEMRESATTRS_DEVICE_ID = exports2.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports2.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports2.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports2.SEMRESATTRS_CONTAINER_RUNTIME = exports2.SEMRESATTRS_CONTAINER_ID = exports2.SEMRESATTRS_CONTAINER_NAME = exports2.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports2.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports2.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports2.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports2.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports2.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports2.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports2.SEMRESATTRS_AWS_ECS_TASK_ARN = exports2.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports2.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports2.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports2.SEMRESATTRS_CLOUD_PLATFORM = exports2.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports2.SEMRESATTRS_CLOUD_REGION = exports2.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports2.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports2.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports2.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports2.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports2.CLOUDPLATFORMVALUES_AZURE_AKS = exports2.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports2.CLOUDPLATFORMVALUES_AZURE_VM = exports2.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports2.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports2.CLOUDPLATFORMVALUES_AWS_EKS = exports2.CLOUDPLATFORMVALUES_AWS_ECS = exports2.CLOUDPLATFORMVALUES_AWS_EC2 = exports2.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports2.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports2.CloudProviderValues = exports2.CLOUDPROVIDERVALUES_GCP = exports2.CLOUDPROVIDERVALUES_AZURE = exports2.CLOUDPROVIDERVALUES_AWS = exports2.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports2.SemanticResourceAttributes = exports2.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports2.SEMRESATTRS_WEBENGINE_VERSION = exports2.SEMRESATTRS_WEBENGINE_NAME = exports2.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports2.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports2.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports2.SEMRESATTRS_TELEMETRY_SDK_NAME = exports2.SEMRESATTRS_SERVICE_VERSION = exports2.SEMRESATTRS_SERVICE_INSTANCE_ID = exports2.SEMRESATTRS_SERVICE_NAMESPACE = exports2.SEMRESATTRS_SERVICE_NAME = exports2.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports2.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports2.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports2.SEMRESATTRS_PROCESS_OWNER = exports2.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports2.SEMRESATTRS_PROCESS_COMMAND_LINE = exports2.SEMRESATTRS_PROCESS_COMMAND = exports2.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports2.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports2.SEMRESATTRS_PROCESS_PID = exports2.SEMRESATTRS_OS_VERSION = exports2.SEMRESATTRS_OS_NAME = exports2.SEMRESATTRS_OS_DESCRIPTION = exports2.SEMRESATTRS_OS_TYPE = exports2.SEMRESATTRS_K8S_CRONJOB_NAME = exports2.SEMRESATTRS_K8S_CRONJOB_UID = exports2.SEMRESATTRS_K8S_JOB_NAME = exports2.SEMRESATTRS_K8S_JOB_UID = exports2.SEMRESATTRS_K8S_DAEMONSET_NAME = exports2.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports2.TelemetrySdkLanguageValues = exports2.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports2.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports2.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports2.TELEMETRYSDKLANGUAGEVALUES_PHP = exports2.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports2.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports2.TELEMETRYSDKLANGUAGEVALUES_GO = exports2.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports2.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports2.TELEMETRYSDKLANGUAGEVALUES_CPP = exports2.OsTypeValues = exports2.OSTYPEVALUES_Z_OS = exports2.OSTYPEVALUES_SOLARIS = exports2.OSTYPEVALUES_AIX = exports2.OSTYPEVALUES_HPUX = exports2.OSTYPEVALUES_DRAGONFLYBSD = exports2.OSTYPEVALUES_OPENBSD = exports2.OSTYPEVALUES_NETBSD = exports2.OSTYPEVALUES_FREEBSD = exports2.OSTYPEVALUES_DARWIN = exports2.OSTYPEVALUES_LINUX = exports2.OSTYPEVALUES_WINDOWS = exports2.HostArchValues = exports2.HOSTARCHVALUES_X86 = exports2.HOSTARCHVALUES_PPC64 = exports2.HOSTARCHVALUES_PPC32 = exports2.HOSTARCHVALUES_IA64 = exports2.HOSTARCHVALUES_ARM64 = exports2.HOSTARCHVALUES_ARM32 = exports2.HOSTARCHVALUES_AMD64 = exports2.AwsEcsLaunchtypeValues = exports2.AWSECSLAUNCHTYPEVALUES_FARGATE = exports2.AWSECSLAUNCHTYPEVALUES_EC2 = exports2.CloudPlatformValues = exports2.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports2.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports2.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports2.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils3();
    var TMP_CLOUD_PROVIDER = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
    var TMP_CLOUD_REGION = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME = "container.name";
    var TMP_CONTAINER_ID = "container.id";
    var TMP_CONTAINER_RUNTIME = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
    var TMP_DEVICE_ID = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME = "device.model.name";
    var TMP_FAAS_NAME = "faas.name";
    var TMP_FAAS_ID = "faas.id";
    var TMP_FAAS_VERSION = "faas.version";
    var TMP_FAAS_INSTANCE = "faas.instance";
    var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
    var TMP_HOST_ID = "host.id";
    var TMP_HOST_NAME = "host.name";
    var TMP_HOST_TYPE = "host.type";
    var TMP_HOST_ARCH = "host.arch";
    var TMP_HOST_IMAGE_NAME = "host.image.name";
    var TMP_HOST_IMAGE_ID = "host.image.id";
    var TMP_HOST_IMAGE_VERSION = "host.image.version";
    var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME = "k8s.node.name";
    var TMP_K8S_NODE_UID = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
    var TMP_K8S_POD_UID = "k8s.pod.uid";
    var TMP_K8S_POD_NAME = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID = "k8s.job.uid";
    var TMP_K8S_JOB_NAME = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
    var TMP_OS_TYPE = "os.type";
    var TMP_OS_DESCRIPTION = "os.description";
    var TMP_OS_NAME = "os.name";
    var TMP_OS_VERSION = "os.version";
    var TMP_PROCESS_PID = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
    var TMP_PROCESS_COMMAND = "process.command";
    var TMP_PROCESS_COMMAND_LINE = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
    var TMP_PROCESS_OWNER = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
    var TMP_SERVICE_NAME = "service.name";
    var TMP_SERVICE_NAMESPACE = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
    var TMP_SERVICE_VERSION = "service.version";
    var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME = "webengine.name";
    var TMP_WEBENGINE_VERSION = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
    exports2.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
    exports2.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
    exports2.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
    exports2.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
    exports2.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
    exports2.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
    exports2.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
    exports2.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
    exports2.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
    exports2.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
    exports2.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
    exports2.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
    exports2.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
    exports2.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
    exports2.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
    exports2.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
    exports2.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
    exports2.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
    exports2.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
    exports2.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
    exports2.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
    exports2.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
    exports2.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
    exports2.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
    exports2.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
    exports2.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
    exports2.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
    exports2.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
    exports2.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
    exports2.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
    exports2.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
    exports2.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
    exports2.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
    exports2.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
    exports2.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
    exports2.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
    exports2.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
    exports2.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
    exports2.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
    exports2.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
    exports2.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
    exports2.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
    exports2.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
    exports2.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
    exports2.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
    exports2.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
    exports2.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
    exports2.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
    exports2.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
    exports2.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
    exports2.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
    exports2.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
    exports2.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
    exports2.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
    exports2.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
    exports2.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
    exports2.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
    exports2.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
    exports2.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
    exports2.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
    exports2.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
    exports2.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
    exports2.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
    exports2.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
    exports2.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
    exports2.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
    exports2.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
    exports2.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    exports2.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
    exports2.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
    exports2.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    exports2.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
    exports2.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
    exports2.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
    exports2.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    exports2.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    exports2.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    exports2.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
    exports2.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
    exports2.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
    exports2.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
    exports2.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
    exports2.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
    exports2.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
    exports2.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
    exports2.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
    exports2.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
    exports2.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
    exports2.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
    exports2.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
    exports2.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
    exports2.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
    exports2.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
    exports2.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
    exports2.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
    exports2.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
    exports2.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
    exports2.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
    exports2.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
    exports2.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
    exports2.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
    exports2.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
    exports2.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
    exports2.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
    exports2.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
    exports2.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
    exports2.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
    exports2.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]);
    var TMP_HOSTARCHVALUES_AMD64 = "amd64";
    var TMP_HOSTARCHVALUES_ARM32 = "arm32";
    var TMP_HOSTARCHVALUES_ARM64 = "arm64";
    var TMP_HOSTARCHVALUES_IA64 = "ia64";
    var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
    var TMP_HOSTARCHVALUES_X86 = "x86";
    exports2.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
    exports2.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
    exports2.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
    exports2.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
    exports2.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
    exports2.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
    exports2.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
    exports2.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]);
    var TMP_OSTYPEVALUES_WINDOWS = "windows";
    var TMP_OSTYPEVALUES_LINUX = "linux";
    var TMP_OSTYPEVALUES_DARWIN = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX = "hpux";
    var TMP_OSTYPEVALUES_AIX = "aix";
    var TMP_OSTYPEVALUES_SOLARIS = "solaris";
    var TMP_OSTYPEVALUES_Z_OS = "z_os";
    exports2.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
    exports2.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
    exports2.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
    exports2.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
    exports2.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
    exports2.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
    exports2.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
    exports2.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
    exports2.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
    exports2.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
    exports2.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
    exports2.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
    exports2.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
    exports2.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
    exports2.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
    exports2.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
    exports2.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
    exports2.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
    exports2.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
    exports2.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
    exports2.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
    exports2.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
    exports2.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes(), exports2);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_trace(), exports2);
    __exportStar(require_resource(), exports2);
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDK_INFO = void 0;
    var version_1 = require_version();
    var semantic_conventions_1 = require_src2();
    exports2.SDK_INFO = {
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports2.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnv = exports2.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment2();
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    __exportStar(require_globalThis(), exports2);
    __exportStar(require_hex_to_base64(), exports2);
    __exportStar(require_RandomIdGenerator(), exports2);
    __exportStar(require_performance(), exports2);
    __exportStar(require_sdk_info(), exports2);
    __exportStar(require_timer_util(), exports2);
  }
});

// node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node2(), exports2);
  }
});

// node_modules/@opentelemetry/core/build/src/common/time.js
var require_time2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addHrTimes = exports2.isTimeInput = exports2.isTimeInputHrTime = exports2.hrTimeToMicroseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToNanoseconds = exports2.hrTimeToTimeStamp = exports2.hrTimeDuration = exports2.timeInputToHrTime = exports2.hrTime = exports2.getTimeOrigin = exports2.millisToHrTime = void 0;
    var platform_1 = require_platform();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports2.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports2.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports2.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports2.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports2.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports2.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports2.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports2.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports2.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports2.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports2.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports2.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/core/build/src/common/types.js
var require_types3 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports2.ExportResultCode || (exports2.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context2, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context2, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context2, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context2);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports2.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports2.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports2.validateValue = validateValue2;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceState = void 0;
    var validators_1 = require_validators();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CTraceContextPropagator = exports2.parseTraceParent = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var TraceState_1 = require_TraceState();
    exports2.TRACE_PARENT_HEADER = "traceparent";
    exports2.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports2.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context2, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context2);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context2) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports2.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports2.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context2, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports2.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context2;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context2;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context2;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports2.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context2, spanContext);
      }
      fields() {
        return [exports2.TRACE_PARENT_HEADER, exports2.TRACE_STATE_HEADER];
      }
    };
    exports2.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.setRPCMetadata = exports2.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports2.RPCType || (exports2.RPCType = {}));
    function setRPCMetadata(context2, meta) {
      return context2.setValue(RPC_METADATA_KEY, meta);
    }
    exports2.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context2) {
      return context2.deleteValue(RPC_METADATA_KEY);
    }
    exports2.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context2) {
      return context2.getValue(RPC_METADATA_KEY);
    }
    exports2.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context2, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context2);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context2, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          const pos = i * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports2.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      const result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lodash_merge_1 = require_lodash_merge();
    var MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    exports2.merge = merge;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (let i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              const obj1 = result[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        const info = arr[i];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callWithTimeout = exports2.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUrlIgnored = exports2.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports2.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports2.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWrapped = void 0;
    function isWrapped(func) {
      return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
    }
    exports2.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BindOnceFuture = void 0;
    var promise_1 = require_promise();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports2.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    exports2._export = _export;
  }
});

// node_modules/@opentelemetry/core/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.internal = exports2.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator(), exports2);
    __exportStar(require_anchored_clock(), exports2);
    __exportStar(require_attributes(), exports2);
    __exportStar(require_global_error_handler(), exports2);
    __exportStar(require_logging_error_handler(), exports2);
    __exportStar(require_time2(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_hex_to_binary(), exports2);
    __exportStar(require_ExportResult(), exports2);
    exports2.baggageUtils = require_utils2();
    __exportStar(require_platform(), exports2);
    __exportStar(require_composite(), exports2);
    __exportStar(require_W3CTraceContextPropagator(), exports2);
    __exportStar(require_IdGenerator(), exports2);
    __exportStar(require_rpc_metadata(), exports2);
    __exportStar(require_AlwaysOffSampler(), exports2);
    __exportStar(require_AlwaysOnSampler(), exports2);
    __exportStar(require_ParentBasedSampler(), exports2);
    __exportStar(require_TraceIdRatioBasedSampler(), exports2);
    __exportStar(require_suppress_tracing(), exports2);
    __exportStar(require_TraceState(), exports2);
    __exportStar(require_environment(), exports2);
    __exportStar(require_merge(), exports2);
    __exportStar(require_sampling(), exports2);
    __exportStar(require_timeout(), exports2);
    __exportStar(require_url2(), exports2);
    __exportStar(require_wrap(), exports2);
    __exportStar(require_callback(), exports2);
    __exportStar(require_version(), exports2);
    var exporter_1 = require_exporter();
    exports2.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js
var require_LastValue = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LastValueAggregator = exports2.LastValueAccumulation = void 0;
    var types_1 = require_types();
    var core_1 = require_src3();
    var MetricData_1 = require_MetricData();
    var LastValueAccumulation = class {
      constructor(startTime, _current = 0, sampleTime = [0, 0]) {
        this.startTime = startTime;
        this._current = _current;
        this.sampleTime = sampleTime;
      }
      record(value) {
        this._current = value;
        this.sampleTime = (0, core_1.millisToHrTime)(Date.now());
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports2.LastValueAccumulation = LastValueAccumulation;
    var LastValueAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.LAST_VALUE;
      }
      createAccumulation(startTime) {
        return new LastValueAccumulation(startTime);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       *
       * Return the newly captured (delta) accumulation for LastValueAggregator.
       */
      merge(previous, delta) {
        const latestAccumulation = (0, core_1.hrTimeToMicroseconds)(delta.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       *
       * A delta aggregation is not meaningful to LastValueAggregator, just return
       * the newly captured (delta) accumulation for LastValueAggregator.
       */
      diff(previous, current) {
        const latestAccumulation = (0, core_1.hrTimeToMicroseconds)(current.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.GAUGE,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: accumulation.toPointValue()
            };
          })
        };
      }
    };
    exports2.LastValueAggregator = LastValueAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js
var require_Sum = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SumAggregator = exports2.SumAccumulation = void 0;
    var types_1 = require_types();
    var MetricData_1 = require_MetricData();
    var SumAccumulation = class {
      constructor(startTime, monotonic, _current = 0, reset = false) {
        this.startTime = startTime;
        this.monotonic = monotonic;
        this._current = _current;
        this.reset = reset;
      }
      record(value) {
        if (this.monotonic && value < 0) {
          return;
        }
        this._current += value;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports2.SumAccumulation = SumAccumulation;
    var SumAggregator = class {
      constructor(monotonic) {
        this.monotonic = monotonic;
        this.kind = types_1.AggregatorKind.SUM;
      }
      createAccumulation(startTime) {
        return new SumAccumulation(startTime, this.monotonic);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       */
      merge(previous, delta) {
        const prevPv = previous.toPointValue();
        const deltaPv = delta.toPointValue();
        if (delta.reset) {
          return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);
        }
        return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        const prevPv = previous.toPointValue();
        const currPv = current.toPointValue();
        if (this.monotonic && prevPv > currPv) {
          return new SumAccumulation(current.startTime, this.monotonic, currPv, true);
        }
        return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.SUM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: accumulation.toPointValue()
            };
          }),
          isMonotonic: this.monotonic
        };
      }
    };
    exports2.SumAggregator = SumAggregator;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js
var require_aggregator = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Drop(), exports2);
    __exportStar(require_Histogram2(), exports2);
    __exportStar(require_ExponentialHistogram(), exports2);
    __exportStar(require_LastValue(), exports2);
    __exportStar(require_Sum(), exports2);
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js
var require_Aggregation = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultAggregation = exports2.ExponentialHistogramAggregation = exports2.ExplicitBucketHistogramAggregation = exports2.HistogramAggregation = exports2.LastValueAggregation = exports2.SumAggregation = exports2.DropAggregation = exports2.Aggregation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var aggregator_1 = require_aggregator();
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Aggregation = class {
      static Drop() {
        return DROP_AGGREGATION;
      }
      static Sum() {
        return SUM_AGGREGATION;
      }
      static LastValue() {
        return LAST_VALUE_AGGREGATION;
      }
      static Histogram() {
        return HISTOGRAM_AGGREGATION;
      }
      static ExponentialHistogram() {
        return EXPONENTIAL_HISTOGRAM_AGGREGATION;
      }
      static Default() {
        return DEFAULT_AGGREGATION;
      }
    };
    exports2.Aggregation = Aggregation;
    var DropAggregation = class _DropAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _DropAggregation.DEFAULT_INSTANCE;
      }
    };
    exports2.DropAggregation = DropAggregation;
    DropAggregation.DEFAULT_INSTANCE = new aggregator_1.DropAggregator();
    var SumAggregation = class _SumAggregation extends Aggregation {
      createAggregator(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM: {
            return _SumAggregation.MONOTONIC_INSTANCE;
          }
          default: {
            return _SumAggregation.NON_MONOTONIC_INSTANCE;
          }
        }
      }
    };
    exports2.SumAggregation = SumAggregation;
    SumAggregation.MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(true);
    SumAggregation.NON_MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(false);
    var LastValueAggregation = class _LastValueAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _LastValueAggregation.DEFAULT_INSTANCE;
      }
    };
    exports2.LastValueAggregation = LastValueAggregation;
    LastValueAggregation.DEFAULT_INSTANCE = new aggregator_1.LastValueAggregator();
    var HistogramAggregation = class _HistogramAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _HistogramAggregation.DEFAULT_INSTANCE;
      }
    };
    exports2.HistogramAggregation = HistogramAggregation;
    HistogramAggregation.DEFAULT_INSTANCE = new aggregator_1.HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1e3, 2500, 5e3, 7500, 1e4], true);
    var ExplicitBucketHistogramAggregation = class extends Aggregation {
      /**
       * @param boundaries the bucket boundaries of the histogram aggregation
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(boundaries, _recordMinMax = true) {
        super();
        this._recordMinMax = _recordMinMax;
        if (boundaries == null) {
          throw new Error("ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array");
        }
        boundaries = boundaries.concat();
        boundaries = boundaries.sort((a, b) => a - b);
        const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);
        let infinityIndex = boundaries.indexOf(Infinity);
        if (infinityIndex === -1) {
          infinityIndex = void 0;
        }
        this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
      }
      createAggregator(_instrument) {
        return new aggregator_1.HistogramAggregator(this._boundaries, this._recordMinMax);
      }
    };
    exports2.ExplicitBucketHistogramAggregation = ExplicitBucketHistogramAggregation;
    var ExponentialHistogramAggregation = class extends Aggregation {
      constructor(_maxSize = 160, _recordMinMax = true) {
        super();
        this._maxSize = _maxSize;
        this._recordMinMax = _recordMinMax;
      }
      createAggregator(_instrument) {
        return new aggregator_1.ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
      }
    };
    exports2.ExponentialHistogramAggregation = ExponentialHistogramAggregation;
    var DefaultAggregation = class extends Aggregation {
      _resolve(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {
            return SUM_AGGREGATION;
          }
          case InstrumentDescriptor_1.InstrumentType.GAUGE:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE: {
            return LAST_VALUE_AGGREGATION;
          }
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM: {
            if (instrument.advice.explicitBucketBoundaries) {
              return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);
            }
            return HISTOGRAM_AGGREGATION;
          }
        }
        api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);
        return DROP_AGGREGATION;
      }
      createAggregator(instrument) {
        return this._resolve(instrument).createAggregator(instrument);
      }
    };
    exports2.DefaultAggregation = DefaultAggregation;
    var DROP_AGGREGATION = new DropAggregation();
    var SUM_AGGREGATION = new SumAggregation();
    var LAST_VALUE_AGGREGATION = new LastValueAggregation();
    var HISTOGRAM_AGGREGATION = new HistogramAggregation();
    var EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();
    var DEFAULT_AGGREGATION = new DefaultAggregation();
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js
var require_AggregationSelector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = exports2.DEFAULT_AGGREGATION_SELECTOR = void 0;
    var Aggregation_1 = require_Aggregation();
    var AggregationTemporality_1 = require_AggregationTemporality();
    var DEFAULT_AGGREGATION_SELECTOR = (_instrumentType) => Aggregation_1.Aggregation.Default();
    exports2.DEFAULT_AGGREGATION_SELECTOR = DEFAULT_AGGREGATION_SELECTOR;
    var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = (_instrumentType) => AggregationTemporality_1.AggregationTemporality.CUMULATIVE;
    exports2.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js
var require_MetricReader = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetricReader = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils();
    var AggregationSelector_1 = require_AggregationSelector();
    var MetricReader = class {
      constructor(options) {
        var _a, _b, _c;
        this._shutdown = false;
        this._aggregationSelector = (_a = options === null || options === void 0 ? void 0 : options.aggregationSelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_SELECTOR;
        this._aggregationTemporalitySelector = (_b = options === null || options === void 0 ? void 0 : options.aggregationTemporalitySelector) !== null && _b !== void 0 ? _b : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
        this._metricProducers = (_c = options === null || options === void 0 ? void 0 : options.metricProducers) !== null && _c !== void 0 ? _c : [];
      }
      /**
       * Set the {@link MetricProducer} used by this instance. **This should only be called by the
       * SDK and should be considered internal.**
       *
       * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the
       * constructor as {@link MetricReaderOptions.metricProducers}.
       *
       * @internal
       * @param metricProducer
       */
      setMetricProducer(metricProducer) {
        if (this._sdkMetricProducer) {
          throw new Error("MetricReader can not be bound to a MeterProvider again.");
        }
        this._sdkMetricProducer = metricProducer;
        this.onInitialized();
      }
      /**
       * Select the {@link Aggregation} for the given {@link InstrumentType} for this
       * reader.
       */
      selectAggregation(instrumentType) {
        return this._aggregationSelector(instrumentType);
      }
      /**
       * Select the {@link AggregationTemporality} for the given
       * {@link InstrumentType} for this reader.
       */
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
      /**
       * Handle once the SDK has initialized this {@link MetricReader}
       * Overriding this method is optional.
       */
      onInitialized() {
      }
      /**
       * Collect all metrics from the associated {@link MetricProducer}
       */
      async collect(options) {
        if (this._sdkMetricProducer === void 0) {
          throw new Error("MetricReader is not bound to a MetricProducer");
        }
        if (this._shutdown) {
          throw new Error("MetricReader is shutdown");
        }
        const [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([
          this._sdkMetricProducer.collect({
            timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
          }),
          ...this._metricProducers.map((producer) => producer.collect({
            timeoutMillis: options === null || options === void 0 ? void 0 : options.timeoutMillis
          }))
        ]);
        const errors = sdkCollectionResults.errors.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.errors));
        const resource = sdkCollectionResults.resourceMetrics.resource;
        const scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.resourceMetrics.scopeMetrics));
        return {
          resourceMetrics: {
            resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api.diag.error("Cannot call shutdown twice.");
          return;
        }
        if ((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null) {
          await this.onShutdown();
        } else {
          await (0, utils_1.callWithTimeout)(this.onShutdown(), options.timeoutMillis);
        }
        this._shutdown = true;
      }
      /**
       * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api.diag.warn("Cannot forceFlush on already shutdown MetricReader.");
          return;
        }
        if ((options === null || options === void 0 ? void 0 : options.timeoutMillis) == null) {
          await this.onForceFlush();
          return;
        }
        await (0, utils_1.callWithTimeout)(this.onForceFlush(), options.timeoutMillis);
      }
    };
    exports2.MetricReader = MetricReader;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js
var require_PeriodicExportingMetricReader = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PeriodicExportingMetricReader = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src3();
    var MetricReader_1 = require_MetricReader();
    var utils_1 = require_utils();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var PeriodicExportingMetricReader = class extends MetricReader_1.MetricReader {
      constructor(options) {
        var _a, _b, _c, _d;
        super({
          aggregationSelector: (_a = options.exporter.selectAggregation) === null || _a === void 0 ? void 0 : _a.bind(options.exporter),
          aggregationTemporalitySelector: (_b = options.exporter.selectAggregationTemporality) === null || _b === void 0 ? void 0 : _b.bind(options.exporter),
          metricProducers: options.metricProducers
        });
        if (options.exportIntervalMillis !== void 0 && options.exportIntervalMillis <= 0) {
          throw Error("exportIntervalMillis must be greater than 0");
        }
        if (options.exportTimeoutMillis !== void 0 && options.exportTimeoutMillis <= 0) {
          throw Error("exportTimeoutMillis must be greater than 0");
        }
        if (options.exportTimeoutMillis !== void 0 && options.exportIntervalMillis !== void 0 && options.exportIntervalMillis < options.exportTimeoutMillis) {
          throw Error("exportIntervalMillis must be greater than or equal to exportTimeoutMillis");
        }
        this._exportInterval = (_c = options.exportIntervalMillis) !== null && _c !== void 0 ? _c : 6e4;
        this._exportTimeout = (_d = options.exportTimeoutMillis) !== null && _d !== void 0 ? _d : 3e4;
        this._exporter = options.exporter;
      }
      async _runOnce() {
        try {
          await (0, utils_1.callWithTimeout)(this._doRun(), this._exportTimeout);
        } catch (err) {
          if (err instanceof utils_1.TimeoutError) {
            api.diag.error("Export took longer than %s milliseconds and timed out.", this._exportTimeout);
            return;
          }
          (0, core_1.globalErrorHandler)(err);
        }
      }
      async _doRun() {
        var _a, _b;
        const { resourceMetrics, errors } = await this.collect({
          timeoutMillis: this._exportTimeout
        });
        if (errors.length > 0) {
          api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors);
        }
        const doExport = async () => {
          const result = await core_1.internal._export(this._exporter, resourceMetrics);
          if (result.code !== core_1.ExportResultCode.SUCCESS) {
            throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);
          }
        };
        if (resourceMetrics.resource.asyncAttributesPending) {
          (_b = (_a = resourceMetrics.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a).then(doExport, (err) => api_1.diag.debug("Error while resolving async portion of resource: ", err));
        } else {
          await doExport();
        }
      }
      onInitialized() {
        this._interval = setInterval(() => {
          void this._runOnce();
        }, this._exportInterval);
        (0, core_1.unrefTimer)(this._interval);
      }
      async onForceFlush() {
        await this._runOnce();
        await this._exporter.forceFlush();
      }
      async onShutdown() {
        if (this._interval) {
          clearInterval(this._interval);
        }
        await this._exporter.shutdown();
      }
    };
    exports2.PeriodicExportingMetricReader = PeriodicExportingMetricReader;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js
var require_InMemoryMetricExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryMetricExporter = void 0;
    var core_1 = require_src3();
    var InMemoryMetricExporter = class {
      constructor(aggregationTemporality) {
        this._shutdown = false;
        this._metrics = [];
        this._aggregationTemporality = aggregationTemporality;
      }
      /**
       * @inheritedDoc
       */
      export(metrics2, resultCallback) {
        if (this._shutdown) {
          setTimeout(() => resultCallback({ code: core_1.ExportResultCode.FAILED }), 0);
          return;
        }
        this._metrics.push(metrics2);
        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      /**
       * Returns all the collected resource metrics
       * @returns ResourceMetrics[]
       */
      getMetrics() {
        return this._metrics;
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._metrics = [];
      }
      selectAggregationTemporality(_instrumentType) {
        return this._aggregationTemporality;
      }
      shutdown() {
        this._shutdown = true;
        return Promise.resolve();
      }
    };
    exports2.InMemoryMetricExporter = InMemoryMetricExporter;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js
var require_ConsoleMetricExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleMetricExporter = void 0;
    var core_1 = require_src3();
    var AggregationSelector_1 = require_AggregationSelector();
    var ConsoleMetricExporter = class _ConsoleMetricExporter {
      constructor(options) {
        var _a;
        this._shutdown = false;
        this._temporalitySelector = (_a = options === null || options === void 0 ? void 0 : options.temporalitySelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
      }
      export(metrics2, resultCallback) {
        if (this._shutdown) {
          setImmediate(resultCallback, { code: core_1.ExportResultCode.FAILED });
          return;
        }
        return _ConsoleMetricExporter._sendMetrics(metrics2, resultCallback);
      }
      forceFlush() {
        return Promise.resolve();
      }
      selectAggregationTemporality(_instrumentType) {
        return this._temporalitySelector(_instrumentType);
      }
      shutdown() {
        this._shutdown = true;
        return Promise.resolve();
      }
      static _sendMetrics(metrics2, done) {
        for (const scopeMetrics of metrics2.scopeMetrics) {
          for (const metric of scopeMetrics.metrics) {
            console.dir({
              descriptor: metric.descriptor,
              dataPointType: metric.dataPointType,
              dataPoints: metric.dataPoints
            }, { depth: null });
          }
        }
        done({ code: core_1.ExportResultCode.SUCCESS });
      }
    };
    exports2.ConsoleMetricExporter = ConsoleMetricExporter;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports2.defaultServiceName = defaultServiceName;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    var default_service_name_1 = require_default_service_name();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: true, get: function() {
      return default_service_name_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform2 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    var node_1 = require_node3();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: true, get: function() {
      return node_1.defaultServiceName;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/Resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Resource = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = require_src2();
    var core_1 = require_src3();
    var platform_1 = require_platform2();
    var Resource = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then((asyncAttributes) => {
          this._attributes = Object.assign({}, this._attributes, asyncAttributes);
          this.asyncAttributesPending = false;
          return asyncAttributes;
        }, (err) => {
          api_1.diag.debug("a resource's async attributes promise rejected: %s", err);
          this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a;
        if (this.asyncAttributesPending) {
          api_1.diag.error("Accessing resource attributes before async attributes settled");
        }
        return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        if (this.asyncAttributesPending) {
          await this._asyncAttributesPromise;
        }
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a;
        if (!other)
          return this;
        const mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new _Resource(mergedSyncAttributes);
        }
        const mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a2;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports2.Resource = Resource;
    Resource.EMPTY = new Resource({});
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeType = exports2.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports2.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports2.normalizeType = normalizeType;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.execAsync = void 0;
    var child_process = require("child_process");
    var util = require("util");
    exports2.execAsync = util.promisify(child_process.exec);
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
        const idLine = result.stdout.split("\n").find((line) => line.includes("IOPlatformUUID"));
        if (!idLine) {
          return "";
        }
        const parts = idLine.split('" = "');
        if (parts.length === 2) {
          return parts[1].slice(0, -1);
        }
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var fs_1 = require("fs");
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (const path of paths) {
        try {
          const result = await fs_1.promises.readFile(path, { encoding: "utf8" });
          return result.trim();
        } catch (e) {
          api_1.diag.debug(`error reading machine id: ${e}`);
        }
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var fs_1 = require("fs");
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        const result = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
        return result.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      try {
        const result = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
        return result.stdout.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var process2 = require("process");
    var execAsync_1 = require_execAsync();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
      let command = "%windir%\\System32\\REG.exe";
      if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
        command = "%windir%\\sysnative\\cmd.exe /c " + command;
      }
      try {
        const result = await (0, execAsync_1.execAsync)(`${command} ${args}`);
        const parts = result.stdout.split("REG_SZ");
        if (parts.length === 2) {
          return parts[1].trim();
        }
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      api_1.diag.debug("could not read machine-id: unsupported platform");
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var process2 = require("process");
    var getMachineId;
    exports2.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports2.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
        break;
      case "linux":
        exports2.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
        break;
      case "freebsd":
        exports2.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
        break;
      case "win32":
        exports2.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
        break;
      default:
        exports2.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
    }
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hostDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var os_1 = require("os");
    var utils_1 = require_utils4();
    var getMachineId_1 = require_getMachineId();
    var HostDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SEMRESATTRS_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          const attributes = {};
          if (machineId) {
            attributes[semantic_conventions_1.SEMRESATTRS_HOST_ID] = machineId;
          }
          return attributes;
        });
      }
    };
    exports2.hostDetectorSync = new HostDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync();
    var HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports2.hostDetector = new HostDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.osDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var os_1 = require("os");
    var utils_1 = require_utils4();
    var OSDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SEMRESATTRS_OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.osDetectorSync = new OSDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync();
    var OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports2.osDetector = new OSDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var os = require("os");
    var ProcessDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_PID]: process.pid,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        if (process.argv.length > 1) {
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND] = process.argv[1];
        }
        try {
          const userInfo = os.userInfo();
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.processDetectorSync = new ProcessDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    var ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports2.processDetector = new ProcessDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js
var require_ServiceInstanceIdDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceInstanceIdDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var crypto_1 = require("crypto");
    var ServiceInstanceIdDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.serviceInstanceIdDetectorSync = new ServiceInstanceIdDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var HostDetector_1 = require_HostDetector();
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return HostDetector_1.hostDetector;
    } });
    var HostDetectorSync_1 = require_HostDetectorSync();
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return HostDetectorSync_1.hostDetectorSync;
    } });
    var OSDetector_1 = require_OSDetector();
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return OSDetector_1.osDetector;
    } });
    var OSDetectorSync_1 = require_OSDetectorSync();
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return OSDetectorSync_1.osDetectorSync;
    } });
    var ProcessDetector_1 = require_ProcessDetector();
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return ProcessDetector_1.processDetector;
    } });
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return ProcessDetectorSync_1.processDetectorSync;
    } });
    var ServiceInstanceIdDetectorSync_1 = require_ServiceInstanceIdDetectorSync();
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return ServiceInstanceIdDetectorSync_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var node_1 = require_node4();
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return node_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return node_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return node_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return node_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return node_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return node_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return node_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.browserDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Resource_1 = require_Resource();
    var BrowserDetectorSync = class {
      detect(config) {
        var _a, _b, _c;
        const isBrowser = typeof navigator !== "undefined" && ((_b = (_a = global.process) === null || _a === void 0 ? void 0 : _a.versions) === null || _b === void 0 ? void 0 : _b.node) === void 0 && // Node.js v21 adds `navigator`
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore don't have Bun types
        ((_c = global.Bun) === null || _c === void 0 ? void 0 : _c.version) === void 0;
        if (!isBrowser) {
          return Resource_1.Resource.empty();
        }
        const browserResource = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        if (browserResource[semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION] === "") {
          api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return Resource_1.Resource.empty();
        } else {
          return new Resource_1.Resource(Object.assign({}, browserResource));
        }
      }
    };
    exports2.browserDetectorSync = new BrowserDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.browserDetector = void 0;
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    var BrowserDetector = class {
      detect(config) {
        return Promise.resolve(BrowserDetectorSync_1.browserDetectorSync.detect(config));
      }
    };
    exports2.browserDetector = new BrowserDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src3();
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        const attributes = {};
        const env = (0, core_1.getEnv)();
        const rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES;
        const serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes) {
          try {
            const parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e) {
            api_1.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        }
        if (serviceName) {
          attributes[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME] = serviceName;
        }
        return new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. “key1=val1,key2=val2”. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespace, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-separated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        const attributes = {};
        const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (const rawAttribute of rawAttributes) {
          const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2) {
            continue;
          }
          let [key, value] = keyValuePair;
          key = key.trim();
          value = value.trim().split(/^"|"$/).join("");
          if (!this._isValidAndNotEmpty(key)) {
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          }
          if (!this._isValid(value)) {
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          }
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          const ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports2.envDetectorSync = new EnvDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    var EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports2.envDetector = new EnvDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetectorSync = exports2.browserDetectorSync = exports2.envDetector = exports2.browserDetector = exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var platform_1 = require_platform3();
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return platform_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return platform_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return platform_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return platform_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return platform_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return platform_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return platform_1.serviceInstanceIdDetectorSync;
    } });
    var BrowserDetector_1 = require_BrowserDetector();
    Object.defineProperty(exports2, "browserDetector", { enumerable: true, get: function() {
      return BrowserDetector_1.browserDetector;
    } });
    var EnvDetector_1 = require_EnvDetector();
    Object.defineProperty(exports2, "envDetector", { enumerable: true, get: function() {
      return EnvDetector_1.envDetector;
    } });
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    Object.defineProperty(exports2, "browserDetectorSync", { enumerable: true, get: function() {
      return BrowserDetectorSync_1.browserDetectorSync;
    } });
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    Object.defineProperty(exports2, "envDetectorSync", { enumerable: true, get: function() {
      return EnvDetectorSync_1.envDetectorSync;
    } });
  }
});

// node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils5 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromiseLike = void 0;
    var isPromiseLike = (val) => {
      return val !== null && typeof val === "object" && typeof val.then === "function";
    };
    exports2.isPromiseLike = isPromiseLike;
  }
});

// node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectResourcesSync = exports2.detectResources = void 0;
    var Resource_1 = require_Resource();
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var utils_1 = require_utils5();
    var detectResources = async (config = {}) => {
      const resources = await Promise.all((config.detectors || []).map(async (d) => {
        try {
          const resource = await d.detect(config);
          api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
          return resource;
        } catch (e) {
          api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`);
          return Resource_1.Resource.empty();
        }
      }));
      logResources(resources);
      return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports2.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a;
      const resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map((d) => {
        try {
          const resourceOrPromise = d.detect(config);
          let resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            const createPromise = async () => {
              const resolvedResource = await resourceOrPromise;
              return resolvedResource.attributes;
            };
            resource = new Resource_1.Resource({}, createPromise());
          } else {
            resource = resourceOrPromise;
          }
          if (resource.waitForAsyncAttributes) {
            void resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource));
          } else {
            api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
          }
          return resource;
        } catch (e) {
          api_1.diag.error(`${d.constructor.name} failed: ${e.message}`);
          return Resource_1.Resource.empty();
        }
      });
      const mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(() => {
          logResources(resources);
        });
      }
      return mergedResources;
    };
    exports2.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          const resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// node_modules/@opentelemetry/resources/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectResources = exports2.detectResourcesSync = exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = exports2.envDetectorSync = exports2.envDetector = exports2.browserDetectorSync = exports2.browserDetector = exports2.defaultServiceName = exports2.Resource = void 0;
    var Resource_1 = require_Resource();
    Object.defineProperty(exports2, "Resource", { enumerable: true, get: function() {
      return Resource_1.Resource;
    } });
    var platform_1 = require_platform2();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: true, get: function() {
      return platform_1.defaultServiceName;
    } });
    var detectors_1 = require_detectors();
    Object.defineProperty(exports2, "browserDetector", { enumerable: true, get: function() {
      return detectors_1.browserDetector;
    } });
    Object.defineProperty(exports2, "browserDetectorSync", { enumerable: true, get: function() {
      return detectors_1.browserDetectorSync;
    } });
    Object.defineProperty(exports2, "envDetector", { enumerable: true, get: function() {
      return detectors_1.envDetector;
    } });
    Object.defineProperty(exports2, "envDetectorSync", { enumerable: true, get: function() {
      return detectors_1.envDetectorSync;
    } });
    Object.defineProperty(exports2, "hostDetector", { enumerable: true, get: function() {
      return detectors_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: true, get: function() {
      return detectors_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: true, get: function() {
      return detectors_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: true, get: function() {
      return detectors_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: true, get: function() {
      return detectors_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: true, get: function() {
      return detectors_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: true, get: function() {
      return detectors_1.serviceInstanceIdDetectorSync;
    } });
    var detect_resources_1 = require_detect_resources();
    Object.defineProperty(exports2, "detectResourcesSync", { enumerable: true, get: function() {
      return detect_resources_1.detectResourcesSync;
    } });
    Object.defineProperty(exports2, "detectResources", { enumerable: true, get: function() {
      return detect_resources_1.detectResources;
    } });
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js
var require_ViewRegistry = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewRegistry = void 0;
    var ViewRegistry = class {
      constructor() {
        this._registeredViews = [];
      }
      addView(view) {
        this._registeredViews.push(view);
      }
      findViews(instrument, meter) {
        const views = this._registeredViews.filter((registeredView) => {
          return this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter);
        });
        return views;
      }
      _matchInstrument(selector, instrument) {
        return (selector.getType() === void 0 || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
      }
      _matchMeter(selector, meter) {
        return selector.getNameFilter().match(meter.name) && (meter.version === void 0 || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === void 0 || selector.getSchemaUrlFilter().match(meter.schemaUrl));
      }
    };
    exports2.ViewRegistry = ViewRegistry;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js
var require_Instruments = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObservableInstrument = exports2.ObservableUpDownCounterInstrument = exports2.ObservableGaugeInstrument = exports2.ObservableCounterInstrument = exports2.ObservableInstrument = exports2.HistogramInstrument = exports2.GaugeInstrument = exports2.CounterInstrument = exports2.UpDownCounterInstrument = exports2.SyncInstrument = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var core_1 = require_src3();
    var SyncInstrument = class {
      constructor(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage;
        this._descriptor = _descriptor;
      }
      _record(value, attributes = {}, context2 = api_1.context.active()) {
        if (typeof value !== "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        if (this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
          api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`);
          value = Math.trunc(value);
          if (!Number.isInteger(value)) {
            return;
          }
        }
        this._writableMetricStorage.record(value, attributes, context2, (0, core_1.millisToHrTime)(Date.now()));
      }
    };
    exports2.SyncInstrument = SyncInstrument;
    var UpDownCounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may be negative.
       */
      add(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports2.UpDownCounterInstrument = UpDownCounterInstrument;
    var CounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may not be negative.
       */
      add(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports2.CounterInstrument = CounterInstrument;
    var GaugeInstrument = class extends SyncInstrument {
      /**
       * Records a measurement.
       */
      record(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports2.GaugeInstrument = GaugeInstrument;
    var HistogramInstrument = class extends SyncInstrument {
      /**
       * Records a measurement. Value of the measurement must not be negative.
       */
      record(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports2.HistogramInstrument = HistogramInstrument;
    var ObservableInstrument = class {
      constructor(descriptor, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry;
        this._descriptor = descriptor;
        this._metricStorages = metricStorages;
      }
      /**
       * @see {Observable.addCallback}
       */
      addCallback(callback) {
        this._observableRegistry.addCallback(callback, this);
      }
      /**
       * @see {Observable.removeCallback}
       */
      removeCallback(callback) {
        this._observableRegistry.removeCallback(callback, this);
      }
    };
    exports2.ObservableInstrument = ObservableInstrument;
    var ObservableCounterInstrument = class extends ObservableInstrument {
    };
    exports2.ObservableCounterInstrument = ObservableCounterInstrument;
    var ObservableGaugeInstrument = class extends ObservableInstrument {
    };
    exports2.ObservableGaugeInstrument = ObservableGaugeInstrument;
    var ObservableUpDownCounterInstrument = class extends ObservableInstrument {
    };
    exports2.ObservableUpDownCounterInstrument = ObservableUpDownCounterInstrument;
    function isObservableInstrument(it) {
      return it instanceof ObservableInstrument;
    }
    exports2.isObservableInstrument = isObservableInstrument;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js
var require_Meter2 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Meter = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Instruments_1 = require_Instruments();
    var Meter = class {
      constructor(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
      }
      /**
       * Create a {@link Gauge} instrument.
       */
      createGauge(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.GAUGE, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.GaugeInstrument(storage, descriptor);
      }
      /**
       * Create a {@link Histogram} instrument.
       */
      createHistogram(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.HISTOGRAM, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.HistogramInstrument(storage, descriptor);
      }
      /**
       * Create a {@link Counter} instrument.
       */
      createCounter(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.COUNTER, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.CounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link UpDownCounter} instrument.
       */
      createUpDownCounter(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER, options);
        const storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.UpDownCounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link ObservableGauge} instrument.
       */
      createObservableGauge(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE, options);
        const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableCounter} instrument.
       */
      createObservableCounter(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER, options);
        const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableUpDownCounter} instrument.
       */
      createObservableUpDownCounter(name, options) {
        const descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options);
        const storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
      }
    };
    exports2.Meter = Meter;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js
var require_MetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetricStorage = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var MetricStorage = class {
      constructor(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
      }
      getInstrumentDescriptor() {
        return this._instrumentDescriptor;
      }
      updateDescription(description) {
        this._instrumentDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
          description,
          valueType: this._instrumentDescriptor.valueType,
          unit: this._instrumentDescriptor.unit,
          advice: this._instrumentDescriptor.advice
        });
      }
    };
    exports2.MetricStorage = MetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js
var require_HashMap = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeHashMap = exports2.HashMap = void 0;
    var utils_1 = require_utils();
    var HashMap = class {
      constructor(_hash) {
        this._hash = _hash;
        this._valueMap = /* @__PURE__ */ new Map();
        this._keyMap = /* @__PURE__ */ new Map();
      }
      get(key, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : hashCode = this._hash(key);
        return this._valueMap.get(hashCode);
      }
      getOrDefault(key, defaultFactory) {
        const hash = this._hash(key);
        if (this._valueMap.has(hash)) {
          return this._valueMap.get(hash);
        }
        const val = defaultFactory();
        if (!this._keyMap.has(hash)) {
          this._keyMap.set(hash, key);
        }
        this._valueMap.set(hash, val);
        return val;
      }
      set(key, value, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : hashCode = this._hash(key);
        if (!this._keyMap.has(hashCode)) {
          this._keyMap.set(hashCode, key);
        }
        this._valueMap.set(hashCode, value);
      }
      has(key, hashCode) {
        hashCode !== null && hashCode !== void 0 ? hashCode : hashCode = this._hash(key);
        return this._valueMap.has(hashCode);
      }
      *keys() {
        const keyIterator = this._keyMap.entries();
        let next = keyIterator.next();
        while (next.done !== true) {
          yield [next.value[1], next.value[0]];
          next = keyIterator.next();
        }
      }
      *entries() {
        const valueIterator = this._valueMap.entries();
        let next = valueIterator.next();
        while (next.done !== true) {
          yield [this._keyMap.get(next.value[0]), next.value[1], next.value[0]];
          next = valueIterator.next();
        }
      }
      get size() {
        return this._valueMap.size;
      }
    };
    exports2.HashMap = HashMap;
    var AttributeHashMap = class extends HashMap {
      constructor() {
        super(utils_1.hashAttributes);
      }
    };
    exports2.AttributeHashMap = AttributeHashMap;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js
var require_DeltaMetricProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeltaMetricProcessor = void 0;
    var HashMap_1 = require_HashMap();
    var DeltaMetricProcessor = class {
      constructor(_aggregator) {
        this._aggregator = _aggregator;
        this._activeCollectionStorage = new HashMap_1.AttributeHashMap();
        this._cumulativeMemoStorage = new HashMap_1.AttributeHashMap();
      }
      record(value, attributes, _context, collectionTime) {
        const accumulation = this._activeCollectionStorage.getOrDefault(attributes, () => this._aggregator.createAccumulation(collectionTime));
        accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);
      }
      batchCumulate(measurements, collectionTime) {
        Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {
          const accumulation = this._aggregator.createAccumulation(collectionTime);
          accumulation === null || accumulation === void 0 ? void 0 : accumulation.record(value);
          let delta = accumulation;
          if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
            const previous = this._cumulativeMemoStorage.get(attributes, hashCode);
            delta = this._aggregator.diff(previous, accumulation);
          }
          if (this._activeCollectionStorage.has(attributes, hashCode)) {
            const active = this._activeCollectionStorage.get(attributes, hashCode);
            delta = this._aggregator.merge(active, delta);
          }
          this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);
          this._activeCollectionStorage.set(attributes, delta, hashCode);
        });
      }
      /**
       * Returns a collection of delta metrics. Start time is the when first
       * time event collected.
       */
      collect() {
        const unreportedDelta = this._activeCollectionStorage;
        this._activeCollectionStorage = new HashMap_1.AttributeHashMap();
        return unreportedDelta;
      }
    };
    exports2.DeltaMetricProcessor = DeltaMetricProcessor;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js
var require_TemporalMetricProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TemporalMetricProcessor = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality();
    var HashMap_1 = require_HashMap();
    var TemporalMetricProcessor = class _TemporalMetricProcessor {
      constructor(_aggregator, collectorHandles) {
        this._aggregator = _aggregator;
        this._unreportedAccumulations = /* @__PURE__ */ new Map();
        this._reportHistory = /* @__PURE__ */ new Map();
        collectorHandles.forEach((handle) => {
          this._unreportedAccumulations.set(handle, []);
        });
      }
      /**
       * Builds the {@link MetricData} streams to report against a specific MetricCollector.
       * @param collector The information of the MetricCollector.
       * @param collectors The registered collectors.
       * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
       * @param currentAccumulations The current accumulation of metric data from instruments.
       * @param collectionTime The current collection timestamp.
       * @returns The {@link MetricData} points or `null`.
       */
      buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(currentAccumulations);
        const unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);
        let result = unreportedAccumulations;
        let aggregationTemporality;
        if (this._reportHistory.has(collector)) {
          const last = this._reportHistory.get(collector);
          const lastCollectionTime = last.collectionTime;
          aggregationTemporality = last.aggregationTemporality;
          if (aggregationTemporality === AggregationTemporality_1.AggregationTemporality.CUMULATIVE) {
            result = _TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);
          } else {
            result = _TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
          }
        } else {
          aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        }
        this._reportHistory.set(collector, {
          accumulations: result,
          collectionTime,
          aggregationTemporality
        });
        const accumulationRecords = AttributesMapToAccumulationRecords(result);
        if (accumulationRecords.length === 0) {
          return void 0;
        }
        return this._aggregator.toMetricData(
          instrumentDescriptor,
          aggregationTemporality,
          accumulationRecords,
          /* endTime */
          collectionTime
        );
      }
      _stashAccumulations(currentAccumulation) {
        const registeredCollectors = this._unreportedAccumulations.keys();
        for (const collector of registeredCollectors) {
          let stash = this._unreportedAccumulations.get(collector);
          if (stash === void 0) {
            stash = [];
            this._unreportedAccumulations.set(collector, stash);
          }
          stash.push(currentAccumulation);
        }
      }
      _getMergedUnreportedAccumulations(collector) {
        let result = new HashMap_1.AttributeHashMap();
        const unreportedList = this._unreportedAccumulations.get(collector);
        this._unreportedAccumulations.set(collector, []);
        if (unreportedList === void 0) {
          return result;
        }
        for (const it of unreportedList) {
          result = _TemporalMetricProcessor.merge(result, it, this._aggregator);
        }
        return result;
      }
      static merge(last, current, aggregator) {
        const result = last;
        const iterator = current.entries();
        let next = iterator.next();
        while (next.done !== true) {
          const [key, record, hash] = next.value;
          if (last.has(key, hash)) {
            const lastAccumulation = last.get(key, hash);
            const accumulation = aggregator.merge(lastAccumulation, record);
            result.set(key, accumulation, hash);
          } else {
            result.set(key, record, hash);
          }
          next = iterator.next();
        }
        return result;
      }
      /**
       * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
       * the new stream to be the initial observation time unchanged.
       */
      static calibrateStartTime(last, current, lastCollectionTime) {
        for (const [key, hash] of last.keys()) {
          const currentAccumulation = current.get(key, hash);
          currentAccumulation === null || currentAccumulation === void 0 ? void 0 : currentAccumulation.setStartTime(lastCollectionTime);
        }
        return current;
      }
    };
    exports2.TemporalMetricProcessor = TemporalMetricProcessor;
    function AttributesMapToAccumulationRecords(map) {
      return Array.from(map.entries());
    }
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js
var require_AsyncMetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage();
    var DeltaMetricProcessor_1 = require_DeltaMetricProcessor();
    var TemporalMetricProcessor_1 = require_TemporalMetricProcessor();
    var HashMap_1 = require_HashMap();
    var AsyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {
        super(_instrumentDescriptor);
        this._attributesProcessor = _attributesProcessor;
        this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator);
        this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(measurements, observationTime) {
        const processed = new HashMap_1.AttributeHashMap();
        Array.from(measurements.entries()).forEach(([attributes, value]) => {
          processed.set(this._attributesProcessor.process(attributes), value);
        });
        this._deltaMetricStorage.batchCumulate(processed, observationTime);
      }
      /**
       * Collects the metrics from this storage. The ObservableCallback is invoked
       * during the collection.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        const accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports2.AsyncMetricStorage = AsyncMetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js
var require_RegistrationConflicts = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getConflictResolutionRecipe = exports2.getDescriptionResolutionRecipe = exports2.getTypeConflictResolutionRecipe = exports2.getUnitConflictResolutionRecipe = exports2.getValueTypeConflictResolutionRecipe = exports2.getIncompatibilityDetails = void 0;
    function getIncompatibilityDetails(existing, otherDescriptor) {
      let incompatibility = "";
      if (existing.unit !== otherDescriptor.unit) {
        incompatibility += `	- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'
`;
      }
      if (existing.type !== otherDescriptor.type) {
        incompatibility += `	- Type '${existing.type}' does not match '${otherDescriptor.type}'
`;
      }
      if (existing.valueType !== otherDescriptor.valueType) {
        incompatibility += `	- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'
`;
      }
      if (existing.description !== otherDescriptor.description) {
        incompatibility += `	- Description '${existing.description}' does not match '${otherDescriptor.description}'
`;
      }
      return incompatibility;
    }
    exports2.getIncompatibilityDetails = getIncompatibilityDetails;
    function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports2.getValueTypeConflictResolutionRecipe = getValueTypeConflictResolutionRecipe;
    function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports2.getUnitConflictResolutionRecipe = getUnitConflictResolutionRecipe;
    function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
      const selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      };
      const selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
    }
    exports2.getTypeConflictResolutionRecipe = getTypeConflictResolutionRecipe;
    function getDescriptionResolutionRecipe(existing, otherDescriptor) {
      const selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      };
      const selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    	- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    	- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
    }
    exports2.getDescriptionResolutionRecipe = getDescriptionResolutionRecipe;
    function getConflictResolutionRecipe(existing, otherDescriptor) {
      if (existing.valueType !== otherDescriptor.valueType) {
        return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);
      }
      if (existing.unit !== otherDescriptor.unit) {
        return getUnitConflictResolutionRecipe(existing, otherDescriptor);
      }
      if (existing.type !== otherDescriptor.type) {
        return getTypeConflictResolutionRecipe(existing, otherDescriptor);
      }
      if (existing.description !== otherDescriptor.description) {
        return getDescriptionResolutionRecipe(existing, otherDescriptor);
      }
      return "";
    }
    exports2.getConflictResolutionRecipe = getConflictResolutionRecipe;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js
var require_MetricStorageRegistry = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetricStorageRegistry = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var api = (init_esm(), __toCommonJS(esm_exports));
    var RegistrationConflicts_1 = require_RegistrationConflicts();
    var MetricStorageRegistry = class _MetricStorageRegistry {
      constructor() {
        this._sharedRegistry = /* @__PURE__ */ new Map();
        this._perCollectorRegistry = /* @__PURE__ */ new Map();
      }
      static create() {
        return new _MetricStorageRegistry();
      }
      getStorages(collector) {
        let storages = [];
        for (const metricStorages of this._sharedRegistry.values()) {
          storages = storages.concat(metricStorages);
        }
        const perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null) {
          for (const metricStorages of perCollectorStorages.values()) {
            storages = storages.concat(metricStorages);
          }
        }
        return storages;
      }
      register(storage) {
        this._registerStorage(storage, this._sharedRegistry);
      }
      registerForCollector(collector, storage) {
        let storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap == null) {
          storageMap = /* @__PURE__ */ new Map();
          this._perCollectorRegistry.set(collector, storageMap);
        }
        this._registerStorage(storage, storageMap);
      }
      findOrUpdateCompatibleStorage(expectedDescriptor) {
        const storages = this._sharedRegistry.get(expectedDescriptor.name);
        if (storages === void 0) {
          return null;
        }
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
        const storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === void 0) {
          return null;
        }
        const storages = storageMap.get(expectedDescriptor.name);
        if (storages === void 0) {
          return null;
        }
        return this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      _registerStorage(storage, storageMap) {
        const descriptor = storage.getInstrumentDescriptor();
        const storages = storageMap.get(descriptor.name);
        if (storages === void 0) {
          storageMap.set(descriptor.name, [storage]);
          return;
        }
        storages.push(storage);
      }
      _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
        let compatibleStorage = null;
        for (const existingStorage of existingStorages) {
          const existingDescriptor = existingStorage.getInstrumentDescriptor();
          if ((0, InstrumentDescriptor_1.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor)) {
            if (existingDescriptor.description !== expectedDescriptor.description) {
              if (expectedDescriptor.description.length > existingDescriptor.description.length) {
                existingStorage.updateDescription(expectedDescriptor.description);
              }
              api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, " has already been registered, but has a different description and is incompatible with another registered view.\n", "Details:\n", (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), "The longer description will be used.\nTo resolve the conflict:", (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
            }
            compatibleStorage = existingStorage;
          } else {
            api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, " has already been registered and is incompatible with another registered view.\n", "Details:\n", (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), "To resolve the conflict:\n", (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
          }
        }
        return compatibleStorage;
      }
    };
    exports2.MetricStorageRegistry = MetricStorageRegistry;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js
var require_MultiWritableMetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiMetricStorage = void 0;
    var MultiMetricStorage = class {
      constructor(_backingStorages) {
        this._backingStorages = _backingStorages;
      }
      record(value, attributes, context2, recordTime) {
        this._backingStorages.forEach((it) => {
          it.record(value, attributes, context2, recordTime);
        });
      }
    };
    exports2.MultiMetricStorage = MultiMetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js
var require_ObservableResult = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BatchObservableResultImpl = exports2.ObservableResultImpl = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var HashMap_1 = require_HashMap();
    var Instruments_1 = require_Instruments();
    var ObservableResultImpl = class {
      constructor(_instrumentName, _valueType) {
        this._instrumentName = _instrumentName;
        this._valueType = _valueType;
        this._buffer = new HashMap_1.AttributeHashMap();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(value, attributes = {}) {
        if (typeof value !== "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._instrumentName}: ${value}`);
          return;
        }
        if (this._valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
          api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`);
          value = Math.trunc(value);
          if (!Number.isInteger(value)) {
            return;
          }
        }
        this._buffer.set(attributes, value);
      }
    };
    exports2.ObservableResultImpl = ObservableResultImpl;
    var BatchObservableResultImpl = class {
      constructor() {
        this._buffer = /* @__PURE__ */ new Map();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(metric, value, attributes = {}) {
        if (!(0, Instruments_1.isObservableInstrument)(metric)) {
          return;
        }
        let map = this._buffer.get(metric);
        if (map == null) {
          map = new HashMap_1.AttributeHashMap();
          this._buffer.set(metric, map);
        }
        if (typeof value !== "number") {
          api_1.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
          return;
        }
        if (metric._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value)) {
          api_1.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`);
          value = Math.trunc(value);
          if (!Number.isInteger(value)) {
            return;
          }
        }
        map.set(attributes, value);
      }
    };
    exports2.BatchObservableResultImpl = BatchObservableResultImpl;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js
var require_ObservableRegistry = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObservableRegistry = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var Instruments_1 = require_Instruments();
    var ObservableResult_1 = require_ObservableResult();
    var utils_1 = require_utils();
    var ObservableRegistry = class {
      constructor() {
        this._callbacks = [];
        this._batchCallbacks = [];
      }
      addCallback(callback, instrument) {
        const idx = this._findCallback(callback, instrument);
        if (idx >= 0) {
          return;
        }
        this._callbacks.push({ callback, instrument });
      }
      removeCallback(callback, instrument) {
        const idx = this._findCallback(callback, instrument);
        if (idx < 0) {
          return;
        }
        this._callbacks.splice(idx, 1);
      }
      addBatchCallback(callback, instruments) {
        const observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        if (observableInstruments.size === 0) {
          api_1.diag.error("BatchObservableCallback is not associated with valid instruments", instruments);
          return;
        }
        const idx = this._findBatchCallback(callback, observableInstruments);
        if (idx >= 0) {
          return;
        }
        this._batchCallbacks.push({ callback, instruments: observableInstruments });
      }
      removeBatchCallback(callback, instruments) {
        const observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        const idx = this._findBatchCallback(callback, observableInstruments);
        if (idx < 0) {
          return;
        }
        this._batchCallbacks.splice(idx, 1);
      }
      /**
       * @returns a promise of rejected reasons for invoking callbacks.
       */
      async observe(collectionTime, timeoutMillis) {
        const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);
        const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
        const results = await (0, utils_1.PromiseAllSettled)([
          ...callbackFutures,
          ...batchCallbackFutures
        ]);
        const rejections = results.filter(utils_1.isPromiseAllSettledRejectionResult).map((it) => it.reason);
        return rejections;
      }
      _observeCallbacks(observationTime, timeoutMillis) {
        return this._callbacks.map(async ({ callback, instrument }) => {
          const observableResult = new ObservableResult_1.ObservableResultImpl(instrument._descriptor.name, instrument._descriptor.valueType);
          let callPromise = Promise.resolve(callback(observableResult));
          if (timeoutMillis != null) {
            callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis);
          }
          await callPromise;
          instrument._metricStorages.forEach((metricStorage) => {
            metricStorage.record(observableResult._buffer, observationTime);
          });
        });
      }
      _observeBatchCallbacks(observationTime, timeoutMillis) {
        return this._batchCallbacks.map(async ({ callback, instruments }) => {
          const observableResult = new ObservableResult_1.BatchObservableResultImpl();
          let callPromise = Promise.resolve(callback(observableResult));
          if (timeoutMillis != null) {
            callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis);
          }
          await callPromise;
          instruments.forEach((instrument) => {
            const buffer = observableResult._buffer.get(instrument);
            if (buffer == null) {
              return;
            }
            instrument._metricStorages.forEach((metricStorage) => {
              metricStorage.record(buffer, observationTime);
            });
          });
        });
      }
      _findCallback(callback, instrument) {
        return this._callbacks.findIndex((record) => {
          return record.callback === callback && record.instrument === instrument;
        });
      }
      _findBatchCallback(callback, instruments) {
        return this._batchCallbacks.findIndex((record) => {
          return record.callback === callback && (0, utils_1.setEquals)(record.instruments, instruments);
        });
      }
    };
    exports2.ObservableRegistry = ObservableRegistry;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js
var require_SyncMetricStorage = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage();
    var DeltaMetricProcessor_1 = require_DeltaMetricProcessor();
    var TemporalMetricProcessor_1 = require_TemporalMetricProcessor();
    var SyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles) {
        super(instrumentDescriptor);
        this._attributesProcessor = _attributesProcessor;
        this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator);
        this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(value, attributes, context2, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context2);
        this._deltaMetricStorage.record(value, attributes, context2, recordTime);
      }
      /**
       * Collects the metrics from this storage.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        const accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports2.SyncMetricStorage = SyncMetricStorage;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js
var require_AttributesProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilteringAttributesProcessor = exports2.NoopAttributesProcessor = exports2.AttributesProcessor = void 0;
    var AttributesProcessor = class {
      static Noop() {
        return NOOP;
      }
    };
    exports2.AttributesProcessor = AttributesProcessor;
    var NoopAttributesProcessor = class extends AttributesProcessor {
      process(incoming, _context) {
        return incoming;
      }
    };
    exports2.NoopAttributesProcessor = NoopAttributesProcessor;
    var FilteringAttributesProcessor = class extends AttributesProcessor {
      constructor(_allowedAttributeNames) {
        super();
        this._allowedAttributeNames = _allowedAttributeNames;
      }
      process(incoming, _context) {
        const filteredAttributes = {};
        Object.keys(incoming).filter((attributeName) => this._allowedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]);
        return filteredAttributes;
      }
    };
    exports2.FilteringAttributesProcessor = FilteringAttributesProcessor;
    var NOOP = new NoopAttributesProcessor();
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js
var require_MeterSharedState = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MeterSharedState = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    var Meter_1 = require_Meter2();
    var utils_1 = require_utils();
    var AsyncMetricStorage_1 = require_AsyncMetricStorage();
    var MetricStorageRegistry_1 = require_MetricStorageRegistry();
    var MultiWritableMetricStorage_1 = require_MultiWritableMetricStorage();
    var ObservableRegistry_1 = require_ObservableRegistry();
    var SyncMetricStorage_1 = require_SyncMetricStorage();
    var AttributesProcessor_1 = require_AttributesProcessor();
    var MeterSharedState = class {
      constructor(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState;
        this._instrumentationScope = _instrumentationScope;
        this.metricStorageRegistry = new MetricStorageRegistry_1.MetricStorageRegistry();
        this.observableRegistry = new ObservableRegistry_1.ObservableRegistry();
        this.meter = new Meter_1.Meter(this);
      }
      registerMetricStorage(descriptor) {
        const storages = this._registerMetricStorage(descriptor, SyncMetricStorage_1.SyncMetricStorage);
        if (storages.length === 1) {
          return storages[0];
        }
        return new MultiWritableMetricStorage_1.MultiMetricStorage(storages);
      }
      registerAsyncMetricStorage(descriptor) {
        const storages = this._registerMetricStorage(descriptor, AsyncMetricStorage_1.AsyncMetricStorage);
        return storages;
      }
      /**
       * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
       * @param collectionTime the HrTime at which the collection was initiated.
       * @param options options for collection.
       * @returns the list of metric data collected.
       */
      async collect(collector, collectionTime, options) {
        const errors = await this.observableRegistry.observe(collectionTime, options === null || options === void 0 ? void 0 : options.timeoutMillis);
        const storages = this.metricStorageRegistry.getStorages(collector);
        if (storages.length === 0) {
          return null;
        }
        const metricDataList = storages.map((metricStorage) => {
          return metricStorage.collect(collector, collectionTime);
        }).filter(utils_1.isNotNullish);
        if (metricDataList.length === 0) {
          return { errors };
        }
        return {
          scopeMetrics: {
            scope: this._instrumentationScope,
            metrics: metricDataList
          },
          errors
        };
      }
      _registerMetricStorage(descriptor, MetricStorageType) {
        const views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);
        let storages = views.map((view) => {
          const viewDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptorWithView)(view, descriptor);
          const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
          if (compatibleStorage != null) {
            return compatibleStorage;
          }
          const aggregator = view.aggregation.createAggregator(viewDescriptor);
          const viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors);
          this.metricStorageRegistry.register(viewStorage);
          return viewStorage;
        });
        if (storages.length === 0) {
          const perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);
          const collectorStorages = perCollectorAggregations.map(([collector, aggregation]) => {
            const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
            if (compatibleStorage != null) {
              return compatibleStorage;
            }
            const aggregator = aggregation.createAggregator(descriptor);
            const storage = new MetricStorageType(descriptor, aggregator, AttributesProcessor_1.AttributesProcessor.Noop(), [collector]);
            this.metricStorageRegistry.registerForCollector(collector, storage);
            return storage;
          });
          storages = storages.concat(collectorStorages);
        }
        return storages;
      }
    };
    exports2.MeterSharedState = MeterSharedState;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js
var require_MeterProviderSharedState = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MeterProviderSharedState = void 0;
    var utils_1 = require_utils();
    var ViewRegistry_1 = require_ViewRegistry();
    var MeterSharedState_1 = require_MeterSharedState();
    var MeterProviderSharedState = class {
      constructor(resource) {
        this.resource = resource;
        this.viewRegistry = new ViewRegistry_1.ViewRegistry();
        this.metricCollectors = [];
        this.meterSharedStates = /* @__PURE__ */ new Map();
      }
      getMeterSharedState(instrumentationScope) {
        const id = (0, utils_1.instrumentationScopeId)(instrumentationScope);
        let meterSharedState = this.meterSharedStates.get(id);
        if (meterSharedState == null) {
          meterSharedState = new MeterSharedState_1.MeterSharedState(this, instrumentationScope);
          this.meterSharedStates.set(id, meterSharedState);
        }
        return meterSharedState;
      }
      selectAggregations(instrumentType) {
        const result = [];
        for (const collector of this.metricCollectors) {
          result.push([collector, collector.selectAggregation(instrumentType)]);
        }
        return result;
      }
    };
    exports2.MeterProviderSharedState = MeterProviderSharedState;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js
var require_MetricCollector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetricCollector = void 0;
    var core_1 = require_src3();
    var MetricCollector = class {
      constructor(_sharedState, _metricReader) {
        this._sharedState = _sharedState;
        this._metricReader = _metricReader;
      }
      async collect(options) {
        const collectionTime = (0, core_1.millisToHrTime)(Date.now());
        const scopeMetrics = [];
        const errors = [];
        const meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(async (meterSharedState) => {
          const current = await meterSharedState.collect(this, collectionTime, options);
          if ((current === null || current === void 0 ? void 0 : current.scopeMetrics) != null) {
            scopeMetrics.push(current.scopeMetrics);
          }
          if ((current === null || current === void 0 ? void 0 : current.errors) != null) {
            errors.push(...current.errors);
          }
        });
        await Promise.all(meterCollectionPromises);
        return {
          resourceMetrics: {
            resource: this._sharedState.resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Delegates for MetricReader.forceFlush.
       */
      async forceFlush(options) {
        await this._metricReader.forceFlush(options);
      }
      /**
       * Delegates for MetricReader.shutdown.
       */
      async shutdown(options) {
        await this._metricReader.shutdown(options);
      }
      selectAggregationTemporality(instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
      }
      selectAggregation(instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
      }
    };
    exports2.MetricCollector = MetricCollector;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js
var require_MeterProvider = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MeterProvider = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var resources_1 = require_src4();
    var MeterProviderSharedState_1 = require_MeterProviderSharedState();
    var MetricCollector_1 = require_MetricCollector();
    var MeterProvider = class {
      constructor(options) {
        var _a;
        this._shutdown = false;
        const resource = resources_1.Resource.default().merge((_a = options === null || options === void 0 ? void 0 : options.resource) !== null && _a !== void 0 ? _a : resources_1.Resource.empty());
        this._sharedState = new MeterProviderSharedState_1.MeterProviderSharedState(resource);
        if ((options === null || options === void 0 ? void 0 : options.views) != null && options.views.length > 0) {
          for (const view of options.views) {
            this._sharedState.viewRegistry.addView(view);
          }
        }
        if ((options === null || options === void 0 ? void 0 : options.readers) != null && options.readers.length > 0) {
          for (const metricReader of options.readers) {
            this.addMetricReader(metricReader);
          }
        }
      }
      /**
       * Get a meter with the configuration of the MeterProvider.
       */
      getMeter(name, version = "", options = {}) {
        if (this._shutdown) {
          api_1.diag.warn("A shutdown MeterProvider cannot provide a Meter");
          return (0, api_1.createNoopMeter)();
        }
        return this._sharedState.getMeterSharedState({
          name,
          version,
          schemaUrl: options.schemaUrl
        }).meter;
      }
      /**
       * Register a {@link MetricReader} to the meter provider. After the
       * registration, the MetricReader can start metrics collection.
       *
       * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.
       * A {@link MetricReader} instance registered later may receive no or incomplete metric data.
       *
       * @param metricReader the metric reader to be registered.
       *
       * @deprecated This method will be removed in SDK 2.0. Please use
       * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead
       */
      addMetricReader(metricReader) {
        const collector = new MetricCollector_1.MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector);
        this._sharedState.metricCollectors.push(collector);
      }
      /**
       * Flush all buffered data and shut down the MeterProvider and all registered
       * MetricReaders.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api_1.diag.warn("shutdown may only be called once per MeterProvider");
          return;
        }
        this._shutdown = true;
        await Promise.all(this._sharedState.metricCollectors.map((collector) => {
          return collector.shutdown(options);
        }));
      }
      /**
       * Notifies all registered MetricReaders to flush any buffered data.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api_1.diag.warn("invalid attempt to force flush after MeterProvider shutdown");
          return;
        }
        await Promise.all(this._sharedState.metricCollectors.map((collector) => {
          return collector.forceFlush(options);
        }));
      }
    };
    exports2.MeterProvider = MeterProvider;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js
var require_Predicate = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExactPredicate = exports2.PatternPredicate = void 0;
    var ESCAPE = /[\^$\\.+?()[\]{}|]/g;
    var PatternPredicate = class _PatternPredicate {
      constructor(pattern) {
        if (pattern === "*") {
          this._matchAll = true;
          this._regexp = /.*/;
        } else {
          this._matchAll = false;
          this._regexp = new RegExp(_PatternPredicate.escapePattern(pattern));
        }
      }
      match(str) {
        if (this._matchAll) {
          return true;
        }
        return this._regexp.test(str);
      }
      static escapePattern(pattern) {
        return `^${pattern.replace(ESCAPE, "\\$&").replace("*", ".*")}$`;
      }
      static hasWildcard(pattern) {
        return pattern.includes("*");
      }
    };
    exports2.PatternPredicate = PatternPredicate;
    var ExactPredicate = class {
      constructor(pattern) {
        this._matchAll = pattern === void 0;
        this._pattern = pattern;
      }
      match(str) {
        if (this._matchAll) {
          return true;
        }
        if (str === this._pattern) {
          return true;
        }
        return false;
      }
    };
    exports2.ExactPredicate = ExactPredicate;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js
var require_InstrumentSelector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstrumentSelector = void 0;
    var Predicate_1 = require_Predicate();
    var InstrumentSelector = class {
      constructor(criteria) {
        var _a;
        this._nameFilter = new Predicate_1.PatternPredicate((_a = criteria === null || criteria === void 0 ? void 0 : criteria.name) !== null && _a !== void 0 ? _a : "*");
        this._type = criteria === null || criteria === void 0 ? void 0 : criteria.type;
        this._unitFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.unit);
      }
      getType() {
        return this._type;
      }
      getNameFilter() {
        return this._nameFilter;
      }
      getUnitFilter() {
        return this._unitFilter;
      }
    };
    exports2.InstrumentSelector = InstrumentSelector;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js
var require_MeterSelector = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MeterSelector = void 0;
    var Predicate_1 = require_Predicate();
    var MeterSelector = class {
      constructor(criteria) {
        this._nameFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.name);
        this._versionFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.version);
        this._schemaUrlFilter = new Predicate_1.ExactPredicate(criteria === null || criteria === void 0 ? void 0 : criteria.schemaUrl);
      }
      getNameFilter() {
        return this._nameFilter;
      }
      /**
       * TODO: semver filter? no spec yet.
       */
      getVersionFilter() {
        return this._versionFilter;
      }
      getSchemaUrlFilter() {
        return this._schemaUrlFilter;
      }
    };
    exports2.MeterSelector = MeterSelector;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js
var require_View = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.View = void 0;
    var Predicate_1 = require_Predicate();
    var AttributesProcessor_1 = require_AttributesProcessor();
    var InstrumentSelector_1 = require_InstrumentSelector();
    var MeterSelector_1 = require_MeterSelector();
    var Aggregation_1 = require_Aggregation();
    function isSelectorNotProvided(options) {
      return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
    }
    var View = class {
      /**
       * Create a new {@link View} instance.
       *
       * Parameters can be categorized as two types:
       *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
       *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
       *
       *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
       *
       * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
       * @param viewOptions.name
       * Alters the metric stream:
       *  This will be used as the name of the metrics stream.
       *  If not provided, the original Instrument name will be used.
       * @param viewOptions.description
       * Alters the metric stream:
       *  This will be used as the description of the metrics stream.
       *  If not provided, the original Instrument description will be used by default.
       * @param viewOptions.attributeKeys
       * Alters the metric stream:
       *  If provided, the attributes that are not in the list will be ignored.
       *  If not provided, all attribute keys will be used by default.
       * @param viewOptions.aggregation
       * Alters the metric stream:
       *  Alters the {@link Aggregation} of the metric stream.
       * @param viewOptions.instrumentName
       * Instrument selection criteria:
       *  Original name of the Instrument(s) with wildcard support.
       * @param viewOptions.instrumentType
       * Instrument selection criteria:
       *  The original type of the Instrument(s).
       * @param viewOptions.instrumentUnit
       * Instrument selection criteria:
       *  The unit of the Instrument(s).
       * @param viewOptions.meterName
       * Instrument selection criteria:
       *  The name of the Meter. No wildcard support, name must match the meter exactly.
       * @param viewOptions.meterVersion
       * Instrument selection criteria:
       *  The version of the Meter. No wildcard support, version must match exactly.
       * @param viewOptions.meterSchemaUrl
       * Instrument selection criteria:
       *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
       *
       * @example
       * // Create a view that changes the Instrument 'my.instrument' to use to an
       * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
       * new View({
       *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
       *   instrumentName: 'my.instrument'
       * })
       */
      constructor(viewOptions) {
        var _a;
        if (isSelectorNotProvided(viewOptions)) {
          throw new Error("Cannot create view with no selector arguments supplied");
        }
        if (viewOptions.name != null && ((viewOptions === null || viewOptions === void 0 ? void 0 : viewOptions.instrumentName) == null || Predicate_1.PatternPredicate.hasWildcard(viewOptions.instrumentName))) {
          throw new Error("Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.");
        }
        if (viewOptions.attributeKeys != null) {
          this.attributesProcessor = new AttributesProcessor_1.FilteringAttributesProcessor(viewOptions.attributeKeys);
        } else {
          this.attributesProcessor = AttributesProcessor_1.AttributesProcessor.Noop();
        }
        this.name = viewOptions.name;
        this.description = viewOptions.description;
        this.aggregation = (_a = viewOptions.aggregation) !== null && _a !== void 0 ? _a : Aggregation_1.Aggregation.Default();
        this.instrumentSelector = new InstrumentSelector_1.InstrumentSelector({
          name: viewOptions.instrumentName,
          type: viewOptions.instrumentType,
          unit: viewOptions.instrumentUnit
        });
        this.meterSelector = new MeterSelector_1.MeterSelector({
          name: viewOptions.meterName,
          version: viewOptions.meterVersion,
          schemaUrl: viewOptions.meterSchemaUrl
        });
      }
    };
    exports2.View = View;
  }
});

// node_modules/@opentelemetry/sdk-metrics/build/src/index.js
var require_src5 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeoutError = exports2.View = exports2.Aggregation = exports2.SumAggregation = exports2.LastValueAggregation = exports2.HistogramAggregation = exports2.DropAggregation = exports2.ExponentialHistogramAggregation = exports2.ExplicitBucketHistogramAggregation = exports2.DefaultAggregation = exports2.MeterProvider = exports2.InstrumentType = exports2.ConsoleMetricExporter = exports2.InMemoryMetricExporter = exports2.PeriodicExportingMetricReader = exports2.MetricReader = exports2.DataPointType = exports2.AggregationTemporality = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality();
    Object.defineProperty(exports2, "AggregationTemporality", { enumerable: true, get: function() {
      return AggregationTemporality_1.AggregationTemporality;
    } });
    var MetricData_1 = require_MetricData();
    Object.defineProperty(exports2, "DataPointType", { enumerable: true, get: function() {
      return MetricData_1.DataPointType;
    } });
    var MetricReader_1 = require_MetricReader();
    Object.defineProperty(exports2, "MetricReader", { enumerable: true, get: function() {
      return MetricReader_1.MetricReader;
    } });
    var PeriodicExportingMetricReader_1 = require_PeriodicExportingMetricReader();
    Object.defineProperty(exports2, "PeriodicExportingMetricReader", { enumerable: true, get: function() {
      return PeriodicExportingMetricReader_1.PeriodicExportingMetricReader;
    } });
    var InMemoryMetricExporter_1 = require_InMemoryMetricExporter();
    Object.defineProperty(exports2, "InMemoryMetricExporter", { enumerable: true, get: function() {
      return InMemoryMetricExporter_1.InMemoryMetricExporter;
    } });
    var ConsoleMetricExporter_1 = require_ConsoleMetricExporter();
    Object.defineProperty(exports2, "ConsoleMetricExporter", { enumerable: true, get: function() {
      return ConsoleMetricExporter_1.ConsoleMetricExporter;
    } });
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    Object.defineProperty(exports2, "InstrumentType", { enumerable: true, get: function() {
      return InstrumentDescriptor_1.InstrumentType;
    } });
    var MeterProvider_1 = require_MeterProvider();
    Object.defineProperty(exports2, "MeterProvider", { enumerable: true, get: function() {
      return MeterProvider_1.MeterProvider;
    } });
    var Aggregation_1 = require_Aggregation();
    Object.defineProperty(exports2, "DefaultAggregation", { enumerable: true, get: function() {
      return Aggregation_1.DefaultAggregation;
    } });
    Object.defineProperty(exports2, "ExplicitBucketHistogramAggregation", { enumerable: true, get: function() {
      return Aggregation_1.ExplicitBucketHistogramAggregation;
    } });
    Object.defineProperty(exports2, "ExponentialHistogramAggregation", { enumerable: true, get: function() {
      return Aggregation_1.ExponentialHistogramAggregation;
    } });
    Object.defineProperty(exports2, "DropAggregation", { enumerable: true, get: function() {
      return Aggregation_1.DropAggregation;
    } });
    Object.defineProperty(exports2, "HistogramAggregation", { enumerable: true, get: function() {
      return Aggregation_1.HistogramAggregation;
    } });
    Object.defineProperty(exports2, "LastValueAggregation", { enumerable: true, get: function() {
      return Aggregation_1.LastValueAggregation;
    } });
    Object.defineProperty(exports2, "SumAggregation", { enumerable: true, get: function() {
      return Aggregation_1.SumAggregation;
    } });
    Object.defineProperty(exports2, "Aggregation", { enumerable: true, get: function() {
      return Aggregation_1.Aggregation;
    } });
    var View_1 = require_View();
    Object.defineProperty(exports2, "View", { enumerable: true, get: function() {
      return View_1.View;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return utils_1.TimeoutError;
    } });
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-metrics/ElasticApmMetricExporter.js
var require_ElasticApmMetricExporter = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-metrics/ElasticApmMetricExporter.js"(exports2, module2) {
    var { ExportResultCode } = require_src3();
    var {
      AggregationTemporality,
      InstrumentType,
      ExplicitBucketHistogramAggregation,
      SumAggregation,
      LastValueAggregation,
      DropAggregation,
      DataPointType
    } = require_src5();
    var { LRUCache } = require_commonjs();
    function metricTimestampFromOTelHrTime(otelHrTime) {
      return Math.round(otelHrTime[0] * 1e6 + otelHrTime[1] / 1e3);
    }
    function hashAttributes(attributes) {
      let keys = Object.keys(attributes);
      if (keys.length === 0) return "";
      keys = keys.sort();
      return JSON.stringify(keys.map((key) => [key, attributes[key]]));
    }
    function fillIntakeHistogramSample(sample, otelDataPoint) {
      const otelCounts = otelDataPoint.value.buckets.counts;
      const otelBoundaries = otelDataPoint.value.buckets.boundaries;
      const bucketCount = otelCounts.length;
      if (bucketCount === 0) {
        return;
      }
      const intakeCounts = sample.counts = [];
      const intakeValues = sample.values = [];
      sample.type = "histogram";
      for (let i = 0; i < bucketCount; i++) {
        if (otelCounts[i] !== 0) {
          intakeCounts.push(otelCounts[i]);
          if (i === 0) {
            let bound = otelBoundaries[i];
            if (bound > 0) {
              bound /= 2;
            }
            intakeValues.push(bound);
          } else if (i === bucketCount - 1) {
            intakeValues.push(otelBoundaries[bucketCount - 2]);
          } else {
            const lower = otelBoundaries[i - 1];
            const upper = otelBoundaries[i];
            intakeValues.push(lower + (upper - lower) / 2);
          }
        }
      }
    }
    var ElasticApmMetricExporter = class {
      constructor(agent) {
        this._agent = agent;
        this._histogramAggregation = new ExplicitBucketHistogramAggregation(
          this._agent._conf.customMetricsHistogramBoundaries
        );
        this._sumAggregation = new SumAggregation();
        this._lastValueAggregation = new LastValueAggregation();
        this._dropAggregation = new DropAggregation();
        this._attrDropWarnCache = new LRUCache({ max: 1e3 });
        this._dataPointTypeDropWarnCache = new LRUCache({ max: 1e3 });
      }
      /**
       * Spec: https://github.com/elastic/apm/blob/main/specs/agents/metrics-otel.md#aggregation
       *
       * @param {import('@opentelemetry/sdk-metrics').InstrumentType} instrumentType
       * @returns {import('@opentelemetry/sdk-metrics').Aggregation}
       */
      selectAggregation(instrumentType) {
        switch (instrumentType) {
          case InstrumentType.COUNTER:
          case InstrumentType.UP_DOWN_COUNTER:
          case InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
            return this._sumAggregation;
          case InstrumentType.OBSERVABLE_GAUGE:
            return this._lastValueAggregation;
          case InstrumentType.HISTOGRAM:
            return this._histogramAggregation;
          default:
            this._agent.logger.warn(
              `cannot selectAggregation: unknown OTel Metric instrumentType: ${instrumentType}`
            );
            return this._dropAggregation;
        }
      }
      // Spec: https://github.com/elastic/apm/blob/main/specs/agents/metrics-otel.md#aggregation-temporality
      //
      // Note: This differs from the OTel SDK default.
      // `OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=Cumulative`
      // https://opentelemetry.io/docs/reference/specification/metrics/sdk_exporters/otlp/
      selectAggregationTemporality(instrumentType) {
        switch (instrumentType) {
          case InstrumentType.COUNTER:
          case InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentType.HISTOGRAM:
          case InstrumentType.OBSERVABLE_GAUGE:
            return AggregationTemporality.DELTA;
          case InstrumentType.UP_DOWN_COUNTER:
          case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
            return AggregationTemporality.CUMULATIVE;
        }
      }
      async forceFlush() {
        return this._agent.flush();
      }
      async shutdown() {
        return this._agent.flush();
      }
      /**
       * Export an OTel `ResourceMetrics` to Elastic APM intake `metricset`s.
       *
       * Dev notes:
       * - Explicitly *not* including `metricData.descriptor.unit` because the APM
       *   spec doesn't include it. It isn't clear there is value.
       */
      export(resourceMetrics, resultCallback) {
        for (const scopeMetrics of resourceMetrics.scopeMetrics) {
          const metricsetFromAttrHash = {};
          for (const metricData of scopeMetrics.metrics) {
            const metricName = metricData.descriptor.name;
            if (this._agent._isMetricNameDisabled(metricName)) {
              continue;
            }
            if (!(metricData.dataPointType === DataPointType.GAUGE || metricData.dataPointType === DataPointType.SUM || metricData.dataPointType === DataPointType.HISTOGRAM)) {
              if (!this._dataPointTypeDropWarnCache.has(metricName)) {
                this._agent.logger.warn(
                  `dropping metric "${metricName}": cannot export metrics with dataPointType=${metricData.dataPointType}`
                );
                this._dataPointTypeDropWarnCache.set(metricName, true);
              }
            }
            for (const dataPoint of metricData.dataPoints) {
              const labels = this._labelsFromOTelMetricAttributes(
                dataPoint.attributes,
                metricData.descriptor.name
              );
              const attrHash = hashAttributes(labels);
              let metricset = metricsetFromAttrHash[attrHash];
              if (!metricset) {
                metricset = {
                  samples: {},
                  // Assumption: `endTime` is the same for all `dataPoint`s in
                  // this `metricData`.
                  timestamp: metricTimestampFromOTelHrTime(dataPoint.endTime),
                  tags: labels
                };
                metricsetFromAttrHash[attrHash] = metricset;
              }
              const sample = {};
              switch (metricData.dataPointType) {
                case DataPointType.GAUGE:
                  sample.type = "gauge";
                  sample.value = dataPoint.value;
                  break;
                case DataPointType.SUM:
                  if (metricData.isMonotonic) {
                    sample.type = "counter";
                  } else {
                    sample.type = "gauge";
                  }
                  sample.value = dataPoint.value;
                  break;
                case DataPointType.HISTOGRAM:
                  fillIntakeHistogramSample(sample, dataPoint);
                  break;
              }
              if (sample.type) {
                metricset.samples[metricData.descriptor.name] = sample;
              }
            }
          }
          Object.values(metricsetFromAttrHash).forEach((metricset) => {
            this._agent._apmClient.sendMetricSet(metricset);
          });
        }
        return resultCallback({ code: ExportResultCode.SUCCESS });
      }
      /**
       * Convert from `dataPoint.attributes` to a set of labels (a.k.a. tags) for
       * Elastic APM intake. Attributes with an *array* value are not supported --
       * they are dropped with a log.warn that mentions the metric and attribute
       * names.
       *
       * This makes *in-place* changes to the given `attrs` argument. It returns
       * the same object.
       *
       * https://github.com/elastic/apm/blob/main/specs/agents/metrics-otel.md#labels
       */
      _labelsFromOTelMetricAttributes(attrs, metricName) {
        const keys = Object.keys(attrs);
        for (var i = 0; i < keys.length; i++) {
          const k = keys[i];
          const v = attrs[k];
          if (Array.isArray(v)) {
            delete attrs[k];
            const cacheKey = metricName + "/" + k;
            if (!this._attrDropWarnCache.has(cacheKey)) {
              this._agent.logger.warn(
                { metricName, attrName: k },
                "dropping array-valued metric attribute: array attribute values are not supported"
              );
              this._attrDropWarnCache.set(cacheKey, true);
            }
          }
        }
        return attrs;
      }
    };
    module2.exports = ElasticApmMetricExporter;
  }
});

// node_modules/@opentelemetry/sdk-metrics/package.json
var require_package4 = __commonJS({
  "node_modules/@opentelemetry/sdk-metrics/package.json"(exports2, module2) {
    module2.exports = {
      name: "@opentelemetry/sdk-metrics",
      version: "1.25.1",
      description: "OpenTelemetry metrics SDK",
      main: "build/src/index.js",
      module: "build/esm/index.js",
      esnext: "build/esnext/index.js",
      types: "build/src/index.d.ts",
      repository: "open-telemetry/opentelemetry-js",
      scripts: {
        prepublishOnly: "npm run compile",
        compile: "tsc --build tsconfig.json tsconfig.esm.json tsconfig.esnext.json",
        clean: "tsc --build --clean tsconfig.json tsconfig.esm.json tsconfig.esnext.json",
        test: "nyc ts-mocha -p tsconfig.json 'test/**/*.test.ts'",
        "test:browser": "karma start --single-run",
        tdd: "npm run test -- --watch-extensions ts --watch",
        "tdd:browser": "karma start",
        codecov: "nyc report --reporter=json && codecov -f coverage/*.json -p ../../",
        lint: "eslint . --ext .ts",
        "lint:fix": "eslint . --ext .ts --fix",
        version: "node ../../scripts/version-update.js",
        watch: "tsc --build --watch tsconfig.json tsconfig.esm.json tsconfig.esnext.json",
        precompile: "cross-var lerna run version --scope $npm_package_name --include-dependencies",
        prewatch: "node ../../scripts/version-update.js",
        "peer-api-check": "node ../../scripts/peer-api-check.js",
        "align-api-deps": "node ../../scripts/align-api-deps.js"
      },
      keywords: [
        "opentelemetry",
        "nodejs",
        "metrics",
        "stats",
        "profiling"
      ],
      author: "OpenTelemetry Authors",
      license: "Apache-2.0",
      engines: {
        node: ">=14"
      },
      files: [
        "build/esm/**/*.js",
        "build/esm/**/*.js.map",
        "build/esm/**/*.d.ts",
        "build/esnext/**/*.js",
        "build/esnext/**/*.js.map",
        "build/esnext/**/*.d.ts",
        "build/src/**/*.js",
        "build/src/**/*.js.map",
        "build/src/**/*.d.ts",
        "doc",
        "LICENSE",
        "README.md"
      ],
      publishConfig: {
        access: "public"
      },
      devDependencies: {
        "@babel/core": "7.24.7",
        "@babel/preset-env": "7.24.7",
        "@opentelemetry/api": ">=1.3.0 <1.10.0",
        "@types/lodash.merge": "4.6.9",
        "@types/mocha": "10.0.6",
        "@types/node": "18.6.5",
        "@types/sinon": "17.0.3",
        "babel-plugin-istanbul": "6.1.1",
        codecov: "3.8.3",
        "cross-var": "1.1.0",
        karma: "6.4.3",
        "karma-chrome-launcher": "3.1.0",
        "karma-coverage": "2.2.1",
        "karma-mocha": "2.0.1",
        "karma-spec-reporter": "0.0.36",
        "karma-webpack": "5.0.1",
        lerna: "6.6.2",
        mocha: "10.2.0",
        nyc: "15.1.0",
        sinon: "15.1.2",
        "ts-loader": "9.5.1",
        "ts-mocha": "10.0.0",
        typescript: "4.4.4",
        webpack: "5.89.0",
        "webpack-cli": "5.1.4",
        "webpack-merge": "5.10.0"
      },
      peerDependencies: {
        "@opentelemetry/api": ">=1.3.0 <1.10.0"
      },
      dependencies: {
        "@opentelemetry/core": "1.25.1",
        "@opentelemetry/resources": "1.25.1",
        "lodash.merge": "^4.6.2"
      },
      homepage: "https://github.com/open-telemetry/opentelemetry-js/tree/main/packages/sdk-metrics",
      sideEffects: false,
      gitHead: "0608f405573901e54db01e44c533009cf28be262"
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-metrics/index.js
var require_opentelemetry_metrics = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-metrics/index.js"(exports2, module2) {
    var assert = require("assert");
    var {
      MeterProvider,
      PeriodicExportingMetricReader
    } = require_src5();
    var semver = require_semver2();
    var ElasticApmMetricExporter = require_ElasticApmMetricExporter();
    var _supportRange = require_package4().engines.node;
    var isOTelMetricsFeatSupported = semver.satisfies(
      process.version,
      _supportRange
    );
    function createOTelMetricReader(agent) {
      const metricsInterval = agent._conf.metricsInterval;
      assert(
        metricsInterval > 0,
        "createOTelMeterProvider() should not be called if metricsInterval <= 0"
      );
      return new PeriodicExportingMetricReader({
        exporter: new ElasticApmMetricExporter(agent),
        exportIntervalMillis: metricsInterval * 1e3,
        exportTimeoutMillis: metricsInterval / 2 * 1e3
      });
    }
    function createOTelMeterProvider(agent) {
      const meterProvider = new MeterProvider();
      meterProvider.addMetricReader(createOTelMetricReader(agent));
      return meterProvider;
    }
    module2.exports = {
      isOTelMetricsFeatSupported,
      createOTelMetricReader,
      createOTelMeterProvider
    };
  }
});

// node_modules/elastic-apm-node/lib/http-request.js
var require_http_request = __commonJS({
  "node_modules/elastic-apm-node/lib/http-request.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var coreHttpRequest = require("http").request;
    var coreHttpsRequest = require("https").request;
    function urlToOptions(url) {
      const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || ""}${url.search || ""}`,
        href: url.href
      };
      if (url.port !== "") {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
      }
      return options;
    }
    function httpRequest(url, opts, cb) {
      if (typeof url !== "string") {
        throw new TypeError(
          '"url" argument is not a string, this does not support the "httpRequest(opts, cb)" call signature'
        );
      }
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const { connectTimeout, ...otherOpts } = opts;
      const u = new URL2(url);
      const mergedOpts = Object.assign(urlToOptions(u), otherOpts);
      let requestFn;
      if (mergedOpts.protocol === "http:") {
        requestFn = coreHttpRequest;
      } else if (mergedOpts.protocol === "https:") {
        requestFn = coreHttpsRequest;
      } else {
        throw new Error(`unsupported protocol: "${mergedOpts.protocol}"`);
      }
      const req = requestFn(mergedOpts, cb);
      if (connectTimeout) {
        req.on("socket", function(socket) {
          var connectTimer = setTimeout(function onConnectTimeout() {
            req.emit("connectTimeout");
          }, connectTimeout);
          socket.on("connect", function() {
            clearTimeout(connectTimer);
            connectTimer = null;
          });
          socket.on("close", function() {
            if (connectTimer) {
              clearTimeout(connectTimer);
            }
          });
        });
      }
      return req;
    }
    module2.exports = {
      httpRequest
    };
    function main(argv) {
      if (argv.length !== 5) {
        process.stderr.write("http-request: error: incorrect number of args\n");
        process.stderr.write(
          "usage: http-request $url $connectTimeoutMs $timeoutMs\n"
        );
        process.exitCode = 1;
        return;
      }
      const url = argv[2];
      const connectTimeout = Number(argv[3]);
      const timeout = Number(argv[4]);
      var req = httpRequest(
        url,
        {
          timeout,
          connectTimeout
          // TODO: log support
        },
        function onRes(res) {
          res.pipe(process.stdout);
        }
      );
      req.on("timeout", function() {
        console.warn(
          `http-request: response timeout (${timeout}ms): destroying request`
        );
        req.destroy(new Error("got timeout event"));
        process.exitCode = 28;
      });
      req.on("connectTimeout", function() {
        console.warn(
          `http-request: connect timeout (${connectTimeout}ms): destroying request`
        );
        req.destroy(new Error("got connectTimeout event"));
        process.exitCode = 28;
      });
      req.on("error", function(err) {
        console.warn("http-request: request error:", err);
        process.exitCode = 1;
      });
      req.end();
    }
    if (require.main === module2) {
      main(process.argv);
    }
  }
});

// node_modules/elastic-apm-node/lib/cloud-metadata/aws.js
var require_aws = __commonJS({
  "node_modules/elastic-apm-node/lib/cloud-metadata/aws.js"(exports2, module2) {
    "use strict";
    var URL2 = require("url").URL;
    var { httpRequest } = require_http_request();
    var DEFAULT_BASE_URL = new URL2("/", "http://169.254.169.254:80");
    function sanitizeHttpHeaderValue(value) {
      const newValue = value.replace(/[\r\n]/g, "").replace(/[^\x20-\x7F]/g, "");
      return newValue;
    }
    function getMetadataAwsWithHeaders(baseUrl, headers, connectTimeoutMs, resTimeoutMs, logger, cb) {
      const options = {
        method: "GET",
        timeout: resTimeoutMs,
        connectTimeout: connectTimeoutMs
      };
      if (headers) {
        options.headers = headers;
      }
      const url = baseUrl + "latest/dynamic/instance-identity/document";
      const req = httpRequest(url, options, function(res) {
        const finalData = [];
        res.on("data", function(data) {
          finalData.push(data);
        });
        res.on("end", function(data) {
          let result;
          try {
            result = formatMetadataStringIntoObject(finalData.join(""));
          } catch (err) {
            logger.trace(
              "aws metadata server responded, but there was an error parsing the result: %o",
              err
            );
            cb(err);
            return;
          }
          cb(null, result);
        });
      });
      req.on("timeout", function() {
        req.destroy(new Error("request to metadata server timed out"));
      });
      req.on("connectTimeout", function() {
        req.destroy(new Error("could not ping metadata server"));
      });
      req.on("error", function(err) {
        cb(err);
      });
      req.end();
    }
    function getMetadataAws(connectTimeoutMs, resTimeoutMs, logger, baseUrlOverride, cb) {
      const baseUrl = baseUrlOverride || DEFAULT_BASE_URL;
      const url = baseUrl + "latest/api/token";
      const options = {
        method: "PUT",
        headers: {
          "X-aws-ec2-metadata-token-ttl-seconds": 300
        },
        timeout: resTimeoutMs,
        connectTimeout: connectTimeoutMs
      };
      const req = httpRequest(url, options, function(res) {
        const finalData = [];
        res.on("data", function(data) {
          finalData.push(data);
        });
        res.on("end", function() {
          const token = sanitizeHttpHeaderValue(finalData.join(""));
          const headers = {};
          if (token && res.statusCode === 200) {
            headers["X-aws-ec2-metadata-token"] = token;
          }
          getMetadataAwsWithHeaders(
            baseUrl,
            headers,
            connectTimeoutMs,
            resTimeoutMs,
            logger,
            cb
          );
        });
      });
      req.on("timeout", function() {
        req.destroy(new Error("request for metadata token timed out"));
      });
      req.on("connectTimeout", function() {
        req.destroy(
          new Error("socket connection to metadata token server timed out")
        );
      });
      req.on("error", function(err) {
        cb(err);
      });
      req.end();
    }
    function formatMetadataStringIntoObject(string) {
      const data = JSON.parse(string);
      const metadata = {
        account: {
          id: String(data.accountId)
        },
        instance: {
          id: String(data.instanceId)
        },
        availability_zone: String(data.availabilityZone),
        machine: {
          type: String(data.instanceType)
        },
        provider: "aws",
        region: String(data.region)
      };
      return metadata;
    }
    module2.exports = { getMetadataAws };
  }
});

// node_modules/elastic-apm-node/lib/cloud-metadata/azure.js
var require_azure = __commonJS({
  "node_modules/elastic-apm-node/lib/cloud-metadata/azure.js"(exports2, module2) {
    "use strict";
    var URL2 = require("url").URL;
    var { httpRequest } = require_http_request();
    var DEFAULT_BASE_URL = new URL2("/", "http://169.254.169.254:80");
    function getMetadataAzure(connectTimeoutMs, resTimeoutMs, logger, baseUrlOverride, cb) {
      const baseUrl = baseUrlOverride || DEFAULT_BASE_URL;
      const options = {
        method: "GET",
        timeout: resTimeoutMs,
        connectTimeout: connectTimeoutMs,
        headers: {
          Metadata: "true"
        }
      };
      const url = baseUrl.toString() + "metadata/instance?api-version=2020-09-01";
      const req = httpRequest(url, options, function(res) {
        const finalData = [];
        res.on("data", function(data) {
          finalData.push(data);
        });
        res.on("end", function(data) {
          let result;
          try {
            result = formatMetadataStringIntoObject(finalData.join(""));
          } catch (err) {
            logger.trace(
              "azure metadata server responded, but there was an error parsing the result: %o",
              err
            );
            cb(err);
            return;
          }
          cb(null, result);
        });
      });
      req.on("timeout", function() {
        req.destroy(new Error("request to azure metadata server timed out"));
      });
      req.on("connectTimeout", function() {
        req.destroy(new Error("could not ping azure metadata server"));
      });
      req.on("error", function(err) {
        cb(err);
      });
      req.end();
    }
    function formatMetadataStringIntoObject(string) {
      const metadata = {
        account: {
          id: null
        },
        instance: {
          id: null,
          name: null
        },
        project: {
          name: null
        },
        availability_zone: null,
        machine: {
          type: null
        },
        provider: "azure",
        region: null
      };
      const parsed = JSON.parse(string);
      if (!parsed.compute) {
        return metadata;
      }
      const data = parsed.compute;
      metadata.account.id = String(data.subscriptionId);
      metadata.instance.id = String(data.vmId);
      metadata.instance.name = String(data.name);
      metadata.project.name = String(data.resourceGroupName);
      metadata.availability_zone = String(data.zone);
      metadata.machine.type = String(data.vmSize);
      metadata.region = String(data.location);
      return metadata;
    }
    module2.exports = { getMetadataAzure };
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports2, module2) {
    var BigNumber = require_bignumber();
    var JSON2 = module2.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports2, module2) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module2.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports2, module2) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse3();
    module2.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module2.exports.parse = json_parse();
    module2.exports.stringify = json_stringify;
  }
});

// node_modules/elastic-apm-node/lib/cloud-metadata/gcp.js
var require_gcp = __commonJS({
  "node_modules/elastic-apm-node/lib/cloud-metadata/gcp.js"(exports2, module2) {
    "use strict";
    var URL2 = require("url").URL;
    var JSONBigInt = require_json_bigint();
    var { httpRequest } = require_http_request();
    var DEFAULT_BASE_URL = new URL2("/", "http://metadata.google.internal:80");
    function getMetadataGcp(connectTimeoutMs, resTimeoutMs, logger, baseUrlOverride, cb) {
      const baseUrl = baseUrlOverride || DEFAULT_BASE_URL;
      const options = {
        method: "GET",
        timeout: resTimeoutMs,
        connectTimeout: connectTimeoutMs,
        headers: {
          "Metadata-Flavor": "Google"
        }
      };
      const url = baseUrl + "computeMetadata/v1/?recursive=true";
      const req = httpRequest(url, options, function(res) {
        const finalData = [];
        res.on("data", function(data) {
          finalData.push(data);
        });
        res.on("end", function(data) {
          if (res.statusCode !== 200) {
            logger.debug("gcp metadata: unexpected statusCode: %s", res.statusCode);
            cb(
              new Error(
                "error fetching gcp metadata: unexpected statusCode: " + res.statusCode
              )
            );
            return;
          }
          let result;
          try {
            result = formatMetadataStringIntoObject(finalData.join(""));
          } catch (err) {
            logger.debug(
              "gcp metadata server responded, but there was an error parsing the result: %o",
              err
            );
            cb(err);
            return;
          }
          cb(null, result);
        });
      });
      req.on("timeout", function() {
        req.destroy(new Error("request to metadata server timed out"));
      });
      req.on("connectTimeout", function() {
        req.destroy(new Error("could not ping metadata server"));
      });
      req.on("error", function(err) {
        cb(err);
      });
      req.end();
    }
    function formatMetadataStringIntoObject(string) {
      const data = JSONBigInt.parse(string);
      const az = data.instance.zone.split("/").pop();
      const metadata = {
        provider: "gcp",
        instance: {
          id: data.instance.id.toString(),
          // We expect this to be a BigInt.
          name: data.instance.name
        },
        project: {
          id: data.project.projectId
        },
        availability_zone: az,
        region: az.slice(0, az.lastIndexOf("-")),
        // 'us-west1-b' -> 'us-west1'
        machine: {
          type: data.instance.machineType.split("/").pop()
        }
      };
      return metadata;
    }
    module2.exports = { getMetadataGcp };
  }
});

// node_modules/elastic-apm-node/lib/cloud-metadata/callback-coordination.js
var require_callback_coordination = __commonJS({
  "node_modules/elastic-apm-node/lib/cloud-metadata/callback-coordination.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var CallbackCoordination = class extends EventEmitter {
      constructor(maxWaitMS = -1, logger) {
        super();
        this.logger = logger;
        this.resultCount = 0;
        this.expectedResults = 0;
        this.errors = [];
        this.scheduled = [];
        this.done = false;
        this.started = false;
        this.timeout = null;
        if (maxWaitMS !== -1) {
          this.timeout = setTimeout(() => {
            if (!this.done) {
              this.complete();
              this.logger.warn(
                "cloud metadata requests timed out, using default values instead"
              );
              const error = new CallbackCoordinationError(
                "callback coordination reached timeout",
                this.errors
              );
              this.emit("error", error);
            }
          }, maxWaitMS);
        }
      }
      /**
       * Finishes coordination
       *
       * Marks as `done`, cleans up timeout (if necessary)
       */
      complete() {
        this.done = true;
        if (this.timeout) {
          clearTimeout(this.timeout);
        }
      }
      /**
       * Accepts and schedules a callback function
       *
       * Callback will be in the form
       *     function(fetcher) {
       *         //... work to fetch data ...
       *
       *         // this callback calls the recordResult method
       *         // method of the fetcher
       *         fetcher.recordResult(error, result)
       *     }
       *
       * Method also increments expectedResults counter to keep track
       * of how many callbacks we've scheduled
       */
      schedule(fetcherCallback) {
        if (this.started) {
          this.logger.error("Can not schedule callback, already started");
          return;
        }
        this.expectedResults++;
        this.scheduled.push(fetcherCallback);
      }
      /**
       * Starts processing of the callbacks scheduled by the `schedule` method
       */
      start() {
        this.started = true;
        if (this.scheduled.length === 0) {
          const error = new CallbackCoordinationError("no callbacks to run");
          this.recordResult(error);
        }
        for (const cb of this.scheduled) {
          process.nextTick(cb.bind(null, this));
        }
      }
      /**
       * Receives calls from scheduled callbacks.
       *
       * If called with a non-error, the method will emit a `result` event
       * and include the results as an argument.  Only a single result
       * is emitted -- if other callbacks respond with a result this method
       * will ignore them.
       *
       * If called by _all_ scheduled callbacks without a non-error, this method
       * will issue the error event.
       */
      recordResult(error, result) {
        this.resultCount++;
        if (error) {
          this.errors.push(error);
          if (this.resultCount >= this.expectedResults && !this.done) {
            this.complete();
            const error2 = new CallbackCoordinationError(
              "no response from any callback, no cloud metadata will be set (normal outside of cloud env.)",
              this.errors
            );
            this.logger.debug("no cloud metadata servers responded");
            this.emit("error", error2);
          }
        }
        if (!error && result && !this.done) {
          this.complete();
          this.emit("result", result);
        }
      }
    };
    var CallbackCoordinationError = class extends Error {
      constructor(message, allErrors = []) {
        super(message);
        this.allErrors = allErrors;
      }
    };
    module2.exports = {
      CallbackCoordination
    };
  }
});

// node_modules/elastic-apm-node/lib/cloud-metadata/index.js
var require_cloud_metadata = __commonJS({
  "node_modules/elastic-apm-node/lib/cloud-metadata/index.js"(exports2, module2) {
    "use strict";
    var { getMetadataAws } = require_aws();
    var { getMetadataAzure } = require_azure();
    var { getMetadataGcp } = require_gcp();
    var { CallbackCoordination } = require_callback_coordination();
    var logging = require_logging();
    var CONNECT_TIMEOUT_MS = 100;
    var DNS_TIMEOUT_MS = 100;
    var HTTP_TIMEOUT_MS = 1e3;
    var COORDINATION_TIMEOUT_MS = 3e3;
    var CloudMetadata = class {
      constructor(cloudProvider, logger, serviceName) {
        this.cloudProvider = cloudProvider;
        this.logger = logger;
        this.serviceName = serviceName;
      }
      /**
       * Fetches Cloud Metadata
       *
       * The module's main entry-point/primary method.  The getCloudMetadata function
       * will query the cloud metadata servers and return (via a callback function)
       * to final metadata object.  This function may be called with a single
       * argument.
       *
       * getCloudMetadata(function(err, metadata){
       *     //...
       * })
       *
       * Or with two
       *
       * getCloudMetadata(config, function(err, metadata){
       *     //...
       * })
       *
       * The config parameter is an object that contains information on the
       * metadata servers.
       */
      getCloudMetadata(config, cb) {
        if (!cb) {
          cb = config;
          config = {};
        }
        config.aws = config.aws ? config.aws : null;
        config.azure = config.azure ? config.azure : null;
        config.gcp = config.gcp ? config.gcp : null;
        const fetcher = new CallbackCoordination(
          COORDINATION_TIMEOUT_MS,
          this.logger
        );
        if (this.shouldFetchGcp()) {
          fetcher.schedule((fetcher2) => {
            const url = config.gcp;
            getMetadataGcp(
              CONNECT_TIMEOUT_MS + DNS_TIMEOUT_MS,
              HTTP_TIMEOUT_MS,
              this.logger,
              url,
              (err, result) => {
                fetcher2.recordResult(err, result);
              }
            );
          });
        }
        if (this.shouldFetchAws()) {
          fetcher.schedule((fetcher2) => {
            const url = config.aws;
            getMetadataAws(
              CONNECT_TIMEOUT_MS,
              HTTP_TIMEOUT_MS,
              this.logger,
              url,
              function(err, result) {
                fetcher2.recordResult(err, result);
              }
            );
          });
        }
        if (this.shouldFetchAzure()) {
          fetcher.schedule((fetcher2) => {
            const url = config.azure;
            getMetadataAzure(
              CONNECT_TIMEOUT_MS,
              HTTP_TIMEOUT_MS,
              this.logger,
              url,
              function(err, result) {
                fetcher2.recordResult(err, result);
              }
            );
          });
        }
        fetcher.on("result", function(result) {
          cb(null, result);
        });
        fetcher.on("error", function(err) {
          cb(err);
        });
        fetcher.start();
      }
      shouldFetchGcp() {
        return this.cloudProvider === "auto" || this.cloudProvider === "gcp";
      }
      shouldFetchAzure() {
        return this.cloudProvider === "auto" || this.cloudProvider === "azure";
      }
      shouldFetchAws() {
        return this.cloudProvider === "auto" || this.cloudProvider === "aws";
      }
    };
    function main(args) {
      const cloudMetadata = new CloudMetadata("auto", logging.createLogger("off"));
      cloudMetadata.getCloudMetadata(function(err, metadata) {
        if (err) {
          console.log("could not fetch metadata, see error below");
          console.log(err);
          process.exit(1);
        } else {
          console.log("fetched the following metadata");
          console.log(metadata);
          process.exit(0);
        }
      });
    }
    if (require.main === module2) {
      main(process.argv);
    }
    module2.exports = {
      CloudMetadata
    };
  }
});

// node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/humanize-ms/index.js
var require_humanize_ms = __commonJS({
  "node_modules/humanize-ms/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ms = require_ms2();
    module2.exports = function(t) {
      if (typeof t === "number") return t;
      var r = ms(t);
      if (r === void 0) {
        var err = new Error(util.format("humanize-ms(%j) result undefined", t));
        console.warn(err.stack);
      }
      return r;
    };
  }
});

// node_modules/agentkeepalive/lib/constants.js
var require_constants5 = __commonJS({
  "node_modules/agentkeepalive/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // agent
      CURRENT_ID: Symbol("agentkeepalive#currentId"),
      CREATE_ID: Symbol("agentkeepalive#createId"),
      INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
      CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
      // socket
      SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
      SOCKET_NAME: Symbol("agentkeepalive#socketName"),
      SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
      SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
    };
  }
});

// node_modules/agentkeepalive/lib/agent.js
var require_agent = __commonJS({
  "node_modules/agentkeepalive/lib/agent.js"(exports2, module2) {
    "use strict";
    var OriginalAgent = require("http").Agent;
    var ms = require_humanize_ms();
    var debug = require("util").debuglog("agentkeepalive");
    var {
      INIT_SOCKET,
      CURRENT_ID,
      CREATE_ID,
      SOCKET_CREATED_TIME,
      SOCKET_NAME,
      SOCKET_REQUEST_COUNT,
      SOCKET_REQUEST_FINISHED_COUNT
    } = require_constants5();
    var defaultTimeoutListenerCount = 1;
    var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
    if (majorVersion >= 11 && majorVersion <= 12) {
      defaultTimeoutListenerCount = 2;
    } else if (majorVersion >= 13) {
      defaultTimeoutListenerCount = 3;
    }
    function deprecate(message) {
      console.log("[agentkeepalive:deprecated] %s", message);
    }
    var Agent = class extends OriginalAgent {
      constructor(options) {
        options = options || {};
        options.keepAlive = options.keepAlive !== false;
        if (options.freeSocketTimeout === void 0) {
          options.freeSocketTimeout = 4e3;
        }
        if (options.keepAliveTimeout) {
          deprecate("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
          options.freeSocketTimeout = options.keepAliveTimeout;
          delete options.keepAliveTimeout;
        }
        if (options.freeSocketKeepAliveTimeout) {
          deprecate("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
          options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
          delete options.freeSocketKeepAliveTimeout;
        }
        if (options.timeout === void 0) {
          options.timeout = Math.max(options.freeSocketTimeout * 2, 8e3);
        }
        options.timeout = ms(options.timeout);
        options.freeSocketTimeout = ms(options.freeSocketTimeout);
        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;
        super(options);
        this[CURRENT_ID] = 0;
        this.createSocketCount = 0;
        this.createSocketCountLastCheck = 0;
        this.createSocketErrorCount = 0;
        this.createSocketErrorCountLastCheck = 0;
        this.closeSocketCount = 0;
        this.closeSocketCountLastCheck = 0;
        this.errorSocketCount = 0;
        this.errorSocketCountLastCheck = 0;
        this.requestCount = 0;
        this.requestCountLastCheck = 0;
        this.timeoutSocketCount = 0;
        this.timeoutSocketCountLastCheck = 0;
        this.on("free", (socket) => {
          const timeout = this.calcSocketTimeout(socket);
          if (timeout > 0 && socket.timeout !== timeout) {
            socket.setTimeout(timeout);
          }
        });
      }
      get freeSocketKeepAliveTimeout() {
        deprecate("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
        return this.options.freeSocketTimeout;
      }
      get timeout() {
        deprecate("agent.timeout is deprecated, please use agent.options.timeout instead");
        return this.options.timeout;
      }
      get socketActiveTTL() {
        deprecate("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
        return this.options.socketActiveTTL;
      }
      calcSocketTimeout(socket) {
        let freeSocketTimeout = this.options.freeSocketTimeout;
        const socketActiveTTL = this.options.socketActiveTTL;
        if (socketActiveTTL) {
          const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
          const diff = socketActiveTTL - aliveTime;
          if (diff <= 0) {
            return diff;
          }
          if (freeSocketTimeout && diff < freeSocketTimeout) {
            freeSocketTimeout = diff;
          }
        }
        if (freeSocketTimeout) {
          const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
          return customFreeSocketTimeout || freeSocketTimeout;
        }
      }
      keepSocketAlive(socket) {
        const result = super.keepSocketAlive(socket);
        if (!result) return result;
        const customTimeout = this.calcSocketTimeout(socket);
        if (typeof customTimeout === "undefined") {
          return true;
        }
        if (customTimeout <= 0) {
          debug(
            "%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s",
            socket[SOCKET_NAME],
            socket[SOCKET_REQUEST_COUNT],
            socket[SOCKET_REQUEST_FINISHED_COUNT],
            customTimeout
          );
          return false;
        }
        if (socket.timeout !== customTimeout) {
          socket.setTimeout(customTimeout);
        }
        return true;
      }
      // only call on addRequest
      reuseSocket(...args) {
        super.reuseSocket(...args);
        const socket = args[0];
        const req = args[1];
        req.reusedSocket = true;
        const agentTimeout = this.options.timeout;
        if (getSocketTimeout(socket) !== agentTimeout) {
          socket.setTimeout(agentTimeout);
          debug("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
        }
        socket[SOCKET_REQUEST_COUNT]++;
        debug(
          "%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          getSocketTimeout(socket)
        );
      }
      [CREATE_ID]() {
        const id = this[CURRENT_ID]++;
        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
        return id;
      }
      [INIT_SOCKET](socket, options) {
        if (options.timeout) {
          const timeout = getSocketTimeout(socket);
          if (!timeout) {
            socket.setTimeout(options.timeout);
          }
        }
        if (this.options.keepAlive) {
          socket.setNoDelay(true);
        }
        this.createSocketCount++;
        if (this.options.socketActiveTTL) {
          socket[SOCKET_CREATED_TIME] = Date.now();
        }
        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
        socket[SOCKET_REQUEST_COUNT] = 1;
        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
        installListeners(this, socket, options);
      }
      createConnection(options, oncreate) {
        let called = false;
        const onNewCreate = (err, socket) => {
          if (called) return;
          called = true;
          if (err) {
            this.createSocketErrorCount++;
            return oncreate(err);
          }
          this[INIT_SOCKET](socket, options);
          oncreate(err, socket);
        };
        const newSocket = super.createConnection(options, onNewCreate);
        if (newSocket) onNewCreate(null, newSocket);
        return newSocket;
      }
      get statusChanged() {
        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
        if (changed) {
          this.createSocketCountLastCheck = this.createSocketCount;
          this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
          this.closeSocketCountLastCheck = this.closeSocketCount;
          this.errorSocketCountLastCheck = this.errorSocketCount;
          this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
          this.requestCountLastCheck = this.requestCount;
        }
        return changed;
      }
      getCurrentStatus() {
        return {
          createSocketCount: this.createSocketCount,
          createSocketErrorCount: this.createSocketErrorCount,
          closeSocketCount: this.closeSocketCount,
          errorSocketCount: this.errorSocketCount,
          timeoutSocketCount: this.timeoutSocketCount,
          requestCount: this.requestCount,
          freeSockets: inspect(this.freeSockets),
          sockets: inspect(this.sockets),
          requests: inspect(this.requests)
        };
      }
    };
    function getSocketTimeout(socket) {
      return socket.timeout || socket._idleTimeout;
    }
    function installListeners(agent, socket, options) {
      debug("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
      function onFree() {
        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;
        socket[SOCKET_REQUEST_FINISHED_COUNT]++;
        agent.requestCount++;
        debug(
          "%s(requests: %s, finished: %s) free",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT]
        );
        const name = agent.getName(options);
        if (socket.writable && agent.requests[name] && agent.requests[name].length) {
          socket[SOCKET_REQUEST_COUNT]++;
          debug(
            "%s(requests: %s, finished: %s) will be reuse on agent free event",
            socket[SOCKET_NAME],
            socket[SOCKET_REQUEST_COUNT],
            socket[SOCKET_REQUEST_FINISHED_COUNT]
          );
        }
      }
      socket.on("free", onFree);
      function onClose(isError) {
        debug(
          "%s(requests: %s, finished: %s) close, isError: %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          isError
        );
        agent.closeSocketCount++;
      }
      socket.on("close", onClose);
      function onTimeout() {
        const listenerCount = socket.listeners("timeout").length;
        const timeout = getSocketTimeout(socket);
        const req = socket._httpMessage;
        const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
        debug(
          "%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          timeout,
          listenerCount,
          defaultTimeoutListenerCount,
          !!req,
          reqTimeoutListenerCount
        );
        if (debug.enabled) {
          debug("timeout listeners: %s", socket.listeners("timeout").map((f) => f.name).join(", "));
        }
        agent.timeoutSocketCount++;
        const name = agent.getName(options);
        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
          socket.destroy();
          agent.removeSocket(socket, options);
          debug("%s is free, destroy quietly", socket[SOCKET_NAME]);
        } else {
          if (reqTimeoutListenerCount === 0) {
            const error = new Error("Socket timeout");
            error.code = "ERR_SOCKET_TIMEOUT";
            error.timeout = timeout;
            socket.destroy(error);
            agent.removeSocket(socket, options);
            debug("%s destroy with timeout error", socket[SOCKET_NAME]);
          }
        }
      }
      socket.on("timeout", onTimeout);
      function onError(err) {
        const listenerCount = socket.listeners("error").length;
        debug(
          "%s(requests: %s, finished: %s) error: %s, listenerCount: %s",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          err,
          listenerCount
        );
        agent.errorSocketCount++;
        if (listenerCount === 1) {
          debug("%s emit uncaught error event", socket[SOCKET_NAME]);
          socket.removeListener("error", onError);
          socket.emit("error", err);
        }
      }
      socket.on("error", onError);
      function onRemove() {
        debug(
          "%s(requests: %s, finished: %s) agentRemove",
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT]
        );
        socket.removeListener("close", onClose);
        socket.removeListener("error", onError);
        socket.removeListener("free", onFree);
        socket.removeListener("timeout", onTimeout);
        socket.removeListener("agentRemove", onRemove);
      }
      socket.on("agentRemove", onRemove);
    }
    module2.exports = Agent;
    function inspect(obj) {
      const res = {};
      for (const key in obj) {
        res[key] = obj[key].length;
      }
      return res;
    }
  }
});

// node_modules/agentkeepalive/lib/https_agent.js
var require_https_agent = __commonJS({
  "node_modules/agentkeepalive/lib/https_agent.js"(exports2, module2) {
    "use strict";
    var OriginalHttpsAgent = require("https").Agent;
    var HttpAgent = require_agent();
    var {
      INIT_SOCKET,
      CREATE_HTTPS_CONNECTION
    } = require_constants5();
    var HttpsAgent = class extends HttpAgent {
      constructor(options) {
        super(options);
        this.defaultPort = 443;
        this.protocol = "https:";
        this.maxCachedSessions = this.options.maxCachedSessions;
        if (this.maxCachedSessions === void 0) {
          this.maxCachedSessions = 100;
        }
        this._sessionCache = {
          map: {},
          list: []
        };
      }
      createConnection(options, oncreate) {
        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
        this[INIT_SOCKET](socket, options);
        return socket;
      }
    };
    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
    [
      "getName",
      "_getSession",
      "_cacheSession",
      // https://github.com/nodejs/node/pull/4982
      "_evictSession"
    ].forEach(function(method) {
      if (typeof OriginalHttpsAgent.prototype[method] === "function") {
        HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
      }
    });
    module2.exports = HttpsAgent;
  }
});

// node_modules/agentkeepalive/index.js
var require_agentkeepalive = __commonJS({
  "node_modules/agentkeepalive/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_agent();
    module2.exports.HttpsAgent = require_https_agent();
    module2.exports.constants = require_constants5();
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/util-deprecate/node.js
var require_node5 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node5()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/container-info.js
var require_container_info = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/container-info.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var uuidSource = "[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}";
    var containerSource = "[0-9a-f]{64}";
    var taskSource = "[0-9a-f]{32}";
    var awsEcsSource = "[0-9a-f]{32}-[0-9]{10}";
    var lineReg = /^(\d+):([^:]*):(.+)$/;
    var podReg = new RegExp(`pod(${uuidSource})(?:.slice)?$`);
    var containerReg = new RegExp(
      `(${uuidSource}|${containerSource})(?:.scope)?$`
    );
    var taskReg = new RegExp(`^/ecs/(${taskSource})/.*$`);
    var ecsMetadata;
    resetEcsMetadata(process.env.ECS_CONTAINER_METADATA_FILE);
    function resetEcsMetadata(file) {
      ecsMetadata = ecsMetadataSync(file);
    }
    function parseLine(line) {
      const [id, groups, path] = (line.match(lineReg) || []).slice(1);
      const data = { id, groups, path };
      const parts = path.split("/");
      const basename = parts.pop();
      const controllers = groups.split(",");
      if (controllers) data.controllers = controllers;
      const containerId = (basename.match(containerReg) || [])[1];
      if (containerId) data.containerId = containerId;
      const podId = (parts.pop().match(podReg) || [])[1];
      if (podId) data.podId = podId.replace(/_/g, "-");
      const taskId = (path.match(taskReg) || [])[1];
      if (taskId) data.taskId = taskId;
      if (!containerId && !ecsMetadata) {
        if (basename.match(awsEcsSource)) {
          data.containerId = basename;
        }
      }
      return data;
    }
    function parse(contents) {
      const data = {
        entries: []
      };
      for (let line of contents.split("\n")) {
        line = line.trim();
        if (line) {
          const lineData = parseLine(line);
          data.entries.push(lineData);
          if (lineData.containerId) {
            data.containerId = lineData.containerId;
          }
          if (lineData.podId) {
            data.podId = lineData.podId;
          }
          if (lineData.taskId) {
            data.taskId = lineData.taskId;
            if (ecsMetadata) {
              data.containerId = ecsMetadata.ContainerID;
            }
          }
        }
      }
      return data;
    }
    function containerInfo(pid = "self") {
      return new Promise((resolve) => {
        fs.readFile(`/proc/${pid}/cgroup`, (err, data) => {
          resolve(err ? void 0 : parse(data.toString()));
        });
      });
    }
    function containerInfoSync(pid = "self") {
      try {
        const data = fs.readFileSync(`/proc/${pid}/cgroup`);
        return parse(data.toString());
      } catch (err) {
      }
    }
    function ecsMetadataSync(ecsMetadataFile) {
      try {
        return ecsMetadataFile && JSON.parse(fs.readFileSync(ecsMetadataFile));
      } catch (err) {
      }
    }
    module2.exports = containerInfo;
    containerInfo.sync = containerInfoSync;
    containerInfo.parse = parse;
    containerInfo.resetEcsMetadata = resetEcsMetadata;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream)) stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/fast-stream-to-buffer/index.js
var require_fast_stream_to_buffer = __commonJS({
  "node_modules/fast-stream-to-buffer/index.js"(exports2, module2) {
    "use strict";
    var eos = require_end_of_stream2();
    module2.exports = streamToBuffer;
    streamToBuffer.onStream = onStream;
    function streamToBuffer(stream, cb) {
      const buffers = [];
      stream.on("data", buffers.push.bind(buffers));
      eos(stream, function(err) {
        switch (buffers.length) {
          case 0:
            cb(err, Buffer.allocUnsafe(0), stream);
            break;
          case 1:
            cb(err, buffers[0], stream);
            break;
          default:
            cb(err, Buffer.concat(buffers), stream);
        }
      });
    }
    function onStream(cb) {
      return function(stream) {
        streamToBuffer(stream, cb);
      };
    }
  }
});

// node_modules/stream-chopper/index.js
var require_stream_chopper = __commonJS({
  "node_modules/stream-chopper/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var zlib = require("zlib");
    var { Writable, PassThrough } = require_readable();
    module2.exports = StreamChopper;
    util.inherits(StreamChopper, Writable);
    StreamChopper.split = Symbol("split");
    StreamChopper.overflow = Symbol("overflow");
    StreamChopper.underflow = Symbol("underflow");
    var types = [
      StreamChopper.split,
      StreamChopper.overflow,
      StreamChopper.underflow
    ];
    function StreamChopper(opts) {
      if (!(this instanceof StreamChopper)) return new StreamChopper(opts);
      if (!opts) opts = {};
      Writable.call(this, opts);
      this.size = opts.size || Infinity;
      this.time = opts.time || -1;
      this.type = types.indexOf(opts.type) === -1 ? StreamChopper.split : opts.type;
      this._transform = opts.transform;
      if (this._transform && this.type === StreamChopper.split) {
        throw new Error("stream-chopper cannot split a transform stream");
      }
      this._bytes = 0;
      this._stream = null;
      this._locked = false;
      this._draining = false;
      this._onunlock = null;
      this._next = noop;
      this._oneos = oneos;
      this._ondrain = ondrain;
      const self2 = this;
      function oneos() {
        self2._removeStream();
      }
      function ondrain() {
        self2._draining = false;
        const next = self2._next;
        self2._next = noop;
        next();
      }
    }
    StreamChopper.prototype.chop = function(cb) {
      if (this.destroyed) {
        if (cb) process.nextTick(cb);
      } else if (this._onunlock === null) {
        this._endStream(cb);
      } else {
        const write = this._onunlock;
        this._onunlock = () => {
          write();
          this._endStream(cb);
        };
      }
    };
    StreamChopper.prototype._startStream = function(cb) {
      if (this.destroyed) return;
      if (this._locked) {
        this._onunlock = cb;
        return;
      }
      this._bytes = 0;
      if (this._transform) {
        this._stream = this._transform().once("resume", () => {
          if (this._stream === null) return;
          this._stream.on("data", (chunk) => {
            this._bytes += chunk.length;
            this._maybeEndTransformSteam();
          });
        });
      } else {
        this._stream = new PassThrough();
      }
      this._stream.on("close", this._oneos).on("error", this._oneos).on("finish", this._oneos).on("end", this._oneos).on("drain", this._ondrain);
      this._locked = true;
      this.emit("stream", this._stream, (err) => {
        this._locked = false;
        if (err) return this.destroy(err);
        const cb2 = this._onunlock;
        if (cb2) {
          this._onunlock = null;
          cb2();
        }
      });
      this.resetTimer();
      cb();
    };
    StreamChopper.prototype._maybeEndTransformSteam = function() {
      if (this._stream === null) return;
      const bufferedSize = getBufferedSize(this._stream);
      const overflow = this._bytes + bufferedSize - this.size;
      if (overflow >= 0) this._endStream();
    };
    StreamChopper.prototype.resetTimer = function(time) {
      if (arguments.length > 0) this.time = time;
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      if (this.time !== -1 && !this.destroyed && this._stream) {
        this._timer = setTimeout(() => {
          this._timer = null;
          this._endStream();
        }, this.time);
        this._timer.unref();
      }
    };
    StreamChopper.prototype._endStream = function(cb) {
      if (this.destroyed) return;
      if (this._stream === null) {
        if (cb) process.nextTick(cb);
        return;
      }
      const stream = this._stream;
      this._removeStream();
      if (!stream._writableState.ending && !stream._writableState.finished) {
        stream.end(cb);
      } else if (cb) {
        process.nextTick(cb);
      }
    };
    StreamChopper.prototype._removeStream = function() {
      if (this._stream === null) return;
      const stream = this._stream;
      this._stream = null;
      if (this._timer !== null) clearTimeout(this._timer);
      if (stream._writableState.needDrain) this._ondrain();
      stream.removeListener("error", this._oneos);
      stream.removeListener("close", this._oneos);
      stream.removeListener("finish", this._oneos);
      stream.removeListener("end", this._oneos);
      stream.removeListener("drain", this._ondrain);
    };
    StreamChopper.prototype._write = function(chunk, enc, cb) {
      if (this._stream === null) {
        this._startStream(() => {
          this._write(chunk, enc, cb);
        });
        return;
      }
      if (isDestroyed(this._stream)) {
        this._startStream(() => {
          this._write(chunk, enc, cb);
        });
        return;
      }
      if (this._transform) {
        this._unprotectedWrite(chunk, enc, cb);
      } else {
        this._protectedWrite(chunk, enc, cb);
      }
    };
    StreamChopper.prototype._protectedWrite = function(chunk, enc, cb) {
      this._bytes += chunk.length;
      const overflow = this._bytes - this.size;
      if (overflow > 0 && this.type !== StreamChopper.overflow) {
        if (this.type === StreamChopper.split) {
          const remaining = chunk.length - overflow;
          this._stream.write(chunk.slice(0, remaining));
          chunk = chunk.slice(remaining);
        }
        if (this.type === StreamChopper.underflow && this._bytes - chunk.length === 0) {
          cb(new Error(`Cannot write ${chunk.length} byte chunk - only ${this.size} available`));
          return;
        }
        this._endStream(() => {
          this._write(chunk, enc, cb);
        });
        return;
      }
      if (overflow < 0) {
        this._unprotectedWrite(chunk, enc, cb);
      } else {
        this._stream.end(chunk);
        this._endStream(cb);
      }
    };
    StreamChopper.prototype._unprotectedWrite = function(chunk, enc, cb) {
      if (this._stream.write(chunk) === false) this._draining = true;
      if (this._draining === false) cb();
      else this._next = cb;
    };
    StreamChopper.prototype._destroy = function(err, cb) {
      const stream = this._stream;
      this._removeStream();
      if (stream !== null) {
        if (stream.destroyed === true) return cb(err);
        destroyStream(stream, function() {
          cb(err);
        });
      } else {
        cb(err);
      }
    };
    StreamChopper.prototype._final = function(cb) {
      if (this._stream === null) return cb();
      this._stream.end(cb);
    };
    function noop() {
    }
    function getBufferedSize(stream) {
      const buffer = stream.writableBuffer || stream._writableState.getBuffer();
      return buffer.reduce((total, b) => {
        return total + b.chunk.length;
      }, 0);
    }
    function isDestroyed(stream) {
      return stream.destroyed === true || stream._handle === null;
    }
    function destroyStream(stream, cb) {
      const emitClose = stream._writableState.emitClose;
      if (emitClose) stream.once("close", cb);
      if (stream instanceof zlib.Gzip || stream instanceof zlib.Gunzip || stream instanceof zlib.Deflate || stream instanceof zlib.DeflateRaw || stream instanceof zlib.Inflate || stream instanceof zlib.InflateRaw || stream instanceof zlib.Unzip) {
        if (typeof stream.destroy === "function") {
          if (stream._handle && typeof stream._handle.close === "function") {
            stream._handle.close();
            stream._handle = null;
          }
          stream.destroy();
        } else if (typeof stream.close === "function") {
          stream.close();
        }
      } else {
        if (typeof stream.destroy === "function") stream.destroy();
        else if (typeof stream.emit === "function") stream.emit("close");
      }
      if (!emitClose) cb();
    }
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/detect-hostname.js
var require_detect_hostname = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/detect-hostname.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { spawnSync } = require("child_process");
    function detectHostname() {
      let hostname = null;
      let out;
      const fallback = os.hostname();
      switch (os.platform()) {
        case "win32":
          out = spawnSync(
            "powershell.exe",
            [
              "-NoLogo",
              "-NonInteractive",
              "-NoProfile",
              "-ExecutionPolicy",
              "Bypass",
              "-Command",
              "[System.Net.Dns]::GetHostEntry($env:computerName).HostName"
            ],
            { encoding: "utf8", shell: true, timeout: 2e3 }
          );
          if (!out.error) {
            hostname = out.stdout.trim();
            break;
          }
          out = spawnSync("hostname.exe", {
            encoding: "utf8",
            shell: true,
            timeout: 2e3
          });
          if (!out.error) {
            hostname = out.stdout.trim();
            break;
          }
          if ("COMPUTERNAME" in process.env) {
            hostname = process.env["COMPUTERNAME"].trim();
          }
          break;
        default:
          out = spawnSync("/bin/hostname", ["-f"], {
            encoding: "utf8",
            shell: false,
            timeout: 500
          });
          if (!out.error) {
            hostname = out.stdout.trim();
          }
          break;
      }
      if (!hostname) {
        hostname = fallback;
      }
      hostname = hostname.trim().toLowerCase();
      return hostname;
    }
    module2.exports = {
      detectHostname
    };
    if (require.main === module2) {
      console.log(detectHostname());
    }
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/ndjson.js
var require_ndjson = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/ndjson.js"(exports2) {
    "use strict";
    var stringify = require_fast_safe_stringify();
    exports2.serialize = function serialize(obj) {
      const str = tryJSONStringify(obj) || stringify(obj);
      return str + "\n";
    };
    function tryJSONStringify(obj) {
      try {
        return JSON.stringify(obj);
      } catch (e) {
      }
    }
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/logging.js
var require_logging2 = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/logging.js"(exports2, module2) {
    "use strict";
    var NoopLogger = class {
      trace() {
      }
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
      fatal() {
      }
      child() {
        return this;
      }
      isLevelEnabled(_level) {
        return false;
      }
    };
    module2.exports = {
      NoopLogger
    };
  }
});

// node_modules/breadth-filter/index.js
var require_breadth_filter = __commonJS({
  "node_modules/breadth-filter/index.js"(exports2, module2) {
    var entries = require_object();
    function defaultOnArray() {
      return [];
    }
    function defaultOnObject() {
      return {};
    }
    function targetFor(source, key, fieldPath, isNew, {
      onArray = defaultOnArray,
      onObject = defaultOnObject
    } = {}) {
      if (Array.isArray(source)) {
        return onArray(source, key, fieldPath, isNew);
      } else if (source !== null && typeof source === "object") {
        return onObject(source, key, fieldPath, isNew);
      }
    }
    module2.exports = function breadthFilter(root, opts = {}) {
      const { onValue } = opts;
      const target = targetFor(root, null, [], true, opts);
      if (!target) return root;
      const queue = [[root, target, []]];
      const seen = /* @__PURE__ */ new Set([root]);
      let item;
      while (item = queue.shift()) {
        const [source, target2, path] = item;
        for (const [key, value] of entries(source)) {
          const fieldPath = path.concat(key);
          const isNew = !seen.has(value);
          if (isNew) seen.add(value);
          const newTarget = targetFor(value, key, fieldPath, isNew, opts);
          if (newTarget) {
            target2[key] = newTarget;
            if (isNew) {
              queue.push([value, target2[key], fieldPath]);
            }
          } else {
            target2[key] = onValue(value, key, fieldPath);
          }
        }
      }
      return target;
    };
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/truncate.js
var require_truncate = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/truncate.js"(exports2) {
    "use strict";
    var breadthFilter = require_breadth_filter();
    exports2.metadata = truncMetadata;
    exports2.transaction = truncTransaction;
    exports2.span = truncSpan;
    exports2.error = truncError;
    exports2.metricset = truncMetricSet;
    function unitrunc(s, max) {
      if (s.length > max) {
        if (max <= 0) {
          return "";
        }
        const endChar = s.charCodeAt(max - 1);
        if (endChar >= 55296 && endChar <= 56319) {
          return s.slice(0, max - 1);
        } else {
          return s.slice(0, max);
        }
      }
      return s;
    }
    function truncMetadata(metadata, opts) {
      return breadthFilter(metadata, {
        onArray,
        onObject,
        onValue(value, key, path) {
          if (typeof value !== "string") {
            return value;
          }
          let max = opts.truncateStringsAt;
          switch (path[0]) {
            case "service":
              switch (path[1]) {
                case "name":
                case "version":
                case "environment":
                  max = opts.truncateKeywordsAt;
                  break;
                case "agent":
                case "framework":
                case "language":
                case "runtime":
                  switch (path[2]) {
                    case "name":
                    case "version":
                      max = opts.truncateKeywordsAt;
                      break;
                  }
                  break;
              }
              break;
            case "process":
              if (path[1] === "title") {
                max = opts.truncateKeywordsAt;
              }
              break;
            case "system":
              switch (path[1]) {
                case "architecture":
                case "hostname":
                case "platform":
                  max = opts.truncateKeywordsAt;
                  break;
              }
              break;
            case "cloud":
              switch (path[1]) {
                case "availability_zone":
                case "provider":
                case "region":
                  max = opts.truncateKeywordsAt;
                  break;
                case "account":
                  switch (path[2]) {
                    case "id":
                    case "name":
                      max = opts.truncateKeywordsAt;
                      break;
                  }
                  break;
                case "instance":
                  switch (path[2]) {
                    case "id":
                    case "name":
                      max = opts.truncateKeywordsAt;
                      break;
                  }
                  break;
                case "machine":
                  switch (path[2]) {
                    case "type":
                      max = opts.truncateKeywordsAt;
                      break;
                  }
                  break;
                case "project":
                  switch (path[2]) {
                    case "id":
                    case "name":
                      max = opts.truncateKeywordsAt;
                      break;
                  }
              }
              break;
          }
          return unitrunc(value, max);
        }
      });
    }
    function truncTransaction(trans, opts) {
      const result = breadthFilter(trans, {
        onArray,
        onObject: onObjectWithHeaders,
        onValue(value, key, path) {
          if (typeof value !== "string") {
            if (isHeader(path)) return String(value);
            return value;
          }
          let max = opts.truncateStringsAt;
          switch (path[0]) {
            case "name":
            case "type":
            case "result":
            case "id":
            case "trace_id":
            case "parent_id":
              max = opts.truncateKeywordsAt;
              break;
            case "context":
              max = contextLength(path, opts);
              break;
          }
          return unitrunc(value, max);
        }
      });
      return Object.assign(
        {
          name: "undefined",
          type: "undefined",
          result: "undefined"
        },
        result
      );
    }
    function truncSpan(span, opts) {
      let result = breadthFilter(span, {
        onArray,
        onObject,
        onValue(value, key, path) {
          if (typeof value !== "string") {
            return value;
          }
          let max = opts.truncateStringsAt;
          switch (path[0]) {
            case "name":
            case "type":
            case "id":
            case "trace_id":
            case "parent_id":
            case "transaction_id":
            case "subtype":
            case "action":
              max = opts.truncateKeywordsAt;
              break;
            case "context":
              max = contextLength(path, opts);
              break;
          }
          return unitrunc(value, max);
        }
      });
      result = truncateCustomKeys(result, opts.truncateCustomKeysAt, [
        "name",
        "type",
        "id",
        "trace_id",
        "parent_id",
        "transaction_id",
        "subtype",
        "action",
        "context"
      ]);
      return Object.assign(
        {
          name: "undefined",
          type: "undefined"
        },
        result
      );
    }
    function truncError(error, opts) {
      return breadthFilter(error, {
        onArray,
        onObject: onObjectWithHeaders,
        onValue(value, key, path) {
          if (typeof value !== "string") {
            if (isHeader(path)) return String(value);
            return value;
          }
          let max = opts.truncateStringsAt;
          switch (path[0]) {
            case "id":
            case "trace_id":
            case "parent_id":
            case "transaction_id":
              max = opts.truncateKeywordsAt;
              break;
            case "context":
              max = contextLength(path, opts);
              break;
            case "log":
              switch (path[1]) {
                case "level":
                case "logger_name":
                case "param_message":
                  max = opts.truncateKeywordsAt;
                  break;
                case "message":
                  if (opts.truncateErrorMessagesAt === void 0) {
                    max = opts.truncateLongFieldsAt;
                  } else if (opts.truncateErrorMessagesAt < 0) {
                    return value;
                  } else {
                    max = opts.truncateErrorMessagesAt;
                  }
                  break;
              }
              break;
            case "exception":
              switch (path[1]) {
                case "type":
                case "code":
                case "module":
                  max = opts.truncateKeywordsAt;
                  break;
                case "message":
                  if (opts.truncateErrorMessagesAt === void 0) {
                    max = opts.truncateLongFieldsAt;
                  } else if (opts.truncateErrorMessagesAt < 0) {
                    return value;
                  } else {
                    max = opts.truncateErrorMessagesAt;
                  }
                  break;
              }
              break;
          }
          return unitrunc(value, max);
        }
      });
    }
    function truncMetricSet(metricset, opts) {
      return breadthFilter(metricset, {
        onArray,
        onObject,
        onValue(value, key, path) {
          if (typeof value !== "string") {
            return value;
          }
          const max = path[0] === "tags" ? opts.truncateKeywordsAt : opts.truncateStringsAt;
          return unitrunc(value, max);
        }
      });
    }
    function contextLength(path, opts) {
      switch (path[1]) {
        case "db":
          if (path[2] === "statement") {
            return opts.truncateLongFieldsAt;
          }
          break;
        case "message":
          if (path[2] === "body") {
            return opts.truncateLongFieldsAt;
          }
          break;
        case "request":
          switch (path[2]) {
            case "method":
            case "http_version":
              return opts.truncateKeywordsAt;
            case "body":
              return opts.truncateLongFieldsAt;
            case "url":
              switch (path[3]) {
                case "protocol":
                case "hostname":
                case "port":
                case "pathname":
                case "search":
                case "hash":
                case "raw":
                case "full":
                  return opts.truncateKeywordsAt;
              }
              break;
          }
          break;
        case "user":
          switch (path[2]) {
            case "id":
            case "email":
            case "username":
              return opts.truncateKeywordsAt;
          }
          break;
        case "tags":
          return opts.truncateKeywordsAt;
        case "destination":
          switch (path[2]) {
            case "address":
              return opts.truncateKeywordsAt;
            case "service":
              switch (path[3]) {
                case "name":
                case "resource":
                case "type":
                  return opts.truncateKeywordsAt;
              }
              break;
          }
          break;
      }
      return opts.truncateStringsAt;
    }
    function isHeader(path) {
      return path[0] === "context" && (path[1] === "request" || path[1] === "response") && path[2] === "headers" && path[3];
    }
    function onObjectWithHeaders(value, key, path, isNew) {
      if (isHeader(path)) return String(value);
      return onObject(value, key, path, isNew);
    }
    function onObject(value, key, path, isNew) {
      return isNew ? {} : "[Circular]";
    }
    function onArray(value, key, path, isNew) {
      return isNew ? [] : "[Circular]";
    }
    function truncateCustomKeys(value, max, keywords) {
      if (typeof value !== "object" || value === null) {
        return value;
      }
      const result = value;
      const keys = Object.keys(result);
      const truncatedKeys = keys.map((k) => {
        if (keywords.includes(k)) {
          return k;
        }
        return unitrunc(k, max);
      });
      for (const [index, k] of keys.entries()) {
        const value2 = result[k];
        delete result[k];
        const newKey = truncatedKeys[index];
        result[newKey] = truncateCustomKeys(value2, max, keywords);
      }
      return result;
    }
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/central-config.js
var require_central_config = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/central-config.js"(exports2, module2) {
    "use strict";
    var INTERVAL_DEFAULT_S = 300;
    var INTERVAL_MIN_S = 5;
    var INTERVAL_MAX_S = 86400;
    function getCentralConfigIntervalS(seconds) {
      if (typeof seconds !== "number" || isNaN(seconds) || seconds <= 0) {
        return INTERVAL_DEFAULT_S;
      }
      return Math.min(Math.max(seconds, INTERVAL_MIN_S), INTERVAL_MAX_S);
    }
    module2.exports = {
      getCentralConfigIntervalS,
      // These are exported for testing.
      INTERVAL_DEFAULT_S,
      INTERVAL_MIN_S,
      INTERVAL_MAX_S
    };
  }
});

// node_modules/elastic-apm-node/lib/apm-client/http-apm-client/index.js
var require_http_apm_client = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/http-apm-client/index.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var crypto2 = require("crypto");
    var fs = require("fs");
    var http = require("http");
    var https = require("https");
    var util = require("util");
    var { performance: performance2 } = require("perf_hooks");
    var { URL: URL2 } = require("url");
    var zlib = require("zlib");
    var HttpAgentKeepAlive = require_agentkeepalive();
    var HttpsAgentKeepAlive = HttpAgentKeepAlive.HttpsAgent;
    var Filters = require_object_filter_sequence();
    var querystring = require("querystring");
    var Writable = require_readable().Writable;
    var getContainerInfo = require_container_info();
    var eos = require_end_of_stream2();
    var semver = require_semver2();
    var streamToBuffer = require_fast_stream_to_buffer();
    var StreamChopper = require_stream_chopper();
    var { detectHostname } = require_detect_hostname();
    var ndjson = require_ndjson();
    var { NoopLogger } = require_logging2();
    var truncate = require_truncate();
    var { getCentralConfigIntervalS } = require_central_config();
    module2.exports = {
      HttpApmClient: Client
    };
    var kFlush = Symbol("flush");
    var kLambdaEndFlush = Symbol("lambdaEndFlush");
    function isFlushMarker(obj) {
      return obj === kFlush || obj === kLambdaEndFlush;
    }
    var requiredOpts = ["agentName", "agentVersion", "serviceName", "userAgent"];
    var httpGet = http.get;
    var httpRequest = http.request;
    var httpsGet = https.get;
    var httpsRequest = https.request;
    var containerInfo = getContainerInfo.sync();
    var isLambdaExecutionEnvironment = !!process.env.AWS_LAMBDA_FUNCTION_NAME;
    var clientsToAutoEnd = [];
    if (!isLambdaExecutionEnvironment) {
      process.once("beforeExit", function() {
        clientsToAutoEnd.forEach(function(client) {
          if (!client) {
            return;
          }
          client._gracefulExit();
        });
      });
    }
    util.inherits(Client, Writable);
    Client.encoding = Object.freeze({
      METADATA: Symbol("metadata"),
      TRANSACTION: Symbol("transaction"),
      SPAN: Symbol("span"),
      ERROR: Symbol("error"),
      METRICSET: Symbol("metricset")
    });
    function Client(opts) {
      if (!(this instanceof Client)) return new Client(opts);
      Writable.call(this, { objectMode: true });
      this._corkTimer = null;
      this._agent = null;
      this._activeIntakeReq = false;
      this._onIntakeReqConcluded = null;
      this._transport = null;
      this._configTimer = null;
      this._backoffReconnectCount = 0;
      this._intakeRequestGracefulExitFn = null;
      this._encodedMetadata = null;
      this._cloudMetadata = null;
      this._extraMetadata = null;
      this._metadataFilters = new Filters();
      this._lambdaActive = false;
      this._lambdaShouldRegisterTransactions = true;
      this._numEvents = 0;
      this._numEventsDropped = 0;
      this._numEventsEnqueued = 0;
      this.sent = 0;
      this._slowWriteBatch = {
        // data on slow or the slowest _writeBatch
        numOver10Ms: 0,
        // Data for the slowest _writeBatch:
        encodeTimeMs: 0,
        fullTimeMs: 0,
        numEvents: 0,
        numBytes: 0
      };
      this.config(opts);
      this._log = this._conf.logger || new NoopLogger();
      this._apmServerVersion = this._conf.apmServerVersion ? new semver.SemVer(this._conf.apmServerVersion) : void 0;
      if (!this._apmServerVersion) {
        this._fetchApmServerVersion();
      }
      const numExtraMdOpts = [
        this._conf.cloudMetadataFetcher,
        this._conf.expectExtraMetadata,
        this._conf.extraMetadata
      ].reduce((accum, curr) => curr ? accum + 1 : accum, 0);
      if (numExtraMdOpts > 1) {
        throw new Error(
          'it is an error to configure a Client with more than one of "cloudMetadataFetcher", "expectExtraMetadata", or "extraMetadata"'
        );
      } else if (this._conf.cloudMetadataFetcher) {
        this._log.trace("corking (cloudMetadataFetcher)");
        this.cork();
        this._fetchAndEncodeMetadata(() => {
          this._maybeUncork();
          this._log.trace("uncorked (cloudMetadataFetcher)");
          this.emit("cloud-metadata", this._encodedMetadata);
        });
      } else if (this._conf.expectExtraMetadata) {
        this._log.trace("corking (expectExtraMetadata)");
        this.cork();
      } else if (this._conf.extraMetadata) {
        this.setExtraMetadata(this._conf.extraMetadata);
      } else {
        this._resetEncodedMetadata();
      }
      this._chopper = new StreamChopper({
        size: this._conf.size,
        time: this._conf.time,
        type: StreamChopper.overflow,
        transform() {
          return zlib.createGzip({
            level: zlib.constants.Z_BEST_SPEED
          });
        }
      });
      const onIntakeError = (err) => {
        if (this.destroyed === false) {
          this.emit("request-error", err);
        }
      };
      this._chopper.on("stream", getChoppedStreamHandler(this, onIntakeError));
      const fail = () => {
        if (this._writableState.ending === false) this.destroy();
      };
      eos(this._chopper, fail);
      this._index = clientsToAutoEnd.length;
      clientsToAutoEnd.push(this);
      if (isLambdaExecutionEnvironment && this._log.isLevelEnabled("trace")) {
        process.prependListener("beforeExit", () => {
          this._log.trace('process "beforeExit"');
        });
      }
      if (this._conf.centralConfig) {
        this._pollConfig();
      }
    }
    Client.prototype._getStats = function() {
      return {
        numEvents: this._numEvents,
        numEventsDropped: this._numEventsDropped,
        numEventsEnqueued: this._numEventsEnqueued,
        numEventsSent: this.sent,
        slowWriteBatch: this._slowWriteBatch,
        backoffReconnectCount: this._backoffReconnectCount
      };
    };
    Client.prototype.config = function(opts) {
      this._conf = Object.assign(this._conf || {}, opts);
      this._conf.globalLabels = normalizeGlobalLabels(this._conf.globalLabels);
      const missing = requiredOpts.filter((name) => !this._conf[name]);
      if (missing.length > 0)
        throw new Error("Missing required option(s): " + missing.join(", "));
      if (!this._conf.size && this._conf.size !== 0) this._conf.size = 750 * 1024;
      if (!this._conf.time && this._conf.time !== 0) this._conf.time = 1e4;
      if (!this._conf.serverTimeout && this._conf.serverTimeout !== 0)
        this._conf.serverTimeout = 15e3;
      if (!this._conf.serverUrl) this._conf.serverUrl = "http://127.0.0.1:8200";
      if (!this._conf.truncateKeywordsAt) this._conf.truncateKeywordsAt = 1024;
      if (!this._conf.truncateStringsAt) this._conf.truncateStringsAt = 1024;
      if (!this._conf.truncateCustomKeysAt) this._conf.truncateCustomKeysAt = 1024;
      if (!this._conf.truncateLongFieldsAt) this._conf.truncateLongFieldsAt = 1e4;
      if (!this._conf.bufferWindowTime) this._conf.bufferWindowTime = 20;
      if (!this._conf.bufferWindowSize) this._conf.bufferWindowSize = 50;
      if (!this._conf.maxQueueSize) this._conf.maxQueueSize = 1024;
      if (!this._conf.intakeResTimeout) this._conf.intakeResTimeout = 1e4;
      if (!this._conf.intakeResTimeoutOnEnd)
        this._conf.intakeResTimeoutOnEnd = 1e3;
      this._conf.keepAlive = this._conf.keepAlive !== false;
      this._conf.centralConfig = this._conf.centralConfig || false;
      if (!("keepAliveMsecs" in this._conf)) this._conf.keepAliveMsecs = 1e3;
      if (!("maxSockets" in this._conf)) this._conf.maxSockets = Infinity;
      if (!("maxFreeSockets" in this._conf)) this._conf.maxFreeSockets = 256;
      if (!("freeSocketTimeout" in this._conf)) this._conf.freeSocketTimeout = 4e3;
      this._conf.serverUrl = new URL2(this._conf.serverUrl);
      this._conf.detectedHostname = detectHostname();
      if (containerInfo) {
        if (!this._conf.containerId && containerInfo.containerId) {
          this._conf.containerId = containerInfo.containerId;
        }
        if (!this._conf.kubernetesPodUID && containerInfo.podId) {
          this._conf.kubernetesPodUID = containerInfo.podId;
        }
        if (!this._conf.kubernetesPodName && containerInfo.podId) {
          this._conf.kubernetesPodName = this._conf.detectedHostname.split(
            ".",
            1
          )[0];
        }
      }
      let AgentKeepAlive;
      switch (this._conf.serverUrl.protocol) {
        case "http:":
          this._transport = http;
          this._transportRequest = httpRequest;
          this._transportGet = httpGet;
          AgentKeepAlive = HttpAgentKeepAlive;
          break;
        case "https:":
          this._transport = https;
          this._transportRequest = httpsRequest;
          this._transportGet = httpsGet;
          AgentKeepAlive = HttpsAgentKeepAlive;
          break;
        default:
          throw new Error("Unknown protocol " + this._conf.serverUrl.protocol);
      }
      if (!this._agent || opts && "serverUrl" in opts) {
        if (this._agent) {
          this._agent.destroy();
        }
        this._agent = new AgentKeepAlive({
          keepAlive: this._conf.keepAlive,
          keepAliveMsecs: this._conf.keepAliveMsecs,
          freeSocketTimeout: this._conf.freeSocketTimeout,
          timeout: this._conf.serverTimeout,
          maxSockets: this._conf.maxSockets,
          maxFreeSockets: this._conf.maxFreeSockets
        });
      }
      this._conf.requestIntake = getIntakeRequestOptions(this._conf, this._agent);
      this._conf.requestConfig = getConfigRequestOptions(this._conf, this._agent);
      this._conf.requestSignalLambdaEnd = getSignalLambdaEndRequestOptions(
        this._conf,
        this._agent
      );
      this._conf.requestRegisterTransaction = getRegisterTransactionRequestOptions(
        this._conf,
        this._agent
      );
      if (this._encodedMetadata) {
        this._resetEncodedMetadata();
      }
    };
    Client.prototype.setExtraMetadata = function(extraMetadata) {
      if (!this._extraMetadata) {
        this._extraMetadata = extraMetadata;
      } else {
        metadataMergeDeep(this._extraMetadata, extraMetadata);
      }
      this._resetEncodedMetadata();
      if (this._conf.expectExtraMetadata) {
        this._log.trace("maybe uncork (expectExtraMetadata)");
        this._maybeUncork();
      }
    };
    Client.prototype.addMetadataFilter = function(fn) {
      assert.strictEqual(typeof fn, "function", "fn arg must be a function");
      this._metadataFilters.push(fn);
      if (this._encodedMetadata) {
        this._resetEncodedMetadata();
      }
    };
    Client.prototype._resetEncodedMetadata = function() {
      let metadata = metadataFromConf(this._conf, this);
      if (this._cloudMetadata) {
        metadata.cloud = deepClone(this._cloudMetadata);
      }
      if (this._extraMetadata) {
        metadataMergeDeep(metadata, deepClone(this._extraMetadata));
      }
      if (this._metadataFilters && this._metadataFilters.length > 0) {
        metadata = this._metadataFilters.process(metadata);
      }
      this._encodedMetadata = this._encode({ metadata }, Client.encoding.METADATA);
      this._log.trace(
        { _encodedMetadata: this._encodedMetadata },
        "_resetEncodedMetadata"
      );
    };
    Client.prototype._pollConfig = function() {
      const opts = this._conf.requestConfig;
      if (this._conf.lastConfigEtag) {
        opts.headers["If-None-Match"] = this._conf.lastConfigEtag;
      }
      const req = this._transportGet(opts, (res) => {
        res.on("error", (err) => {
          res.destroy(err);
        });
        this._scheduleNextConfigPoll(getMaxAge(res));
        if (res.statusCode === 304) {
          this._log.trace("_pollConfig: no new central config since last poll");
          res.resume();
          return;
        } else if (res.statusCode === 403) {
          this._log.debug("_pollConfig: central config not enabled in APM Server");
          res.resume();
          return;
        } else if (res.statusCode === 404) {
          this._log.debug(
            "_pollConfig: APM server does not support central config"
          );
          res.resume();
          return;
        }
        streamToBuffer(res, (err, buf) => {
          if (err) {
            this.emit("request-error", processConfigErrorResponse(res, buf, err));
            return;
          }
          if (res.statusCode === 200) {
            const etag = res.headers.etag;
            if (etag) this._conf.lastConfigEtag = etag;
            let config;
            try {
              config = JSON.parse(buf);
            } catch (parseErr) {
              this.emit(
                "request-error",
                processConfigErrorResponse(res, buf, parseErr)
              );
              return;
            }
            this.emit("config", config);
          } else {
            this.emit("request-error", processConfigErrorResponse(res, buf));
          }
        });
      });
      req.on("error", (err) => {
        this._scheduleNextConfigPoll();
        this.emit("request-error", err);
      });
    };
    Client.prototype._scheduleNextConfigPoll = function(seconds) {
      if (this._configTimer !== null) return;
      const delayS = getCentralConfigIntervalS(seconds);
      this._configTimer = setTimeout(() => {
        this._configTimer = null;
        this._pollConfig();
      }, delayS * 1e3);
      this._configTimer.unref();
    };
    Client.prototype._ref = function() {
      Object.keys(this._agent.sockets).forEach((remote) => {
        this._agent.sockets[remote].forEach(function(socket) {
          socket.ref();
        });
      });
    };
    Client.prototype._write = function(obj, enc, cb) {
      if (isFlushMarker(obj)) {
        this._writeFlush(obj, cb);
      } else {
        const t = process.hrtime();
        const chunk = this._encode(obj, enc);
        this._numEventsEnqueued++;
        this._chopper.write(chunk, cb);
        this._log.trace(
          {
            fullTimeMs: deltaMs(t),
            numEvents: 1,
            numBytes: chunk.length
          },
          "_write: encode object"
        );
      }
    };
    Client.prototype._writev = function(objs, cb) {
      const MAX_WRITE_BATCH_SIZE = 32;
      let offset = 0;
      const processBatch = () => {
        if (this.destroyed) {
          cb();
          return;
        }
        let flushIdx = -1;
        const limit = Math.min(objs.length, offset + MAX_WRITE_BATCH_SIZE);
        for (let i = offset; i < limit; i++) {
          if (isFlushMarker(objs[i].chunk)) {
            flushIdx = i;
            break;
          }
        }
        if (offset === 0 && flushIdx === -1 && objs.length <= MAX_WRITE_BATCH_SIZE) {
          this._writeBatch(objs, cb);
        } else if (flushIdx === -1) {
          this._writeBatch(
            objs.slice(offset, limit),
            limit === objs.length ? cb : processBatch
          );
          offset = limit;
        } else if (flushIdx > offset) {
          this._writeBatch(objs.slice(offset, flushIdx), processBatch);
          offset = flushIdx;
        } else if (flushIdx === objs.length - 1) {
          this._writeFlush(objs[flushIdx].chunk, cb);
        } else {
          this._writeFlush(objs[flushIdx].chunk, processBatch);
          offset++;
        }
      };
      processBatch();
    };
    Client.prototype._writeBatch = function(objs, cb) {
      const t = process.hrtime();
      const chunks = [];
      for (var i = 0; i < objs.length; i++) {
        const obj = objs[i];
        chunks.push(this._encode(obj.chunk, obj.encoding));
      }
      const chunk = chunks.join("");
      const encodeTimeMs = deltaMs(t);
      this._numEventsEnqueued += objs.length;
      this._chopper.write(chunk, cb);
      const fullTimeMs = deltaMs(t);
      if (fullTimeMs > this._slowWriteBatch.fullTimeMs) {
        this._slowWriteBatch.encodeTimeMs = encodeTimeMs;
        this._slowWriteBatch.fullTimeMs = fullTimeMs;
        this._slowWriteBatch.numEvents = objs.length;
        this._slowWriteBatch.numBytes = chunk.length;
      }
      if (fullTimeMs > 10) {
        this._slowWriteBatch.numOver10Ms++;
      }
      this._log.trace(
        {
          encodeTimeMs,
          fullTimeMs,
          numEvents: objs.length,
          numBytes: chunk.length
        },
        "_writeBatch"
      );
    };
    Client.prototype._writeFlush = function(flushMarker, cb) {
      this._log.trace(
        {
          activeIntakeReq: this._activeIntakeReq,
          lambdaEnd: flushMarker === kLambdaEndFlush
        },
        "_writeFlush"
      );
      let onFlushed = cb;
      if (isLambdaExecutionEnvironment && flushMarker === kLambdaEndFlush) {
        onFlushed = () => {
          this._signalLambdaEnd(cb);
        };
      }
      if (this._activeIntakeReq) {
        this._onIntakeReqConcluded = onFlushed;
        this._chopper.chop();
      } else {
        this._chopper.chop(onFlushed);
      }
    };
    Client.prototype._maybeCork = function() {
      if (!this._writableState.corked) {
        if (isLambdaExecutionEnvironment && !this._lambdaActive) {
          this.cork();
        } else if (this._conf.bufferWindowTime !== -1) {
          this.cork();
          if (this._corkTimer && this._corkTimer.refresh) {
            this._corkTimer.refresh();
          } else {
            this._corkTimer = setTimeout(() => {
              this.uncork();
            }, this._conf.bufferWindowTime);
          }
        }
      } else if (this._writableState.length >= this._conf.bufferWindowSize) {
        this._maybeUncork();
      }
    };
    Client.prototype._maybeUncork = function() {
      if (!this._encodedMetadata) {
        return;
      } else if (isLambdaExecutionEnvironment && !this._lambdaActive) {
        return;
      }
      if (this._writableState.corked) {
        process.nextTick(() => {
          if (this.destroyed === false && !(isLambdaExecutionEnvironment && !this._lambdaActive)) {
            this.uncork();
          }
        });
        if (this._corkTimer) {
          clearTimeout(this._corkTimer);
          this._corkTimer = null;
        }
      }
    };
    Client.prototype._encode = function(obj, enc) {
      const out = {};
      switch (enc) {
        case Client.encoding.SPAN:
          out.span = truncate.span(obj.span, this._conf);
          break;
        case Client.encoding.TRANSACTION:
          out.transaction = truncate.transaction(obj.transaction, this._conf);
          break;
        case Client.encoding.METADATA:
          out.metadata = truncate.metadata(obj.metadata, this._conf);
          break;
        case Client.encoding.ERROR:
          out.error = truncate.error(obj.error, this._conf);
          break;
        case Client.encoding.METRICSET:
          out.metricset = truncate.metricset(obj.metricset, this._conf);
          break;
      }
      return ndjson.serialize(out);
    };
    Client.prototype.lambdaStart = function() {
      this._lambdaActive = true;
    };
    Client.prototype.lambdaShouldRegisterTransactions = function() {
      return this._lambdaShouldRegisterTransactions;
    };
    Client.prototype.lambdaRegisterTransaction = function(trans, awsRequestId) {
      if (!isLambdaExecutionEnvironment) {
        return;
      }
      if (!this._lambdaShouldRegisterTransactions) {
        return;
      }
      assert(this._encodedMetadata, "_encodedMetadata is set");
      const TIMEOUT_MS = 5e3;
      const startTime = performance2.now();
      return new Promise((resolve, reject) => {
        this._log.trace(
          { awsRequestId, traceId: trans.trace_id, transId: trans.id },
          "lambdaRegisterTransaction start"
        );
        var out = this._encode({ transaction: trans }, Client.encoding.TRANSACTION);
        const finish = (errOrErrMsg) => {
          const durationMs = performance2.now() - startTime;
          if (errOrErrMsg) {
            this._log.debug(
              { awsRequestId, err: errOrErrMsg, durationMs },
              "lambdaRegisterTransaction unsuccessful"
            );
            this._lambdaShouldRegisterTransactions = false;
          } else {
            this._log.trace(
              { awsRequestId, durationMs },
              "lambdaRegisterTransaction success"
            );
          }
          resolve();
        };
        this._conf.requestRegisterTransaction.headers["x-elastic-aws-request-id"] = awsRequestId;
        const req = this._transportRequest(
          this._conf.requestRegisterTransaction,
          (res) => {
            res.on("error", (err) => {
              res.destroy(err);
            });
            res.resume();
            if (res.statusCode !== 200) {
              finish(`unexpected response status code: ${res.statusCode}`);
              return;
            }
            res.on("end", function() {
              finish();
            });
          }
        );
        req.setTimeout(TIMEOUT_MS);
        req.on("timeout", () => {
          req.destroy(
            new Error(`timeout (${TIMEOUT_MS}ms) registering lambda transaction`)
          );
        });
        req.on("error", (err) => {
          finish(err);
        });
        req.write(this._encodedMetadata);
        req.write(out);
        req.end();
      });
    };
    Client.prototype._isUnsafeToWrite = function() {
      return this.destroyed;
    };
    Client.prototype._shouldDropEvent = function() {
      this._numEvents++;
      const shouldDrop = this._writableState.length >= this._conf.maxQueueSize;
      if (shouldDrop) {
        this._numEventsDropped++;
      }
      return shouldDrop;
    };
    Client.prototype.sendSpan = function(span, cb) {
      if (this._isUnsafeToWrite() || this._shouldDropEvent()) {
        return;
      }
      this._maybeCork();
      return this.write({ span }, Client.encoding.SPAN, cb);
    };
    Client.prototype.sendTransaction = function(transaction, cb) {
      if (this._isUnsafeToWrite() || this._shouldDropEvent()) {
        return;
      }
      this._maybeCork();
      return this.write({ transaction }, Client.encoding.TRANSACTION, cb);
    };
    Client.prototype.sendError = function(error, cb) {
      if (this._isUnsafeToWrite() || this._shouldDropEvent()) {
        return;
      }
      this._maybeCork();
      return this.write({ error }, Client.encoding.ERROR, cb);
    };
    Client.prototype.sendMetricSet = function(metricset, cb) {
      if (this._isUnsafeToWrite() || this._shouldDropEvent()) {
        return;
      }
      this._maybeCork();
      return this.write({ metricset }, Client.encoding.METRICSET, cb);
    };
    Client.prototype.flush = function(opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      } else if (!opts) {
        opts = {};
      }
      const lambdaEnd = !!opts.lambdaEnd;
      if (lambdaEnd && isLambdaExecutionEnvironment && this._lambdaActive) {
        assert(
          this._encodedMetadata,
          "client.flush({lambdaEnd:true}) must not be called before metadata has been set"
        );
        const rv = this.write(kLambdaEndFlush, cb);
        this.uncork();
        this._lambdaActive = false;
        return rv;
      } else {
        this._maybeUncork();
        return this.write(kFlush, cb);
      }
    };
    Client.prototype._gracefulExit = function() {
      this._log.trace("_gracefulExit");
      if (this._intakeRequestGracefulExitFn) {
        this._intakeRequestGracefulExitFn();
      }
      this._ref();
      this.end();
    };
    Client.prototype._final = function(cb) {
      this._log.trace("_final");
      if (this._configTimer) {
        clearTimeout(this._configTimer);
        this._configTimer = null;
      }
      clientsToAutoEnd[this._index] = null;
      this._ref();
      this._chopper.end();
      cb();
    };
    Client.prototype._destroy = function(err, cb) {
      this._log.trace({ err }, "_destroy");
      if (this._configTimer) {
        clearTimeout(this._configTimer);
        this._configTimer = null;
      }
      if (this._corkTimer) {
        clearTimeout(this._corkTimer);
        this._corkTimer = null;
      }
      clientsToAutoEnd[this._index] = null;
      this._chopper.destroy();
      this._agent.destroy();
      cb(err);
    };
    Client.prototype._getBackoffDelay = function(isErr) {
      let reconnectCount = this._backoffReconnectCount;
      if (isErr && !isLambdaExecutionEnvironment) {
        this._backoffReconnectCount++;
      } else {
        this._backoffReconnectCount = 0;
        reconnectCount = 0;
      }
      const delayS = Math.pow(Math.min(reconnectCount, 6), 2);
      const jitterS = delayS * (0.2 * Math.random() - 0.1);
      const delayMs = (delayS + jitterS) * 1e3;
      return delayMs;
    };
    function getChoppedStreamHandler(client, onerror) {
      return function makeIntakeRequest(gzipStream, next) {
        const reqId = crypto2.randomBytes(16).toString("hex");
        const log = client._log.child({ reqId });
        const startTime = process.hrtime();
        const timeline = [];
        let bytesWritten = 0;
        let intakeRes;
        let intakeReqSocket = null;
        let intakeResTimer = null;
        let intakeRequestGracefulExitCalled = false;
        const intakeResTimeout = client._conf.intakeResTimeout;
        const intakeResTimeoutOnEnd = client._conf.intakeResTimeoutOnEnd;
        client._activeIntakeReq = true;
        let concluded = false;
        const completedFromPart = {
          gzipStream: false,
          intakeReq: false,
          intakeRes: false
        };
        let numToComplete = Object.keys(completedFromPart).length;
        const completePart = (part, err) => {
          log.trace({ err, concluded }, "completePart %s", part);
          timeline.push([
            deltaMs(startTime),
            `completePart ${part}`,
            err && err.message
          ]);
          assert(part in completedFromPart, `'${part}' is in completedFromPart`);
          if (concluded) {
            return;
          }
          let allPartsCompleted = false;
          if (!completedFromPart[part]) {
            completedFromPart[part] = true;
            numToComplete--;
            if (numToComplete === 0) {
              allPartsCompleted = true;
            }
          }
          if (!err && !allPartsCompleted) {
            return;
          }
          concluded = true;
          if (err) {
            destroyStream(gzipStream);
            intakeReq.destroy();
            if (intakeResTimer) {
              log.trace("cancel intakeResTimer");
              clearTimeout(intakeResTimer);
              intakeResTimer = null;
            }
          }
          client._intakeRequestGracefulExitFn = null;
          client.sent = client._numEventsEnqueued;
          client._activeIntakeReq = false;
          const backoffDelayMs = client._getBackoffDelay(!!err);
          if (err) {
            log.trace(
              { timeline, bytesWritten, backoffDelayMs, err },
              "conclude intake request: error"
            );
            onerror(err);
          } else {
            log.trace(
              { timeline, bytesWritten, backoffDelayMs },
              "conclude intake request: success"
            );
          }
          if (client._onIntakeReqConcluded) {
            client._onIntakeReqConcluded();
            client._onIntakeReqConcluded = null;
          }
          if (backoffDelayMs > 0) {
            setTimeout(next, backoffDelayMs).unref();
          } else {
            setImmediate(next);
          }
        };
        client._intakeRequestGracefulExitFn = () => {
          intakeRequestGracefulExitCalled = true;
          if (intakeReqSocket) {
            log.trace("_intakeRequestGracefulExitFn: re-ref intakeReqSocket");
            intakeReqSocket.ref();
          }
          if (intakeResTimer) {
            log.trace(
              "_intakeRequestGracefulExitFn: reset intakeResTimer to short timeout"
            );
            clearTimeout(intakeResTimer);
            intakeResTimer = setTimeout(() => {
              completePart(
                "intakeRes",
                new Error(
                  `intake response timeout: APM server did not respond within ${intakeResTimeoutOnEnd / 1e3}s of graceful exit signal`
                )
              );
            }, intakeResTimeoutOnEnd).unref();
          }
        };
        const intakeReq = client._transportRequest(client._conf.requestIntake);
        if (Number.isFinite(client._conf.serverTimeout)) {
          intakeReq.setTimeout(client._conf.serverTimeout);
        }
        log.trace("intake request start");
        intakeReq.on("timeout", () => {
          log.trace('intakeReq "timeout"');
          intakeReq.destroy(
            new Error(
              `APM Server response timeout (${client._conf.serverTimeout}ms)`
            )
          );
        });
        intakeReq.on("socket", function(socket) {
          intakeReqSocket = socket;
          if (!isLambdaExecutionEnvironment && !intakeRequestGracefulExitCalled) {
            log.trace('intakeReq "socket": unref it');
            intakeReqSocket.unref();
          }
        });
        intakeReq.on("response", (intakeRes_) => {
          intakeRes = intakeRes_;
          log.trace(
            { statusCode: intakeRes.statusCode, reqFinished: intakeReq.finished },
            'intakeReq "response"'
          );
          let err;
          const chunks = [];
          if (!intakeReq.finished) {
            if (intakeRes.statusCode >= 200 && intakeRes.statusCode < 300) {
              err = new Error(
                `premature apm-server response with statusCode=${intakeRes.statusCode}`
              );
            }
            gzipStream.pause();
          }
          intakeRes.on("error", (intakeResErr) => {
            intakeResErr = wrapError(intakeResErr, "intake response error event");
            completePart("intakeRes", intakeResErr);
          });
          intakeRes.on("data", (chunk) => {
            chunks.push(chunk);
          });
          intakeRes.on("end", () => {
            log.trace('intakeRes "end"');
            if (intakeResTimer) {
              clearTimeout(intakeResTimer);
              intakeResTimer = null;
            }
            if (intakeRes.statusCode < 200 || intakeRes.statusCode > 299) {
              err = processIntakeErrorResponse(intakeRes, Buffer.concat(chunks));
            }
            completePart("intakeRes", err);
          });
        });
        intakeReq.on("finish", () => {
          log.trace('intakeReq "finish"');
          completePart("intakeReq");
        });
        intakeReq.on("error", (err) => {
          log.trace('intakeReq "error"');
          completePart("intakeReq", err);
        });
        gzipStream.on("data", (chunk) => {
          bytesWritten += chunk.length;
        });
        gzipStream.on("error", (gzipErr) => {
          log.trace('gzipStream "error"');
          gzipErr = wrapError(gzipErr, "gzip stream error");
          completePart("gzipStream", gzipErr);
        });
        gzipStream.on("finish", () => {
          log.trace('gzipStream "finish"');
          if (!completedFromPart.intakeReq && !completedFromPart.intakeRes) {
            const timeout = client._writableState.ending || intakeRequestGracefulExitCalled ? intakeResTimeoutOnEnd : intakeResTimeout;
            log.trace({ timeout }, "start intakeResTimer");
            intakeResTimer = setTimeout(() => {
              completePart(
                "intakeRes",
                new Error(
                  `intake response timeout: APM server did not respond within ${timeout / 1e3}s of gzip stream finish`
                )
              );
            }, timeout).unref();
          }
        });
        gzipStream.on("end", () => {
          log.trace('gzipStream "end"');
          completePart("gzipStream");
        });
        if (client._conf.payloadLogFile) {
          const payloadLogStream = fs.createWriteStream(
            client._conf.payloadLogFile,
            { flags: "a" }
          );
          gzipStream.pipe(zlib.createGunzip()).pipe(payloadLogStream);
        }
        assert(client._encodedMetadata, "client._encodedMetadata is set");
        gzipStream.write(client._encodedMetadata);
        gzipStream.pipe(intakeReq);
      };
    }
    Client.prototype.supportsKeepingUnsampledTransaction = function() {
      if (!this._apmServerVersion) {
        return true;
      } else {
        return this._apmServerVersion.major < 8;
      }
    };
    Client.prototype.supportsActivationMethodField = function() {
      if (!this._apmServerVersion) {
        return true;
      } else {
        return semver.gte(this._apmServerVersion, "8.7.1");
      }
    };
    Client.prototype.supportsConfiguredAndDetectedHostname = function() {
      if (!this._apmServerVersion) {
        return true;
      } else {
        return semver.gte(this._apmServerVersion, "7.4.0");
      }
    };
    Client.prototype._signalLambdaEnd = function(cb) {
      this._log.trace("_signalLambdaEnd start");
      const startTime = performance2.now();
      const finish = (errOrErrMsg) => {
        const durationMs = performance2.now() - startTime;
        if (errOrErrMsg) {
          this._log.error(
            { err: errOrErrMsg, durationMs },
            "_signalLambdaEnd error"
          );
        } else {
          this._log.trace({ durationMs }, "_signalLambdaEnd success");
        }
        cb();
      };
      const TIMEOUT_MS = 5e3;
      const req = this._transportRequest(
        this._conf.requestSignalLambdaEnd,
        (res) => {
          res.on("error", (err) => {
            res.destroy(err);
          });
          res.resume();
          if (res.statusCode !== 202) {
            finish(`unexpected response status code: ${res.statusCode}`);
            return;
          }
          res.on("end", function() {
            finish();
          });
        }
      );
      req.setTimeout(TIMEOUT_MS);
      req.on("timeout", () => {
        req.destroy(
          new Error(`timeout (${TIMEOUT_MS}ms) signaling Lambda invocation done`)
        );
      });
      req.on("error", (err) => {
        finish(err);
      });
      req.end();
    };
    Client.prototype._fetchApmServerVersion = function() {
      const setVerUnknownAndNotify = (errmsg) => {
        this._apmServerVersion = null;
        this._resetEncodedMetadata();
        if (isLambdaExecutionEnvironment) {
          this._log.debug("verfetch: " + errmsg);
        } else {
          this.emit("request-error", new Error(errmsg));
        }
      };
      const headers = getHeaders(this._conf);
      const reqOpts = getBasicRequestOptions("GET", "/", headers, this._conf);
      reqOpts.timeout = 3e4;
      const req = this._transportGet(reqOpts, (res) => {
        res.on("error", (err) => {
          res.destroy(err);
        });
        if (res.statusCode !== 200) {
          res.resume();
          setVerUnknownAndNotify(
            `unexpected status from APM Server information endpoint: ${res.statusCode}`
          );
          return;
        }
        const chunks = [];
        res.on("data", (chunk) => {
          chunks.push(chunk);
        });
        res.on("end", () => {
          if (chunks.length === 0) {
            setVerUnknownAndNotify(
              'APM Server information endpoint returned no body, often this indicates authentication ("apiKey" or "secretToken") is incorrect'
            );
            return;
          }
          let serverInfo;
          try {
            serverInfo = JSON.parse(Buffer.concat(chunks));
          } catch (parseErr) {
            setVerUnknownAndNotify(
              `could not parse APM Server information endpoint body: ${parseErr.message}`
            );
            return;
          }
          if (serverInfo) {
            const verStr = serverInfo.ok ? serverInfo.ok.version : serverInfo.version;
            try {
              this._apmServerVersion = new semver.SemVer(verStr);
            } catch (verErr) {
              setVerUnknownAndNotify(
                `could not parse APM Server version "${verStr}": ${verErr.message}`
              );
              return;
            }
            this._resetEncodedMetadata();
            this._log.debug(
              { apmServerVersion: verStr },
              "fetched APM Server version"
            );
          } else {
            setVerUnknownAndNotify(
              `could not determine APM Server version from information endpoint body: ${JSON.stringify(
                serverInfo
              )}`
            );
          }
        });
      });
      req.on("socket", (socket) => {
        socket.unref();
      });
      req.on("timeout", () => {
        this._log.trace("_fetchApmServerVersion timeout");
        req.destroy(
          new Error(`timeout (${reqOpts.timeout}ms) fetching APM Server version`)
        );
      });
      req.on("error", (err) => {
        setVerUnknownAndNotify(`error fetching APM Server version: ${err.message}`);
      });
    };
    Client.prototype._fetchAndEncodeMetadata = function(cb) {
      assert(
        this._conf.cloudMetadataFetcher,
        "_fetchAndEncodeMetadata should not be called without a configured cloudMetadataFetcher"
      );
      this._conf.cloudMetadataFetcher.getCloudMetadata((err, cloudMetadata) => {
        if (err) {
          this._log.trace("getCloudMetadata err: %s", err);
        } else if (cloudMetadata) {
          this._cloudMetadata = cloudMetadata;
        }
        this._resetEncodedMetadata();
        cb();
      });
    };
    function getIntakeRequestOptions(opts, agent) {
      const headers = getHeaders(opts);
      headers["Content-Type"] = "application/x-ndjson";
      headers["Content-Encoding"] = "gzip";
      return getBasicRequestOptions(
        "POST",
        "/intake/v2/events",
        headers,
        opts,
        agent
      );
    }
    function getSignalLambdaEndRequestOptions(opts, agent) {
      const headers = getHeaders(opts);
      headers["Content-Length"] = 0;
      return getBasicRequestOptions(
        "POST",
        "/intake/v2/events?flushed=true",
        headers,
        opts,
        agent
      );
    }
    function getRegisterTransactionRequestOptions(opts, agent) {
      const headers = getHeaders(opts);
      headers["Content-Type"] = "application/vnd.elastic.apm.transaction+ndjson";
      return getBasicRequestOptions(
        "POST",
        "/register/transaction",
        headers,
        opts,
        agent
      );
    }
    function getConfigRequestOptions(opts, agent) {
      const path = "/config/v1/agents?" + querystring.stringify({
        "service.name": opts.serviceName,
        "service.environment": opts.environment
      });
      const headers = getHeaders(opts);
      return getBasicRequestOptions("GET", path, headers, opts, agent);
    }
    function getBasicRequestOptions(method, defaultPath, headers, opts, agent) {
      return {
        agent,
        rejectUnauthorized: opts.rejectUnauthorized !== false,
        ca: opts.serverCaCert,
        hostname: opts.serverUrl.hostname,
        port: opts.serverUrl.port,
        method,
        path: opts.serverUrl.pathname === "/" ? defaultPath : opts.serverUrl.pathname + defaultPath,
        headers
      };
    }
    function getHeaders(opts) {
      const headers = {};
      if (opts.secretToken) headers.Authorization = "Bearer " + opts.secretToken;
      if (opts.apiKey) headers.Authorization = "ApiKey " + opts.apiKey;
      headers.Accept = "application/json";
      headers["User-Agent"] = opts.userAgent;
      return Object.assign(headers, opts.headers);
    }
    function metadataFromConf(opts, client) {
      var payload = {
        service: {
          name: opts.serviceName,
          environment: opts.environment,
          runtime: {
            name: process.release.name,
            version: process.versions.node
          },
          language: {
            name: "javascript"
          },
          agent: {
            name: opts.agentName,
            version: opts.agentVersion
          },
          framework: void 0,
          version: void 0,
          node: void 0
        },
        process: {
          pid: process.pid,
          ppid: process.ppid,
          title: process.title,
          argv: process.argv
        },
        system: {
          architecture: process.arch,
          platform: process.platform,
          container: void 0,
          kubernetes: void 0
        },
        labels: opts.globalLabels
      };
      if (client.supportsConfiguredAndDetectedHostname()) {
        payload.system.detected_hostname = opts.detectedHostname;
        if (opts.configuredHostname) {
          payload.system.configured_hostname = opts.configuredHostname;
        }
      } else {
        payload.system.hostname = opts.configuredHostname || opts.detectedHostname;
      }
      if (opts.agentActivationMethod && client.supportsActivationMethodField()) {
        payload.service.agent.activation_method = opts.agentActivationMethod;
      }
      if (opts.serviceNodeName) {
        payload.service.node = {
          configured_name: opts.serviceNodeName
        };
      }
      if (opts.serviceVersion) payload.service.version = opts.serviceVersion;
      if (opts.frameworkName || opts.frameworkVersion) {
        payload.service.framework = {
          name: opts.frameworkName,
          version: opts.frameworkVersion
        };
      }
      if (opts.containerId) {
        payload.system.container = {
          id: opts.containerId
        };
      }
      if (opts.kubernetesNodeName || opts.kubernetesNamespace || opts.kubernetesPodName || opts.kubernetesPodUID) {
        payload.system.kubernetes = {
          namespace: opts.kubernetesNamespace,
          node: opts.kubernetesNodeName ? { name: opts.kubernetesNodeName } : void 0,
          pod: opts.kubernetesPodName || opts.kubernetesPodUID ? { name: opts.kubernetesPodName, uid: opts.kubernetesPodUID } : void 0
        };
      }
      return payload;
    }
    function destroyStream(stream) {
      if (stream instanceof zlib.Gzip || stream instanceof zlib.Gunzip || stream instanceof zlib.Deflate || stream instanceof zlib.DeflateRaw || stream instanceof zlib.Inflate || stream instanceof zlib.InflateRaw || stream instanceof zlib.Unzip) {
        if (typeof stream.destroy === "function") {
          if (stream._handle && typeof stream._handle.close === "function") {
            stream._handle.close();
            stream._handle = null;
          }
          stream.destroy();
        } else if (typeof stream.close === "function") {
          stream.close();
        }
      } else {
        if (typeof stream.destroy === "function") stream.destroy();
        else if (typeof stream.emit === "function") stream.emit("close");
      }
    }
    function oneOf(value, list) {
      return list.indexOf(value) >= 0;
    }
    function normalizeGlobalLabels(labels) {
      if (!labels) return;
      const result = {};
      for (const key of Object.keys(labels)) {
        const value = labels[key];
        result[key] = oneOf(typeof value, ["string", "number", "boolean"]) ? value : value.toString();
      }
      return result;
    }
    function getMaxAge(res) {
      const header = res.headers["cache-control"];
      if (!header) {
        return void 0;
      }
      const match = header.match(/max-age=(\d+)/i);
      if (!match) {
        return void 0;
      }
      return parseInt(match[1], 10);
    }
    function wrapError(err, msg) {
      err.message = msg + ": " + err.message;
      return err;
    }
    function processIntakeErrorResponse(res, buf) {
      const err = new Error("Unexpected APM Server response");
      err.code = res.statusCode;
      if (buf.length > 0) {
        const body = buf.toString("utf8");
        const contentType = res.headers["content-type"];
        if (contentType && contentType.startsWith("application/json")) {
          try {
            const data = JSON.parse(body);
            err.accepted = data.accepted;
            err.errors = data.errors;
            if (!err.errors) err.response = body;
          } catch (e) {
            err.response = body;
          }
        } else {
          err.response = body;
        }
      }
      return err;
    }
    function processConfigErrorResponse(res, buf, err) {
      const errMsg = "Unexpected APM Server response when polling config";
      if (!err) {
        err = new Error(errMsg);
      } else {
        err.message = errMsg + ": " + err.message;
      }
      err.code = res.statusCode;
      if (buf && buf.length > 0) {
        const body = buf.toString("utf8");
        const contentType = res.headers["content-type"];
        if (contentType && contentType.startsWith("application/json")) {
          try {
            const response = JSON.parse(body);
            if (typeof response === "string") {
              err.response = response;
            } else if (typeof response === "object" && response !== null && typeof response.error === "string") {
              err.response = response.error;
            } else {
              err.response = body;
            }
          } catch (e) {
            err.response = body;
          }
        } else {
          err.response = body;
        }
      }
      return err;
    }
    function deltaMs(t) {
      const d = process.hrtime(t);
      return d[0] * 1e3 + d[1] / 1e6;
    }
    function metadataMergeDeep(target, source) {
      const isObject = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
      if (!isObject(target) || !isObject(source)) {
        return source;
      }
      Object.keys(source).forEach((key) => {
        const targetValue = target[key];
        const sourceValue = source[key];
        if (isObject(targetValue) && isObject(sourceValue)) {
          target[key] = metadataMergeDeep(
            Object.assign({}, targetValue),
            sourceValue
          );
        } else {
          target[key] = sourceValue;
        }
      });
      return target;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
  }
});

// node_modules/elastic-apm-node/lib/apm-client/apm-client.js
var require_apm_client = __commonJS({
  "node_modules/elastic-apm-node/lib/apm-client/apm-client.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var version = require_package2().version;
    var { INTAKE_STRING_MAX_SIZE } = require_constants2();
    var { CENTRAL_CONFIG_OPTS } = require_schema();
    var { normalize } = require_config();
    var { CloudMetadata } = require_cloud_metadata();
    var { isLambdaExecutionEnvironment } = require_lambda();
    var logging = require_logging();
    var { HttpApmClient } = require_http_apm_client();
    var { NoopApmClient } = require_noop_apm_client();
    var {
      isAzureFunctionsEnvironment,
      getAzureFunctionsExtraMetadata
    } = require_azure_functions();
    function createApmClient(config, agent) {
      if (config.disableSend || config.contextPropagationOnly) {
        return new NoopApmClient();
      } else if (typeof config.transport === "function") {
        return config.transport(config, agent);
      }
      const client = new HttpApmClient(getHttpClientConfig(config, agent));
      client.on("config", (remoteConf) => {
        agent.logger.debug({ remoteConf }, "central config received");
        try {
          const conf = {};
          const unknown = [];
          for (const [key, value] of Object.entries(remoteConf)) {
            const newKey = CENTRAL_CONFIG_OPTS[key];
            if (newKey) {
              conf[newKey] = value;
            } else {
              unknown.push(key);
            }
          }
          if (unknown.length > 0) {
            agent.logger.warn(
              `Central config warning: unsupported config names: ${unknown.join(
                ", "
              )}`
            );
          }
          if (Object.keys(conf).length > 0) {
            normalize(conf, agent.logger);
            for (const [key, value] of Object.entries(conf)) {
              const oldValue = agent._conf[key];
              agent._conf[key] = value;
              if (key === "logLevel" && value !== oldValue && !logging.isLoggerCustom(agent.logger)) {
                logging.setLogLevel(agent.logger, value);
                agent.logger.info(
                  `Central config success: updated logger with new logLevel: ${value}`
                );
              }
              agent.logger.info(`Central config success: updated ${key}: ${value}`);
            }
          }
        } catch (err) {
          agent.logger.error(
            { remoteConf, err },
            "Central config error: exception while applying changes"
          );
        }
      });
      client.on("error", (err) => {
        agent.logger.error("APM Server transport error: %s", err.stack);
      });
      client.on("request-error", (err) => {
        const haveAccepted = Number.isFinite(err.accepted);
        const haveErrors = Array.isArray(err.errors);
        let msg;
        if (err.code === 404) {
          msg = `APM Server responded with "404 Not Found". This might be because you're running an incompatible version of the APM Server. This agent only supports APM Server v6.5 and above. If you're using an older version of the APM Server, please downgrade this agent to version 1.x or upgrade the APM Server`;
        } else if (err.code) {
          msg = `APM Server transport error (${err.code}): ${err.message}`;
        } else {
          msg = `APM Server transport error: ${err.message}`;
        }
        if (haveAccepted || haveErrors) {
          if (haveAccepted)
            msg += `
APM Server accepted ${err.accepted} events in the last request`;
          if (haveErrors) {
            for (const error of err.errors) {
              msg += `
Error: ${error.message}`;
              if (error.document) msg += `
  Document: ${error.document}`;
            }
          }
        } else if (err.response) {
          msg += `
${err.response}`;
        }
        agent.logger.error(msg);
      });
      return client;
    }
    function getHttpClientConfig(conf, agent) {
      let clientLogger = null;
      if (!logging.isLoggerCustom(agent.logger)) {
        clientLogger = agent.logger.child({ "event.module": "apmclient" });
      }
      const isLambda = isLambdaExecutionEnvironment();
      const clientConfig = {
        agentName: "nodejs",
        agentVersion: version,
        agentActivationMethod: agent._agentActivationMethod,
        serviceName: conf.serviceName,
        serviceVersion: conf.serviceVersion,
        frameworkName: conf.frameworkName,
        frameworkVersion: conf.frameworkVersion,
        globalLabels: maybePairsToObject(conf.globalLabels),
        configuredHostname: conf.hostname,
        environment: conf.environment,
        // Sanitize conf
        truncateKeywordsAt: INTAKE_STRING_MAX_SIZE,
        truncateLongFieldsAt: conf.longFieldMaxLength,
        // truncateErrorMessagesAt: see below
        // HTTP conf
        secretToken: conf.secretToken,
        apiKey: conf.apiKey,
        userAgent: userAgentFromConf(conf),
        serverUrl: conf.serverUrl,
        serverCaCert: loadServerCaCertFile(conf.serverCaCertFile),
        rejectUnauthorized: conf.verifyServerCert,
        serverTimeout: conf.serverTimeout * 1e3,
        headers: maybePairsToObject(conf.apmClientHeaders),
        // APM Agent Configuration via Kibana:
        centralConfig: conf.centralConfig,
        // Streaming conf
        size: conf.apiRequestSize,
        time: conf.apiRequestTime * 1e3,
        maxQueueSize: conf.maxQueueSize,
        // Debugging/testing options
        logger: clientLogger,
        payloadLogFile: conf.payloadLogFile,
        apmServerVersion: conf.apmServerVersion,
        // Container conf
        containerId: conf.containerId,
        kubernetesNodeName: conf.kubernetesNodeName,
        kubernetesNamespace: conf.kubernetesNamespace,
        kubernetesPodName: conf.kubernetesPodName,
        kubernetesPodUID: conf.kubernetesPodUID
      };
      if (conf.serviceNodeName) {
        if (isLambda) {
          agent.logger.warn(
            { serviceNodeName: conf.serviceNodeName },
            'ignoring "serviceNodeName" config setting in Lambda environment'
          );
        } else if (isAzureFunctionsEnvironment) {
          agent.logger.warn(
            { serviceNodeName: conf.serviceNodeName },
            'ignoring "serviceNodeName" config setting in Azure Functions environment'
          );
        } else {
          clientConfig.serviceNodeName = conf.serviceNodeName;
        }
      }
      if (isLambda) {
        clientConfig.expectExtraMetadata = true;
      } else if (isAzureFunctionsEnvironment) {
        clientConfig.extraMetadata = getAzureFunctionsExtraMetadata();
      } else if (conf.cloudProvider !== "none") {
        clientConfig.cloudMetadataFetcher = new CloudMetadata(
          conf.cloudProvider,
          conf.logger,
          conf.serviceName
        );
      }
      if (conf.errorMessageMaxLength !== void 0) {
        clientConfig.truncateErrorMessagesAt = conf.errorMessageMaxLength;
      }
      return clientConfig;
    }
    function userAgentFromConf(conf) {
      let userAgent = `apm-agent-nodejs/${version}`;
      const commentBadChar = /[^\t \x21-\x27\x2a-\x5b\x5d-\x7e\x80-\xff]/g;
      const commentParts = [];
      if (conf.serviceName) {
        commentParts.push(conf.serviceName);
      }
      if (conf.serviceVersion) {
        commentParts.push(conf.serviceVersion.replace(commentBadChar, "_"));
      }
      if (commentParts.length > 0) {
        userAgent += ` (${commentParts.join(" ")})`;
      }
      return userAgent;
    }
    function loadServerCaCertFile(serverCaCertFile, logger) {
      if (serverCaCertFile) {
        try {
          return fs.readFileSync(serverCaCertFile);
        } catch (err) {
          logger.error(
            "Elastic APM initialization error: Can't read server CA cert file %s (%s)",
            serverCaCertFile,
            err.message
          );
        }
      }
    }
    function maybePairsToObject(pairs) {
      return pairs ? pairsToObject(pairs) : void 0;
    }
    function pairsToObject(pairs) {
      return pairs.reduce((object, [key, value]) => {
        object[key] = value;
        return object;
      }, {});
    }
    module2.exports = {
      createApmClient,
      userAgentFromConf
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/oblog.js
var require_oblog = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/oblog.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      setApiCallLogFn(logFn) {
        module2.exports.apicall = logFn;
      },
      apicall() {
      }
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/opentelemetry-core-mini/internal/validators.js
var require_validators2 = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/opentelemetry-core-mini/internal/validators.js"(exports2) {
    "use strict";
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports2.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports2.validateValue = validateValue2;
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/opentelemetry-core-mini/trace/TraceState.js
var require_TraceState2 = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/opentelemetry-core-mini/trace/TraceState.js"(exports2) {
    "use strict";
    var validators_1 = require_validators2();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceState = TraceState;
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/otelutils.js
var require_otelutils = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/otelutils.js"(exports2, module2) {
    "use strict";
    var otel = (init_esm(), __toCommonJS(esm_exports));
    var semver = require_semver2();
    var timeOrigin = require("perf_hooks").performance.timeOrigin;
    var { TraceState } = require_TraceState2();
    var haveUsablePerformanceNow = semver.satisfies(process.version, ">=8.12.0");
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    function epochMsFromOTelTimeInput(otelTimeInput) {
      if (isTimeInputHrTime(otelTimeInput)) {
        return otelTimeInput[0] * 1e3 + otelTimeInput[1] / 1e6;
      } else if (typeof otelTimeInput === "number") {
        if (haveUsablePerformanceNow && otelTimeInput < timeOrigin) {
          return timeOrigin + otelTimeInput;
        } else {
          return otelTimeInput;
        }
      } else if (otelTimeInput instanceof Date) {
        return otelTimeInput.getTime();
      } else {
        throw TypeError(`Invalid OTel TimeInput: ${otelTimeInput}`);
      }
    }
    function traceparentStrFromOTelSpanContext(spanContext) {
      return `00-${spanContext.traceId}-${spanContext.spanId}-0${Number(
        spanContext.traceFlags || otel.TraceFlags.NONE
      ).toString(16)}`;
    }
    function otelSpanContextFromTraceContext(traceContext) {
      const traceparent = traceContext.traceparent;
      const otelSpanContext = {
        traceId: traceparent.traceId,
        spanId: traceparent.id,
        // `traceparent.flags` is a two-char hex string. `traceFlags` is a number.
        // This conversion assumes `traceparent.flags` are valid.
        traceFlags: parseInt(traceparent.flags, 16)
      };
      const traceStateStr = traceContext.toTraceStateString();
      if (traceStateStr) {
        otelSpanContext.traceState = new TraceState(traceStateStr);
      }
      return otelSpanContext;
    }
    module2.exports = {
      epochMsFromOTelTimeInput,
      otelSpanContextFromTraceContext,
      traceparentStrFromOTelSpanContext
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelBridgeNonRecordingSpan.js
var require_OTelBridgeNonRecordingSpan = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelBridgeNonRecordingSpan.js"(exports2, module2) {
    "use strict";
    var otel = (init_esm(), __toCommonJS(esm_exports));
    var agent = require_elastic_apm_node();
    var { OUTCOME_UNKNOWN } = require_constants2();
    var { traceparentStrFromOTelSpanContext } = require_otelutils();
    var OTelBridgeNonRecordingSpan = class {
      constructor(otelNonRecordingSpan) {
        this._spanContext = otelNonRecordingSpan.spanContext();
        this.name = "";
        this.type = null;
        this.subtype = null;
        this.action = null;
        this.outcome = OUTCOME_UNKNOWN;
        this.ended = false;
        this.result = "";
      }
      get id() {
        return this._spanContext.spanId;
      }
      get traceparent() {
        return traceparentStrFromOTelSpanContext(this._spanContext);
      }
      get ids() {
        return {
          "trace.id": this._spanContext.traceId,
          "transaction.id": this._spanContext.spanId
        };
      }
      setType() {
      }
      setLabel(_key, _value, _stringify) {
        return false;
      }
      addLabels(_labels, _stringify) {
        return false;
      }
      setOutcome(_outcome) {
      }
      startSpan() {
        return null;
      }
      ensureParentId() {
        return "";
      }
      // ---- private class Transaction API
      // Only the parts of that API that are used on instances of this class.
      createSpan() {
        return null;
      }
      // GenericSpan#propagateTraceContextHeaders()
      //
      // Implementation adapted from OTel's W3CTraceContextPropagator#inject().
      propagateTraceContextHeaders(carrier, setter) {
        if (!carrier || !setter) {
          return;
        }
        if (!this._spanContext || !otel.isSpanContextValid(this._spanContext)) {
          return;
        }
        const traceparentStr = traceparentStrFromOTelSpanContext(this._spanContext);
        setter(carrier, "traceparent", traceparentStr);
        if (agent._conf.useElasticTraceparentHeader) {
          setter(carrier, "elastic-apm-traceparent", traceparentStr);
        }
        if (this._spanContext.traceState) {
          setter(carrier, "tracestate", this._spanContext.traceState.serialize());
        }
      }
      // ---- OTel interface Span
      // Implementation adapted from opentelemetry-js-api/src/trace/NonRecordingSpan.ts
      spanContext() {
        return this._spanContext;
      }
      setAttribute(_key, _value) {
        return this;
      }
      setAttributes(_attributes) {
        return this;
      }
      addEvent(_name, _attributes) {
        return this;
      }
      setStatus(_status) {
        return this;
      }
      updateName(_name) {
        return this;
      }
      addLink(_link) {
        return this;
      }
      addLinks(_links) {
        return this;
      }
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return false;
      }
      recordException(_exception, _time) {
      }
    };
    module2.exports = {
      OTelBridgeNonRecordingSpan
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelSpan.js
var require_OTelSpan = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelSpan.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var URL2 = require("url").URL;
    var otel = (init_esm(), __toCommonJS(esm_exports));
    var GenericSpan = require_generic_span();
    var oblog = require_oblog();
    var {
      otelSpanContextFromTraceContext,
      epochMsFromOTelTimeInput
    } = require_otelutils();
    var {
      RESULT_SUCCESS,
      OUTCOME_UNKNOWN,
      OUTCOME_SUCCESS,
      RESULT_FAILURE,
      OUTCOME_FAILURE
    } = require_constants2();
    var Span = require_span();
    var Transaction = require_transaction();
    function isHomogeneousArrayOfStrNumBool(arr) {
      const len = arr.length;
      let elemType = null;
      for (let i = 0; i < len; i++) {
        const elem = arr[i];
        if (elem === void 0 || elem === null) {
          continue;
        }
        if (!elemType) {
          elemType = typeof elem;
          if (!(elemType === "string" || elemType === "number" || elemType === "boolean")) {
            return false;
          }
        } else if (typeof elem !== elemType) {
          return false;
        }
      }
      return true;
    }
    function maybeSetOTelAttr(attrs, k, v) {
      if (Array.isArray(v)) {
        if (isHomogeneousArrayOfStrNumBool(v)) {
          attrs[k] = v.slice();
        }
      } else {
        switch (typeof v) {
          case "number":
          case "boolean":
            attrs[k] = v;
            break;
          case "string":
            attrs[k] = v;
            break;
        }
      }
    }
    var OTelSpan = class {
      constructor(span) {
        assert(span instanceof GenericSpan);
        this._span = span;
        this._spanContext = null;
      }
      toString() {
        return `OTelSpan<${this._span.constructor.name}<${this._span.id}, "${this._span.name}">>`;
      }
      // ---- OTel interface Span
      // https://github.com/open-telemetry/opentelemetry-js-api/blob/v1.0.4/src/trace/span.ts
      spanContext() {
        oblog.apicall("%s.spanContext()", this);
        if (!this._spanContext) {
          this._spanContext = otelSpanContextFromTraceContext(this._span._context);
        }
        return this._spanContext;
      }
      setAttribute(key, value) {
        if (this._span.ended || !key || typeof key !== "string") {
          return this;
        }
        const attrs = this._span._getOTelAttributes();
        maybeSetOTelAttr(attrs, key, value);
        return this;
      }
      setAttributes(attributes) {
        if (this._span.ended || !attributes || typeof attributes !== "object") {
          return this;
        }
        const attrs = this._span._getOTelAttributes();
        for (const k in attributes) {
          if (k.length === 0) continue;
          maybeSetOTelAttr(attrs, k, attributes[k]);
        }
        return this;
      }
      // Span events are not currently supported.
      addEvent(name, attributesOrStartTime, startTime) {
        return this;
      }
      setStatus(otelSpanStatus) {
        if (this._span.ended) {
          return this;
        }
        switch (otelSpanStatus) {
          case otel.SpanStatusCode.ERROR:
            this._span.setOutcome(OUTCOME_FAILURE);
            break;
          case otel.SpanStatusCode.OK:
            this._span.setOutcome(OUTCOME_SUCCESS);
            break;
          case otel.SpanStatusCode.UNSET:
            this._span.setOutcome(OUTCOME_UNKNOWN);
            break;
        }
        if (this._span instanceof Transaction) {
          switch (otelSpanStatus) {
            case otel.SpanStatusCode.ERROR:
              this._span.result = RESULT_FAILURE;
              break;
            case otel.SpanStatusCode.OK:
              this._span.result = RESULT_SUCCESS;
              break;
          }
        }
        return this;
      }
      updateName(name) {
        if (this._span.ended) {
          return this;
        }
        this._span.name = name;
        return this;
      }
      addLink(link) {
        this._span.addLink(link);
        return this;
      }
      addLinks(links) {
        this._span.addLinks(links);
        return this;
      }
      end(otelEndTime) {
        oblog.apicall("%s.end(endTime=%s)", this, otelEndTime);
        const endTime = otelEndTime === void 0 ? void 0 : epochMsFromOTelTimeInput(otelEndTime);
        if (this._span instanceof Transaction) {
          this._transCompatMapping();
          this._span.end(void 0, endTime);
        } else {
          assert(this._span instanceof Span);
          this._spanCompatMapping();
          this._span.end(endTime);
        }
      }
      // https://github.com/elastic/apm/blob/main/specs/agents/tracing-api-otel.md#compatibility-mapping
      _transCompatMapping() {
        const attrs = this._span._otelAttributes;
        let type = "unknown";
        if (!attrs) {
          this._span.type = type;
          return;
        }
        const otelKind = otel.SpanKind[this._span._otelKind];
        const isRpc = attrs["rpc.system"] !== void 0;
        const isHttp = attrs["http.url"] !== void 0 || attrs["http.scheme"] !== void 0;
        const isMessaging = attrs["messaging.system"] !== void 0;
        if (otelKind === otel.SpanKind.SERVER && (isRpc || isHttp)) {
          type = "request";
        } else if (otelKind === otel.SpanKind.CONSUMER && isMessaging) {
          type = "messaging";
        } else {
          type = "unknown";
        }
        this._span.type = type;
      }
      // https://github.com/elastic/apm/blob/main/specs/agents/tracing-api-otel.md#compatibility-mapping
      _spanCompatMapping() {
        const attrs = this._span._otelAttributes;
        const otelKind = otel.SpanKind[this._span._otelKind];
        if (!attrs) {
          if (otelKind === otel.SpanKind.INTERNAL) {
            this._span.type = "app";
            this._span.subtype = "internal";
          } else {
            this._span.type = "unknown";
          }
          return;
        }
        let type;
        let subtype;
        let serviceTargetType = null;
        let serviceTargetName = null;
        const httpPortFromScheme = function(scheme) {
          if (scheme === "http") {
            return 80;
          } else if (scheme === "https") {
            return 443;
          }
          return -1;
        };
        const parseNetName = function(url) {
          let u;
          try {
            u = new URL2(url);
          } catch (_err) {
            return void 0;
          }
          if (u.port !== "") {
            return u.host;
          } else {
            var port = httpPortFromScheme(
              u.protocol.substring(0, u.protocol.length - 1)
            );
            return port > 0 ? u.hostname + ":" + port : u.hostname;
          }
        };
        let netPort = attrs["net.peer.port"] || -1;
        const netPeer = attrs["net.peer.name"] || attrs["net.peer.ip"];
        let netName = netPeer;
        if (netName && netPort > 0) {
          netName += ":" + netPort;
        }
        if (attrs["db.system"]) {
          type = "db";
          subtype = attrs["db.system"];
          serviceTargetType = subtype;
          serviceTargetName = attrs["db.name"] || null;
        } else if (attrs["messaging.system"]) {
          type = "messaging";
          subtype = attrs["messaging.system"];
          if (!netName && attrs["messaging.url"]) {
            netName = parseNetName(attrs["messaging.url"]);
          }
          serviceTargetType = subtype;
          serviceTargetName = attrs["messaging.destination"] || null;
        } else if (attrs["rpc.system"]) {
          type = "external";
          subtype = attrs["rpc.system"];
          serviceTargetType = subtype;
          serviceTargetName = netName || attrs["rpc.service"] || null;
        } else if (attrs["http.url"] || attrs["http.scheme"]) {
          type = "external";
          subtype = "http";
          serviceTargetType = "http";
          const httpHost = attrs["http.host"] || netPeer;
          if (httpHost) {
            if (netPort < 0) {
              netPort = httpPortFromScheme(attrs["http.scheme"]);
            }
            serviceTargetName = netPort < 0 ? httpHost : httpHost + ":" + netPort;
          } else if (attrs["http.url"]) {
            serviceTargetName = parseNetName(attrs["http.url"]);
          }
        }
        if (type === void 0) {
          if (otelKind === otel.SpanKind.INTERNAL) {
            type = "app";
            subtype = "internal";
          } else {
            type = "unknown";
          }
        }
        this._span.type = type;
        if (subtype) {
          this._span.subtype = subtype;
        }
        if (serviceTargetType || serviceTargetName) {
          this._span.setServiceTarget(serviceTargetType, serviceTargetName);
        }
      }
      isRecording() {
        return !this._span.ended && this._span.sampled;
      }
      recordException(otelException, otelTime) {
        const errOpts = {
          parent: this._span,
          captureAttributes: false,
          skipOutcome: true
        };
        if (otelTime !== void 0) {
          errOpts.timestamp = epochMsFromOTelTimeInput(otelTime);
        }
        this._span._agent.captureError(otelException, errOpts);
      }
    };
    module2.exports = {
      OTelSpan
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelBridgeRunContext.js
var require_OTelBridgeRunContext = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelBridgeRunContext.js"(exports2, module2) {
    "use strict";
    var otel = (init_esm(), __toCommonJS(esm_exports));
    var oblog = require_oblog();
    var { OTelBridgeNonRecordingSpan } = require_OTelBridgeNonRecordingSpan();
    var { OTelSpan } = require_OTelSpan();
    var { RunContext } = require_run_context();
    var Span = require_span();
    var OTEL_CONTEXT_KEY = otel.createContextKey(
      "Elastic APM Context Key OTEL CONTEXT"
    );
    var SPAN_KEY2 = null;
    function fetchSpanKey() {
      const capturingContext = {
        spanKey: null,
        setValue(key, _value) {
          this.spanKey = key;
        }
      };
      const fakeSpan = {};
      otel.trace.setSpan(capturingContext, fakeSpan);
      SPAN_KEY2 = capturingContext.spanKey;
      if (!SPAN_KEY2) {
        throw new Error('could not fetch OTel API "SPAN_KEY"');
      }
    }
    var OTelBridgeRunContext = class extends RunContext {
      setOTelContext(otelContext) {
        let runContext = this.setValue(OTEL_CONTEXT_KEY, otelContext);
        const span = otel.trace.getSpan(otelContext);
        if (span) {
          runContext = runContext.setValue(SPAN_KEY2, span);
        }
        return runContext;
      }
      getValue(key) {
        oblog.apicall("OTelBridgeRunContext.getValue(%o)", key);
        if (key === SPAN_KEY2) {
          const curr = this.currSpan() || this.currTransaction();
          if (!curr) {
            return void 0;
          } else if (curr instanceof OTelBridgeNonRecordingSpan) {
            return curr;
          } else {
            return new OTelSpan(curr);
          }
        }
        const value = super.getValue(key);
        if (value !== void 0) {
          return value;
        } else {
          const otelContext = super.getValue(OTEL_CONTEXT_KEY);
          if (otelContext) {
            return otelContext.getValue(key);
          }
        }
      }
      setValue(key, value) {
        oblog.apicall("OTelBridgeRunContext.setValue(%o, %s)", key, value);
        if (key === SPAN_KEY2) {
          if (value instanceof OTelSpan) {
            if (value._span instanceof Span) {
              return this.enterSpan(value._span);
            } else {
              return this.enterTrans(value._span);
            }
          } else if (typeof value.isRecording === "function" && !value.isRecording()) {
            return this.enterTrans(new OTelBridgeNonRecordingSpan(value));
          }
        }
        return super.setValue(key, value);
      }
      deleteValue(key) {
        oblog.apicall("OTelBridgeRunContext.deleteValue(%o)", key);
        if (key === SPAN_KEY2) {
          return this.leaveTrans();
        }
        return super.deleteValue(key);
      }
    };
    module2.exports = {
      fetchSpanKey,
      OTelBridgeRunContext
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelContextManager.js
var require_OTelContextManager = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelContextManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var oblog = require_oblog();
    var { OTelBridgeRunContext } = require_OTelBridgeRunContext();
    var OTelContextManager = class {
      constructor(agent) {
        this._agent = agent;
        this._ins = agent._instrumentation;
      }
      active() {
        oblog.apicall("OTelContextManager.active()");
        return this._ins.currRunContext();
      }
      _runContextFromOTelContext(otelContext) {
        let runContext;
        if (otelContext instanceof OTelBridgeRunContext) {
          runContext = otelContext;
        } else {
          runContext = this._ins._runCtxMgr.root().setOTelContext(otelContext);
        }
        return runContext;
      }
      with(otelContext, fn, thisArg, ...args) {
        oblog.apicall(
          "OTelContextManager.with(%s<...>, function %s, ...)",
          otelContext.constructor.name,
          fn.name || "<anonymous>"
        );
        const runContext = this._runContextFromOTelContext(otelContext);
        return this._ins._runCtxMgr.with(runContext, fn, thisArg, ...args);
      }
      bind(otelContext, target) {
        oblog.apicall(
          "OTelContextManager.bind(%s, %s type)",
          otelContext,
          typeof target
        );
        if (target instanceof EventEmitter) {
          const runContext = this._runContextFromOTelContext(otelContext);
          return this._ins._runCtxMgr.bindEE(runContext, target);
        }
        if (typeof target === "function") {
          const runContext = this._runContextFromOTelContext(otelContext);
          return this._ins._runCtxMgr.bindFn(runContext, target);
        }
        return target;
      }
      enable() {
        oblog.apicall("OTelContextManager.enable()");
        this._ins._runCtxMgr.enable();
        return this;
      }
      disable() {
        oblog.apicall("OTelContextManager.disable()");
        this._ins._runCtxMgr.disable();
        return this;
      }
    };
    module2.exports = {
      OTelContextManager
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelTracerProvider.js
var require_OTelTracerProvider = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelTracerProvider.js"(exports2, module2) {
    "use strict";
    var oblog = require_oblog();
    var OTelTracerProvider = class {
      // @param {OTelTracer} tracer
      constructor(tracer) {
        this._tracer = tracer;
      }
      getTracer(_name, _version, _options) {
        oblog.apicall("OTelTracerProvider.getTracer(...)");
        return this._tracer;
      }
    };
    module2.exports = {
      OTelTracerProvider
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelTracer.js
var require_OTelTracer = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/OTelTracer.js"(exports2, module2) {
    "use strict";
    var otel = (init_esm(), __toCommonJS(esm_exports));
    var oblog = require_oblog();
    var { OTelBridgeRunContext } = require_OTelBridgeRunContext();
    var { OTelSpan } = require_OTelSpan();
    var Transaction = require_transaction();
    var { OTelBridgeNonRecordingSpan } = require_OTelBridgeNonRecordingSpan();
    var {
      epochMsFromOTelTimeInput,
      otelSpanContextFromTraceContext,
      traceparentStrFromOTelSpanContext
    } = require_otelutils();
    var { OUTCOME_UNKNOWN } = require_constants2();
    var OTelTracer = class {
      constructor(agent) {
        this._agent = agent;
        this._ins = agent._instrumentation;
      }
      /**
       * Starts a new {@link Span}. Start the span without setting it on context.
       *
       * This method do NOT modify the current Context.
       *
       * @param name The name of the span
       * @param [options] SpanOptions used for span creation
       * @param [context] Context to use to extract parent
       * @returns Span The newly created span
       * @example
       *     const span = tracer.startSpan('op');
       *     span.setAttribute('key', 'value');
       *     span.end();
       */
      startSpan(name, otelSpanOptions = {}, otelContext = otel.context.active()) {
        oblog.apicall(
          "OTelTracer.startSpan(name=%s, options=%j, context=%s)",
          name,
          otelSpanOptions,
          otelContext
        );
        let parentGenericSpan;
        let parentOTelSpanContext;
        if (otelSpanOptions.root) {
        } else if (otelContext instanceof OTelBridgeRunContext) {
          parentGenericSpan = otelContext.currSpan() || otelContext.currTransaction();
          if (parentGenericSpan instanceof OTelBridgeNonRecordingSpan) {
            parentOTelSpanContext = parentGenericSpan.spanContext();
            parentGenericSpan = null;
          }
        } else {
          parentOTelSpanContext = otel.trace.getSpanContext(otelContext);
        }
        const createOpts = {};
        if (otelSpanOptions.links) {
          createOpts.links = otelSpanOptions.links.filter(
            (otelLink) => otelLink && otelLink.context && otel.isSpanContextValid(otelLink.context)
          ).map((otelLink) => {
            return {
              context: traceparentStrFromOTelSpanContext(otelLink.context)
            };
          });
        }
        let newTransOrSpan = null;
        if (parentGenericSpan) {
          const trans = parentGenericSpan instanceof Transaction ? parentGenericSpan : parentGenericSpan.transaction;
          createOpts.childOf = parentGenericSpan;
          if (otelSpanOptions.startTime) {
            createOpts.startTime = epochMsFromOTelTimeInput(
              otelSpanOptions.startTime
            );
          }
          if (otelSpanOptions.kind === otel.SpanKind.CLIENT || otelSpanOptions.kind === otel.SpanKind.PRODUCER) {
            createOpts.exitSpan = true;
          }
          newTransOrSpan = trans.createSpan(name, createOpts);
          if (!newTransOrSpan) {
            return otel.trace.wrapSpanContext(
              otelSpanContextFromTraceContext(parentGenericSpan._context)
            );
          }
        } else if (parentOTelSpanContext && otel.isSpanContextValid(parentOTelSpanContext)) {
          createOpts.childOf = traceparentStrFromOTelSpanContext(
            parentOTelSpanContext
          );
          if (parentOTelSpanContext.traceState) {
            createOpts.tracestate = parentOTelSpanContext.traceState.serialize();
          }
          if (otelSpanOptions.startTime !== void 0) {
            createOpts.startTime = epochMsFromOTelTimeInput(
              otelSpanOptions.startTime
            );
          }
          newTransOrSpan = this._ins.createTransaction(name, createOpts);
        } else {
          if (otelSpanOptions.startTime !== void 0) {
            createOpts.startTime = epochMsFromOTelTimeInput(
              otelSpanOptions.startTime
            );
          }
          newTransOrSpan = this._ins.createTransaction(name, createOpts);
        }
        newTransOrSpan._setOTelKind(
          otel.SpanKind[otelSpanOptions.kind || otel.SpanKind.INTERNAL]
        );
        newTransOrSpan.setOutcome(OUTCOME_UNKNOWN);
        const otelSpan = new OTelSpan(newTransOrSpan);
        otelSpan.setAttributes(otelSpanOptions.attributes);
        return otelSpan;
      }
      // startActiveSpan(name[, options[, context]], fn)
      //
      // Interface: https://github.com/open-telemetry/opentelemetry-js-api/blob/main/src/trace/tracer.ts#L41
      // Adapted from: https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-base/src/Tracer.ts
      startActiveSpan(name, otelSpanOptions, otelContext, fn) {
        oblog.apicall(
          "OTelTracer.startActiveSpan(name=%s, options=%j, context=%s, fn)",
          name,
          otelSpanOptions,
          otelContext
        );
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = otelSpanOptions;
          otelSpanOptions = void 0;
          otelContext = void 0;
        } else if (arguments.length === 3) {
          fn = otelContext;
          otelContext = void 0;
        }
        const parentContext = otelContext || otel.context.active();
        const span = this.startSpan(name, otelSpanOptions, parentContext);
        const contextWithSpanSet = otel.trace.setSpan(parentContext, span);
        return otel.context.with(contextWithSpanSet, fn, void 0, span);
      }
    };
    module2.exports = {
      OTelTracer
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/setup.js
var require_setup = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/setup.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var otel = (init_esm(), __toCommonJS(esm_exports));
    var logging = require_logging();
    var { fetchSpanKey } = require_OTelBridgeRunContext();
    var oblog = require_oblog();
    var { OTelContextManager } = require_OTelContextManager();
    var { OTelTracerProvider } = require_OTelTracerProvider();
    var { OTelTracer } = require_OTelTracer();
    function setupOTelBridge(agent) {
      let success;
      const log = logging.isLoggerCustom(agent.logger) ? agent.logger : agent.logger.child({ "event.module": "otelbridge" });
      if (log.isLevelEnabled("trace")) {
        success = otel.diag.setLogger(
          {
            verbose: log.trace.bind(log),
            debug: log.debug.bind(log),
            info: log.info.bind(log),
            warn: log.warn.bind(log),
            error: log.error.bind(log)
          },
          otel.DiagLogLevel.ALL
        );
        if (!success) {
          log.error("could not register OpenTelemetry bridge diag logger");
          return;
        }
      }
      const LOG_OTEL_API_CALLS = false;
      if (LOG_OTEL_API_CALLS) {
        oblog.setApiCallLogFn((...args) => {
          const s = util.format(...args);
          console.log("\x1B[90motelapi:\x1B[39m \x1B[32m" + s + "\x1B[39m");
        });
      }
      success = otel.trace.setGlobalTracerProvider(
        new OTelTracerProvider(new OTelTracer(agent))
      );
      if (!success) {
        log.error("could not register OpenTelemetry bridge TracerProvider");
        return;
      }
      fetchSpanKey();
      success = otel.context.setGlobalContextManager(new OTelContextManager(agent));
      if (!success) {
        log.error("could not register OpenTelemetry bridge ContextManager");
      }
    }
    module2.exports = {
      setupOTelBridge
    };
  }
});

// node_modules/elastic-apm-node/lib/opentelemetry-bridge/index.js
var require_opentelemetry_bridge = __commonJS({
  "node_modules/elastic-apm-node/lib/opentelemetry-bridge/index.js"(exports2, module2) {
    "use strict";
    var { OTelBridgeRunContext } = require_OTelBridgeRunContext();
    var { setupOTelBridge } = require_setup();
    module2.exports = {
      OTelBridgeRunContext,
      setupOTelBridge
    };
  }
});

// node_modules/elastic-apm-node/lib/agent.js
var require_agent2 = __commonJS({
  "node_modules/elastic-apm-node/lib/agent.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var path = require("path");
    var isError = require_util().isError;
    var Filters = require_object_filter_sequence();
    var { agentActivationMethodFromStartStack } = require_activation_method();
    var {
      CAPTURE_ERROR_LOG_STACK_TRACES_ALWAYS,
      CAPTURE_ERROR_LOG_STACK_TRACES_MESSAGES
    } = require_constants2();
    var config = require_config();
    var connect = require_connect();
    var constants = require_constants2();
    var errors = require_errors();
    var { InflightEventSet } = require_InflightEventSet();
    var { Instrumentation } = require_instrumentation();
    var { elasticApmAwsLambda } = require_lambda();
    var Metrics = require_metrics();
    var parsers = require_parsers();
    var symbols = require_symbols();
    var { frameCacheStats, initStackTraceCollection } = require_stacktraces();
    var Span = require_span();
    var Transaction = require_transaction();
    var {
      isOTelMetricsFeatSupported,
      createOTelMeterProvider
    } = require_opentelemetry_metrics();
    var { createApmClient } = require_apm_client();
    var IncomingMessage = http.IncomingMessage;
    var ServerResponse = http.ServerResponse;
    var version = require_package2().version;
    module2.exports = Agent;
    function Agent() {
      this.logger = config.configLogger();
      this._conf = config.initialConfig(this.logger);
      this._httpClient = null;
      this._uncaughtExceptionListener = null;
      this._inflightEvents = new InflightEventSet();
      this._instrumentation = new Instrumentation(this);
      this._metrics = new Metrics(this);
      this._otelMeterProvider = null;
      this._errorFilters = new Filters();
      this._transactionFilters = new Filters();
      this._spanFilters = new Filters();
      this._apmClient = null;
      this.lambda = elasticApmAwsLambda(this);
      this.middleware = { connect: connect.bind(this) };
    }
    Object.defineProperty(Agent.prototype, "currentTransaction", {
      get() {
        return this._instrumentation.currTransaction();
      }
    });
    Object.defineProperty(Agent.prototype, "currentSpan", {
      get() {
        return this._instrumentation.currSpan();
      }
    });
    Object.defineProperty(Agent.prototype, "currentTraceparent", {
      get() {
        const current = this._instrumentation.currSpan() || this._instrumentation.currTransaction();
        return current ? current.traceparent : null;
      }
    });
    Object.defineProperty(Agent.prototype, "currentTraceIds", {
      get() {
        return this._instrumentation.ids();
      }
    });
    Agent.prototype.destroy = async function() {
      if (this._otelMeterProvider) {
        try {
          await this._otelMeterProvider.shutdown({ timeoutMillis: 1e3 });
        } catch (reason) {
          this.logger.warn("failed to shutdown OTel MeterProvider:", reason);
        }
        this._otelMeterProvider = null;
      }
      if (this._apmClient && this._apmClient.destroy) {
        this._apmClient.destroy();
      }
      this._apmClient = null;
      this._errorFilters = new Filters();
      this._transactionFilters = new Filters();
      this._spanFilters = new Filters();
      if (this._uncaughtExceptionListener) {
        process.removeListener(
          "uncaughtException",
          this._uncaughtExceptionListener
        );
      }
      this._metrics.stop();
      this._instrumentation.stop();
      global[symbols.agentInitialized] = null;
      if (this._origStackTraceLimit && Error.stackTraceLimit !== this._origStackTraceLimit) {
        Error.stackTraceLimit = this._origStackTraceLimit;
      }
    };
    Agent.prototype._getStats = function() {
      const stats = {
        frameCache: frameCacheStats
      };
      if (this._instrumentation._runCtxMgr && this._instrumentation._runCtxMgr._runContextFromAsyncId) {
        stats.runContextFromAsyncIdSize = this._instrumentation._runCtxMgr._runContextFromAsyncId.size;
      }
      if (this._apmClient && typeof this._apmClient._getStats === "function") {
        stats.apmclient = this._apmClient._getStats();
      }
      return stats;
    };
    Agent.prototype.addPatch = function(modules, handler) {
      return this._instrumentation.addPatch.apply(this._instrumentation, arguments);
    };
    Agent.prototype.removePatch = function(modules, handler) {
      return this._instrumentation.removePatch.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.clearPatches = function(modules) {
      return this._instrumentation.clearPatches.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.startTransaction = function(name, type, { startTime, childOf } = {}) {
      return this._instrumentation.startTransaction.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.endTransaction = function(result, endTime) {
      return this._instrumentation.endTransaction.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.setTransactionName = function(name) {
      return this._instrumentation.setTransactionName.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.setTransactionOutcome = function(outcome) {
      return this._instrumentation.setTransactionOutcome.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.startSpan = function(name, type, subtype, action, { startTime, childOf, exitSpan } = {}) {
      return this._instrumentation.startSpan.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype.setSpanOutcome = function(outcome) {
      return this._instrumentation.setSpanOutcome.apply(
        this._instrumentation,
        arguments
      );
    };
    Agent.prototype._config = function(opts) {
      this._conf = config.createConfig(opts, this.logger);
      this.logger = this._conf.logger;
    };
    Agent.prototype.isStarted = function() {
      return global[symbols.agentInitialized];
    };
    Agent.prototype.start = function(opts) {
      if (this.isStarted()) {
        throw new Error("Do not call .start() more than once");
      }
      global[symbols.agentInitialized] = true;
      this._config(opts);
      if (!this._conf.active) {
        this.logger.debug("Elastic APM agent disabled (`active` is false)");
        return this;
      }
      const preambleData = this._conf.loggingPreambleData;
      const isPreviewVersion = version.indexOf("-") !== -1;
      const startStack = {};
      if (this._conf.active && this._conf.serviceName) {
        this._origStackTraceLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = 20;
        Error.captureStackTrace(startStack);
        Error.stackTraceLimit = this._origStackTraceLimit;
        this._agentActivationMethod = agentActivationMethodFromStartStack(
          startStack,
          this.logger
        );
        preambleData.activationMethod = this._agentActivationMethod;
        if (this._conf.logLevel === "trace") {
          let pkg = null;
          try {
            var basedir = path.dirname(process.argv[1] || ".");
            pkg = require(path.join(basedir, "package.json"));
          } catch (e) {
          }
          preambleData.dependencies = pkg ? pkg.dependencies : "<could not determine>";
          preambleData.startTrace = startStack.stack.split(/\n */).slice(1);
        }
      }
      this.logger.info(preambleData, "Elastic APM Node.js Agent v%s", version);
      if (isPreviewVersion) {
        this.logger.warn(
          "Version %s is a pre-release and not intended for use in production environments",
          version
        );
      }
      if (!this._conf.serverUrl) {
        this.logger.error(
          "Elastic APM is incorrectly configured: Invalid serverUrl (APM will be disabled)"
        );
        this._conf.active = false;
        return this;
      }
      if (!this._conf.serviceName) {
        this.logger.error(
          "Elastic APM is incorrectly configured: Missing serviceName (APM will be disabled)"
        );
        this._conf.active = false;
        return this;
      }
      initStackTraceCollection();
      this._apmClient = createApmClient(this._conf, this);
      let runContextClass;
      if (this._conf.opentelemetryBridgeEnabled) {
        const {
          setupOTelBridge,
          OTelBridgeRunContext
        } = require_opentelemetry_bridge();
        runContextClass = OTelBridgeRunContext;
        setupOTelBridge(this);
      }
      this._instrumentation.start(runContextClass);
      if (this._isMetricsEnabled()) {
        this._metrics.start();
      }
      Error.stackTraceLimit = this._conf.stackTraceLimit;
      if (this._conf.captureExceptions) this.handleUncaughtExceptions();
      return this;
    };
    Agent.prototype._isMetricsEnabled = function() {
      return this._conf.metricsInterval !== 0 && !this._conf.contextPropagationOnly;
    };
    Agent.prototype._getOrCreateOTelMeterProvider = function() {
      if (this._otelMeterProvider) {
        return this._otelMeterProvider;
      }
      if (!this._isMetricsEnabled()) {
        return null;
      }
      if (!isOTelMetricsFeatSupported) {
        return null;
      }
      this.logger.trace("create Elastic APM MeterProvider for @opentelemetry/api");
      this._otelMeterProvider = createOTelMeterProvider(this);
      return this._otelMeterProvider;
    };
    Agent.prototype.getServiceName = function() {
      return this._conf ? this._conf.serviceName : void 0;
    };
    Agent.prototype.getServiceVersion = function() {
      return this._conf ? this._conf.serviceVersion : void 0;
    };
    Agent.prototype.getServiceEnvironment = function() {
      return this._conf ? this._conf.environment : void 0;
    };
    Agent.prototype.getServiceNodeName = function() {
      return this._conf ? this._conf.serviceNodeName : void 0;
    };
    Agent.prototype.setFramework = function({ name, version: version2, overwrite = true }) {
      if (!this._apmClient || !this._conf) {
        return;
      }
      const conf = {};
      if (name && (overwrite || !this._conf.frameworkName))
        this._conf.frameworkName = conf.frameworkName = name;
      if (version2 && (overwrite || !this._conf.frameworkVersion))
        this._conf.frameworkVersion = conf.frameworkVersion = version2;
      this._apmClient.config(conf);
    };
    Agent.prototype.setUserContext = function(context2) {
      var trans = this._instrumentation.currTransaction();
      if (!trans) return false;
      trans.setUserContext(context2);
      return true;
    };
    Agent.prototype.setCustomContext = function(context2) {
      var trans = this._instrumentation.currTransaction();
      if (!trans) return false;
      trans.setCustomContext(context2);
      return true;
    };
    Agent.prototype.setGlobalLabel = function(key, value) {
      if (!this._conf.globalLabels) this._conf.globalLabels = [];
      const foundPos = this._conf.globalLabels.findIndex(([name]) => key === name);
      if (foundPos > -1) {
        this._conf.globalLabels[foundPos][1] = value;
      } else {
        this._conf.globalLabels.push([key, value]);
      }
      if (!this._apmClient) {
        this.logger.warn("cannot setGlobalLabel on inactive or unconfigured agent");
        return;
      }
      this._apmClient.config({
        globalLabels: this._conf.globalLabels.reduce((acc, [k, v]) => {
          acc[k] = v;
          return acc;
        }, {})
      });
    };
    Agent.prototype.setLabel = function(key, value, stringify) {
      var trans = this._instrumentation.currTransaction();
      if (!trans) return false;
      return trans.setLabel(key, value, stringify);
    };
    Agent.prototype.addLabels = function(labels, stringify) {
      var trans = this._instrumentation.currTransaction();
      if (!trans) return false;
      return trans.addLabels(labels, stringify);
    };
    Agent.prototype.addFilter = function(fn) {
      this.addErrorFilter(fn);
      this.addTransactionFilter(fn);
      this.addSpanFilter(fn);
    };
    Agent.prototype.addErrorFilter = function(fn) {
      if (typeof fn !== "function") {
        this.logger.error("Can't add filter of type %s", typeof fn);
        return;
      }
      this._errorFilters.push(fn);
    };
    Agent.prototype.addTransactionFilter = function(fn) {
      if (typeof fn !== "function") {
        this.logger.error("Can't add filter of type %s", typeof fn);
        return;
      }
      this._transactionFilters.push(fn);
    };
    Agent.prototype.addSpanFilter = function(fn) {
      if (typeof fn !== "function") {
        this.logger.error("Can't add filter of type %s", typeof fn);
        return;
      }
      this._spanFilters.push(fn);
    };
    Agent.prototype.addMetadataFilter = function(fn) {
      if (typeof fn !== "function") {
        this.logger.error("Can't add filter of type %s", typeof fn);
        return;
      } else if (!this._apmClient) {
        this.logger.error(
          "cannot add metadata filter to inactive or unconfigured agent (agent has no transport)"
        );
        return;
      } else if (typeof this._apmClient.addMetadataFilter !== "function") {
        this.logger.error(
          "cannot add metadata filter: transport does not support addMetadataFilter"
        );
        return;
      }
      this._apmClient.addMetadataFilter(fn);
    };
    var EMPTY_OPTS = {};
    Agent.prototype.captureError = function(err, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = EMPTY_OPTS;
      } else if (!opts) {
        opts = EMPTY_OPTS;
      }
      const id = errors.generateErrorId();
      if (!this.isStarted()) {
        if (cb) {
          cb(new Error("cannot capture error before agent is started"), id);
        }
        return;
      }
      if (this._conf.contextPropagationOnly) {
        if (cb) {
          process.nextTick(cb, null, id);
        }
        return;
      }
      const agent = this;
      let callSiteLoc = null;
      const errIsError = isError(err);
      const handled = opts.handled !== false;
      const shouldCaptureAttributes = opts.captureAttributes !== false;
      const skipOutcome = Boolean(opts.skipOutcome);
      const timestampUs = opts.timestamp ? Math.floor(opts.timestamp * 1e3) : Date.now() * 1e3;
      let parent;
      let span;
      let trans;
      if (opts.parent === void 0) {
        parent = this._instrumentation.currSpan() || this._instrumentation.currTransaction();
      } else if (opts.parent === null) {
        parent = null;
      } else {
        parent = opts.parent;
      }
      if (parent instanceof Transaction) {
        span = null;
        trans = parent;
      } else if (parent instanceof Span) {
        span = parent;
        trans = parent.transaction;
      }
      const traceContext = (span || trans || {})._context;
      const req = opts.request instanceof IncomingMessage ? opts.request : trans && trans.req;
      const res = opts.response instanceof ServerResponse ? opts.response : trans && trans.res;
      if (handled && (agent._conf.captureErrorLogStackTraces === CAPTURE_ERROR_LOG_STACK_TRACES_ALWAYS || !errIsError && agent._conf.captureErrorLogStackTraces === CAPTURE_ERROR_LOG_STACK_TRACES_MESSAGES)) {
        callSiteLoc = {};
        Error.captureStackTrace(callSiteLoc, Agent.prototype.captureError);
      }
      if (span && !skipOutcome) {
        span._setOutcomeFromErrorCapture(constants.OUTCOME_FAILURE);
      }
      const inflightEvents = this._inflightEvents;
      inflightEvents.add(id);
      setImmediate(() => {
        const errorContext = {
          user: Object.assign(
            {},
            req && parsers.getUserContextFromRequest(req),
            trans && trans._user,
            opts.user
          ),
          tags: Object.assign({}, trans && trans._labels, opts.tags, opts.labels),
          custom: Object.assign({}, trans && trans._custom, opts.custom)
        };
        if (req) {
          errorContext.request = parsers.getContextFromRequest(
            req,
            agent._conf,
            "errors"
          );
        }
        if (res) {
          errorContext.response = parsers.getContextFromResponse(
            res,
            agent._conf,
            true
          );
        }
        errors.createAPMError(
          {
            log: agent.logger,
            id,
            exception: errIsError ? err : null,
            logMessage: errIsError ? null : err,
            shouldCaptureAttributes,
            timestampUs,
            handled,
            callSiteLoc,
            message: opts.message,
            sourceLinesAppFrames: agent._conf.sourceLinesErrorAppFrames,
            sourceLinesLibraryFrames: agent._conf.sourceLinesErrorLibraryFrames,
            trans,
            traceContext,
            errorContext,
            exceptionType: opts.exceptionType
          },
          function filterAndSendError(_err, apmError) {
            apmError = agent._errorFilters.process(apmError);
            if (!apmError) {
              agent.logger.debug("error ignored by filter %o", { id });
              inflightEvents.delete(id);
              if (cb) {
                cb(null, id);
              }
              return;
            }
            if (agent._apmClient) {
              agent.logger.debug("Sending error to Elastic APM: %o", { id });
              agent._apmClient.sendError(apmError);
              inflightEvents.delete(id);
              if (!handled || cb) {
                agent.flush(function(flushErr) {
                  if (cb) {
                    cb(flushErr, id);
                  }
                });
              }
            } else {
              inflightEvents.delete(id);
              if (cb) {
                cb(new Error("cannot send error: missing transport"), id);
              }
            }
          }
        );
      });
    };
    Agent.prototype.handleUncaughtExceptions = function(cb) {
      var agent = this;
      if (this._uncaughtExceptionListener) {
        process.removeListener(
          "uncaughtException",
          this._uncaughtExceptionListener
        );
      }
      this._uncaughtExceptionListener = function(err) {
        agent.logger.debug({ err }, "Elastic APM caught unhandled exception");
        console.error(err);
        agent.captureError(err, { handled: false }, function() {
          cb ? cb(err) : process.exit(1);
        });
      };
      process.on("uncaughtException", this._uncaughtExceptionListener);
    };
    Agent.prototype.flush = function(cb) {
      const DEFAULT_INFLIGHT_FLUSH_TIMEOUT_MS = 1e3;
      const opts = { inflightTimeoutMs: DEFAULT_INFLIGHT_FLUSH_TIMEOUT_MS };
      if (typeof cb !== "function") {
        return new Promise((resolve, reject) => {
          this._flush(opts, (err) => {
            if (err) {
              reject(err);
            }
            resolve();
          });
        });
      }
      return this._flush(opts, cb);
    };
    Agent.prototype._flush = function(opts, cb) {
      const lambdaEnd = !!opts.lambdaEnd;
      if (!this._apmClient) {
        const err = new Error("cannot flush agent before it is started");
        this.logger.warn({ err }, err.message);
        if (cb) {
          process.nextTick(cb);
        }
        return;
      }
      const boundCb = cb && this._instrumentation.bindFunction(cb);
      if (this._inflightEvents.size === 0) {
        this._apmClient.flush({ lambdaEnd }, boundCb);
        return;
      }
      const flushingInflightEvents = this._inflightEvents;
      flushingInflightEvents.setDrainHandler((drainErr) => {
        this.logger.debug(
          {
            numRemainingInflightEvents: flushingInflightEvents.size,
            err: drainErr
          },
          "flush: drained inflight events"
        );
        this._apmClient.flush({ lambdaEnd }, boundCb);
      }, opts.inflightTimeoutMs);
      this._inflightEvents = new InflightEventSet();
    };
    Agent.prototype.registerMetric = function(name, labelsOrCallback, callback) {
      var labels;
      if (typeof labelsOrCallback === "function") {
        callback = labelsOrCallback;
      } else {
        labels = labelsOrCallback;
      }
      if (typeof callback !== "function") {
        this.logger.error("Can't add callback of type %s", typeof callback);
        return;
      }
      this._metrics.getOrCreateGauge(name, callback, labels);
    };
    Agent.prototype._isMetricNameDisabled = function(name) {
      const regexps = this._conf.disableMetricsRegExp;
      for (var i = 0; i < regexps.length; i++) {
        if (regexps[i].test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/elastic-apm-node/index.js
var require_elastic_apm_node = __commonJS({
  "node_modules/elastic-apm-node/index.js"(exports2, module2) {
    "use strict";
    var Agent = require_agent2();
    module2.exports = new Agent();
  }
});

// node_modules/elastic-apm-node/start.js
var require_start = __commonJS({
  "node_modules/elastic-apm-node/start.js"(exports2, module2) {
    "use strict";
    var apm = require_elastic_apm_node();
    var isMainThread;
    try {
      workerThreads = require("worker_threads");
      isMainThread = workerThreads.isMainThread;
    } catch (_importErr) {
      isMainThread = true;
    }
    var workerThreads;
    if (isMainThread) {
      apm.start();
    }
    module2.exports = apm;
  }
});

// app-ok1.ts
var import_start = __toESM(require_start());
/*! Bundled license information:

basic-auth/index.js:
  (*!
   * basic-auth
   * Copyright(c) 2013 TJ Holowaychuk
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

humanize-ms/index.js:
  (*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
